<!DOCTYPE HTML>
<html lang="zh-CN" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Warp Parse 文档 [ALPHA]</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/lang-switch.css">
        <link rel="stylesheet" href="../theme/version-badge.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "ayu";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b509f17a.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-ca145d02.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Warp Parse 文档 [ALPHA]</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/wp-labs/warp-parse" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="使用指南"><a class="header" href="#使用指南">使用指南</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="warpparse-核心概念速查"><a class="header" href="#warpparse-核心概念速查">WarpParse 核心概念速查</a></h1>
<p>本文档帮助零基础用户快速理解 WarpParse 的核心概念和术语。</p>
<h2 id="什么是-etl"><a class="header" href="#什么是-etl">什么是 ETL？</a></h2>
<p>ETL 是 Extract（提取）、Transform（转换）、Load（加载）的缩写。简单来说：</p>
<ul>
<li><strong>Extract（提取）</strong>：从日志文件、数据库、消息队列等地方读取原始数据</li>
<li><strong>Transform（转换）</strong>：把非结构化的文本转换成结构化的数据（如 JSON）</li>
<li><strong>Load（加载）</strong>：把处理好的数据存储到目标位置（文件、数据库、ES 等）</li>
</ul>
<h3 id="类比理解"><a class="header" href="#类比理解">类比理解</a></h3>
<p>就像一个智能快递分拣系统：</p>
<ul>
<li><strong>Extract</strong> = 收件（从各个地方收集包裹）</li>
<li><strong>Transform</strong> = 分类（按地址、类型分类打标签）</li>
<li><strong>Load</strong> = 派送（送到对应的目的地）</li>
</ul>
<hr>
<h2 id="warpparse-核心术语"><a class="header" href="#warpparse-核心术语">WarpParse 核心术语</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>术语</th><th>英文</th><th>通俗解释</th><th>类比</th></tr>
</thead>
<tbody>
<tr><td><strong>输入源</strong></td><td>Source</td><td>数据从哪里来</td><td>水源（文件、TCP、Kafka）</td></tr>
<tr><td><strong>输出源</strong></td><td>Sink</td><td>数据到哪里去</td><td>水池（文件、数据库、ES）</td></tr>
<tr><td><strong>连接器</strong></td><td>Connector</td><td>如何连接数据源/目标</td><td>水管接头（配置连接参数）</td></tr>
<tr><td><strong>WPL</strong></td><td>Warp Processing Language</td><td>数据提取规则语言</td><td>筛子（定义如何从文本中提取字段）</td></tr>
<tr><td><strong>OML</strong></td><td>Object Modeling Language</td><td>数据组装规则语言</td><td>模具（定义如何组装成目标格式）</td></tr>
<tr><td><strong>规则</strong></td><td>Rule</td><td>一条解析规则</td><td>一个筛子的设计图纸</td></tr>
<tr><td><strong>字段</strong></td><td>Field</td><td>要提取的数据项</td><td>筛子上的一个孔</td></tr>
<tr><td><strong>管道</strong></td><td>Pipe</td><td>数据处理流程</td><td>水管（数据流动的路径）</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="数据流转过程"><a class="header" href="#数据流转过程">数据流转过程</a></h2>
<pre><code>原始日志 → [Source 读取] → [WPL 解析] → [OML 转换] → [Sink 输出] → 目标存储
   ↓              ↓              ↓              ↓              ↓
文件/TCP      connectors     提取字段       组装对象      文件/DB/ES
</code></pre>
<h3 id="详细说明"><a class="header" href="#详细说明">详细说明</a></h3>
<ol>
<li>
<p><strong>Source 读取</strong>：从配置的数据源读取原始数据</p>
<ul>
<li>文件：读取日志文件</li>
<li>TCP：监听网络端口接收数据</li>
<li>Kafka：从消息队列消费数据</li>
</ul>
</li>
<li>
<p><strong>WPL 解析</strong>：使用 WPL 规则从原始文本中提取字段</p>
<ul>
<li>识别 IP 地址、时间、数字等类型</li>
<li>解析 JSON、KV 等结构化数据</li>
<li>验证和过滤字段</li>
</ul>
</li>
<li>
<p><strong>OML 转换</strong>：使用 OML 规则组装输出格式</p>
<ul>
<li>字段重命名和映射</li>
<li>类型转换（字符串→数字→时间）</li>
<li>条件判断和计算</li>
</ul>
</li>
<li>
<p><strong>Sink 输出</strong>：将处理后的数据写入目标</p>
<ul>
<li>文件：保存为 JSON/CSV 等格式</li>
<li>数据库：写入 MySQL/PostgreSQL</li>
<li>搜索引擎：写入 Elasticsearch</li>
</ul>
</li>
</ol>
<hr>
<h2 id="快速入门路径"><a class="header" href="#快速入门路径">快速入门路径</a></h2>
<p>阶段一：<br>1、跑通 Getting Started，看到数据流转起来<br>2、学习 WPL 基础类型（ip、digit、time、chars）<br>3、学习 OML 数据组装<br>4、在 editor 学习了解 demo 样例</p>
<p>阶段二：<br>1、在 editor 上开始完成 T1 题目<br>2、在自己空间下创建 wpl和oml<br>3、配置 Source 和 Sink<br>4、使用 wpgen 生成样例数据，wparse 进行执行查看输出</p>
<hr>
<h2 id="项目目录结构"><a class="header" href="#项目目录结构">项目目录结构</a></h2>
<pre><code>工作目录/
├── conf/              # 配置文件
│   ├── wparse.toml   # 解析引擎配置
│   └── wpgen.toml    # 数据生成器配置
│
├── connectors/        # 连接器定义
│   ├── sink.d/       # 输出连接器（数据去哪里）
│   └── source.d/     # 输入连接器（数据从哪来）
│
├── data/              # 数据目录
│   ├── in_dat/       # 输入数据（原始日志）
│   │   └── gen.dat  # 生成的测试数据
│   ├── out_dat/      # 输出数据（解析结果）
│   │   ├── demo.json       # 所有成功解析的记录
│   │   ├── default.dat     # 命中wpl未命中oml异常数据
│   │   ├── error.dat       # 异常数据
│   │   ├── miss.dat        # 未命中wpl异常数据
│   │   ├── monitor.dat     # 监控数据
│   │   └── residue.dat     # 残留数据（部分解析成功）
│   ├── logs/         # 运行日志
│   └── rescue/       # 失败数据（用于排查问题）
│
├── models/            # 模型定义
│   ├── wpl/          # WPL 解析规则
│   │   └── wp-space/
│   │       ├── parse.wpl    # 解析规则文件
│   │       └── sample.dat   # 规则测试样本
│   ├── oml/          # OML 转换规则
│   │   └── wp-space/
│   │       └── adm.oml      # 对象映射规则
│   └── knowledge/    # 知识库（SQL 查询等）
│
└── topology/          # 拓扑配置
    ├── sources/      # 数据源配置
    └── sinks/        # 数据目标配置
</code></pre>
<h3 id="目录说明"><a class="header" href="#目录说明">目录说明</a></h3>
<ul>
<li><strong>conf/</strong>：全局配置，如日志级别、性能参数</li>
<li><strong>connectors/</strong>：定义如何连接数据源和目标</li>
<li><strong>data/</strong>：所有数据文件的存放位置
<ul>
<li><strong>in_dat/</strong>：存放原始输入数据
<ul>
<li><code>gen.dat</code>：wpgen 生成的测试数据</li>
</ul>
</li>
<li><strong>out_dat/</strong>：存放解析后的输出数据
<ul>
<li><code>all.json</code>：所有成功解析的记录（JSON 格式）</li>
<li><code>default.dat</code>：默认输出文件</li>
<li><code>error.dat</code>：解析过程中出错的记录</li>
<li><code>ignore.dat</code>：根据规则被忽略的记录</li>
<li><code>miss.dat</code>：缺失必需字段的记录</li>
<li><code>monitor.dat</code>：监控和统计数据</li>
<li><code>residue.dat</code>：部分字段解析成功的残留数据</li>
</ul>
</li>
<li><strong>logs/</strong>：运行时日志，用于调试和排查问题</li>
<li><strong>rescue/</strong>：解析失败的原始数据，用于重新处理</li>
</ul>
</li>
<li><strong>models/</strong>：核心业务逻辑（WPL 规则和 OML 规则）
<ul>
<li><strong>wpl/</strong>：WPL 解析规则，按命名空间组织
<ul>
<li><code>wp-space/parse.wpl</code>：具体的解析规则文件</li>
<li><code>wp-space/sample.dat</code>：规则对应的测试样本</li>
</ul>
</li>
<li><strong>oml/</strong>：OML 转换规则，按命名空间组织
<ul>
<li><code>wp-space/adm.oml</code>：对象映射和转换规则</li>
</ul>
</li>
<li><strong>knowledge/</strong>：知识库，如 SQL 查询、IP 库等</li>
</ul>
</li>
<li><strong>topology/</strong>：数据流拓扑配置</li>
</ul>
<hr>
<h2 id="常用命令速查"><a class="header" href="#常用命令速查">常用命令速查</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>命令</th><th>功能</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><code>wproj init</code></td><td>初始化项目</td><td><code>wproj init --mode full</code></td></tr>
<tr><td><code>wproj check</code></td><td>检查配置</td><td><code>wproj check</code></td></tr>
<tr><td><code>wproj data stat</code></td><td>统计数据</td><td><code>wproj data stat</code></td></tr>
<tr><td><code>wpgen sample</code></td><td>生成测试数据</td><td><code>wpgen sample -n 3000</code></td></tr>
<tr><td><code>wparse batch</code></td><td>批处理模式</td><td><code>wparse batch --stat 3 -p</code></td></tr>
<tr><td><code>wparse daemon</code></td><td>守护进程模式</td><td><code>wparse daemon --stat-print</code></td></tr>
<tr><td><code>wprescue batch</code></td><td>恢复失败数据</td><td><code>wprescue batch</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="下一步"><a class="header" href="#下一步">下一步</a></h2>
<p>阅读完本文档后，建议按以下顺序学习：</p>
<ol>
<li><strong><a href="#gettingstarted">快速入门</a></strong>：10 分钟跑通第一个示例</li>
<li><strong><a href="#wpl-快速入门">WPL 语言基础</a></strong>：学习数据提取规则</li>
<li><strong><a href="10-user/04-oml/README.html">OML 语言基础</a></strong>：学习数据组装规则</li>
</ol>
<hr>
<h2 id="相关文档"><a class="header" href="#相关文档">相关文档</a></h2>
<ul>
<li><a href="#gettingstarted">快速入门</a></li>
<li><a href="10-user/01-cli/README.html">CLI 工具集</a></li>
<li><a href="10-user/03-wpl/README.html">WPL 语言</a></li>
<li><a href="10-user/04-oml/README.html">OML 语言</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-工具集"><a class="header" href="#cli-工具集">CLI 工具集</a></h1>
<p>本文档集合介绍 WarpParse提供的完整命令行工具集，包括数据解析、生成、项目管理等功能。</p>
<h2 id="工具总览"><a class="header" href="#工具总览">工具总览</a></h2>
<h3 id="核心工具"><a class="header" href="#核心工具">核心工具</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>工具</th><th>功能描述</th><th>主要用途</th></tr>
</thead>
<tbody>
<tr><td><strong>wparse</strong></td><td>数据解析引擎</td><td>实时数据流处理、批处理分析</td></tr>
<tr><td><strong>wpgen</strong></td><td>数据生成器</td><td>基于规则或样本生成测试数据</td></tr>
<tr><td><strong>wproj</strong></td><td>项目管理工具</td><td>项目初始化、配置管理、数据统计</td></tr>
<tr><td><strong>wprescue</strong></td><td>数据恢复工具</td><td>从救援目录恢复处理失败的数据</td></tr>
</tbody>
</table>
</div>
<h2 id="快速参考"><a class="header" href="#快速参考">快速参考</a></h2>
<h3 id="wparse---数据解析引擎"><a class="header" href="#wparse---数据解析引擎">wparse - 数据解析引擎</a></h3>
<pre><code class="language-bash"># 守护进程模式（持续运行）
wparse daemon --work-root ./myproject --stat-print

# 批处理模式
wparse batch --work-root ./myproject --max-line 10000 --stat 5

</code></pre>
<h3 id="wpgen---数据生成器"><a class="header" href="#wpgen---数据生成器">wpgen - 数据生成器</a></h3>
<pre><code class="language-bash"># 基于规则生成数据
wpgen rule --work-root ./myproject --print-stat --line-cnt 10000

# 基于样本生成数据
wpgen sample --work-root ./myproject --line-cnt 5000

# 配置管理
wpgen conf init
wpgen conf check
wpgen conf clean

# 数据管理
wpgen data clean
wpgen data check

</code></pre>
<h3 id="wproj---项目管理工具"><a class="header" href="#wproj---项目管理工具">wproj - 项目管理工具</a></h3>
<pre><code class="language-bash"># 项目初始化
wproj init --mode full

# 项目检查
wproj check

# 数据清理
wproj data clean

# 统计功能
wproj stat file
wproj stat file --output json

# 模型管理
wproj model list
wproj model validate

# 规则工具
wproj rule parse --rule-id myrule
wproj rule test --input sample.log

# 配置管理
wproj sinks list
wproj sinks validate
wproj sinks route

</code></pre>
<h3 id="wprescue---数据恢复工具"><a class="header" href="#wprescue---数据恢复工具">wprescue - 数据恢复工具</a></h3>
<pre><code class="language-bash"># 批处理模式恢复数据
wprescue batch --work-root ./myproject

</code></pre>
<h2 id="工具关系图"><a class="header" href="#工具关系图">工具关系图</a></h2>
<pre class="mermaid">graph TD
    A[wproj] --&gt; B[初始化项目]
    A --&gt; C[检查配置]
    A --&gt; D[统计数据]

    B --&gt; E[生成配置文件]
    B --&gt; F[创建目录结构]

    C --&gt; G[验证配置有效性]

    D --&gt; H[源数据统计]
    D --&gt; I[输出数据统计]

    J[wpgen] --&gt; K[生成测试数据]
    J --&gt; L[管理生成器配置]
    J --&gt; M[管理输出数据]

    N[wparse] --&gt; O[实时流处理]
    N --&gt; P[批处理分析]
    N --&gt; Q[性能调优]

    R[wprescue] --&gt; S[数据恢复]
    R --&gt; T[故障恢复]
</pre>

<h2 id="学习路径"><a class="header" href="#学习路径">学习路径</a></h2>
<ol>
<li><strong>初学者</strong>：从 <a href="#gettingstarted">快速入门指南</a> 开始，了解完整的配置和使用流程</li>
<li><strong>进阶用户</strong>：深入学习 <a href="#wparse">wparse 运行模式</a>，理解两种运行模式的区别和适用场景</li>
<li><strong>数据工程师</strong>：掌握 <a href="#wpgen">wpgen 使用指南</a>，能够生成各种测试数据</li>
<li><strong>运维人员</strong>：使用 <a href="#wproj">wproj 项目管理</a> 进行日常的项目管理和监控</li>
<li><strong>故障处理</strong>：参考 <a href="#wprescue">wprescue 数据恢复</a> 处理异常情况</li>
</ol>
<h2 id="常见使用场景"><a class="header" href="#常见使用场景">常见使用场景</a></h2>
<h3 id="实时流处理"><a class="header" href="#实时流处理">实时流处理</a></h3>
<pre><code class="language-bash"># 启动守护进程，持续处理数据流
wparse daemon \
  --work-root ./myproject \
  --stat-print \
  --robust online
</code></pre>
<h3 id="批量数据分析"><a class="header" href="#批量数据分析">批量数据分析</a></h3>
<pre><code class="language-bash"># 批处理分析历史数据
wparse batch \
  --work-root ./myproject \
  --max-line 100000 \
  --check-continue 1000 \
  --stat 10
</code></pre>
<h3 id="开发测试"><a class="header" href="#开发测试">开发测试</a></h3>
<pre><code class="language-bash"># 开发模式，详细日志
wparse batch \
  --work-root ./myproject \
  --log-profile dev \
  --max-line 100 \
  --stat 1
</code></pre>
<h3 id="数据生成测试"><a class="header" href="#数据生成测试">数据生成测试</a></h3>
<pre><code class="language-bash"># 生成特定场景的测试数据
wpgen rule \
  --work-root ./myproject \
  --conf-name test.toml \
  --line-cnt 10000 \
  --gen-speed 1000
</code></pre>
<h2 id="故障排除"><a class="header" href="#故障排除">故障排除</a></h2>
<h3 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h3>
<ol>
<li>
<p><strong>配置文件找不到</strong></p>
<ul>
<li>确保在正确的工作目录下运行命令</li>
<li>使用 <code>--work-root</code> 参数指定工作目录</li>
</ul>
</li>
<li>
<p><strong>权限错误</strong></p>
<ul>
<li>检查工作目录和日志目录的写权限</li>
<li>确保有足够的磁盘空间</li>
</ul>
</li>
<li>
<p><strong>内存不足</strong></p>
<ul>
<li>减少 <code>--max-line</code> 或 <code>--parse-workers</code> 参数值</li>
<li>使用 <code>--robust</code> 参数设置合适的鲁棒模式</li>
</ul>
</li>
<li>
<p><strong>数据源连接失败</strong></p>
<ul>
<li>检查 <code>connectors/source.d/</code> 目录下的连接器配置</li>
<li>验证网络连接和认证信息</li>
</ul>
</li>
</ol>
<h3 id="日志分析"><a class="header" href="#日志分析">日志分析</a></h3>
<pre><code class="language-bash"># 查看实时日志
tail -f logs/wparse.log

# 搜索错误日志
grep -i error logs/*.log

# 使用 wproj 进行项目检查
wproj check --work-root ./myproject
</code></pre>
<h2 id="版本信息"><a class="header" href="#版本信息">版本信息</a></h2>
<p>查看工具版本：</p>
<pre><code class="language-bash">wparse --version
wpgen --version
wproj --version
wprescue --version
</code></pre>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>变量名</th><th>描述</th></tr>
</thead>
<tbody>
<tr><td><code>WP_PARSE_ROBUST</code></td><td>设置全局鲁棒模式</td></tr>
<tr><td><code>WP_PARSE_LOG_LEVEL</code></td><td>覆盖日志级别</td></tr>
<tr><td><code>RUST_LOG</code></td><td>Rust 日志级别（调试用）</td></tr>
</tbody>
</table>
</div>
<h2 id="退出码"><a class="header" href="#退出码">退出码</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>退出码</th><th>含义</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>成功</td></tr>
<tr><td>1</td><td>通用错误</td></tr>
<tr><td>2</td><td>配置错误</td></tr>
<tr><td>3</td><td>数据错误</td></tr>
<tr><td>4</td><td>网络错误</td></tr>
<tr><td>5</td><td>权限错误</td></tr>
</tbody>
</table>
</div>
<h2 id="技术架构"><a class="header" href="#技术架构">技术架构</a></h2>
<p>CLI 工具采用 Rust 编写，使用 clap 框架处理命令行参数，tokio 异步运行时。核心功能通过 <code>wp-engine</code> 库的 facade 模式对外暴露，确保 API 稳定性和向后兼容性。</p>
<h3 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h3>
<pre><code>warp-parse/
├── src/
│   ├── wparse/          # 数据解析引擎
│   │   └── main.rs
│   ├── wpgen/            # 数据生成器
│   │   ├── main.rs
│   │   ├── cli.rs       # CLI 定义
│   │   ├── rule.rs      # 规则生成逻辑
│   │   ├── sample.rs    # 样本生成逻辑
│   │   ├── conf.rs      # 配置管理
│   │   └── data.rs      # 数据管理
│   ├── wproj/            # 项目管理
│   │   └── main.rs
│   └── wprescue/         # 数据恢复
│       └── main.rs
└── wp-engine/            # 核心引擎库
    └── facade/args.rs    # 参数定义
</code></pre>
<p>这种设计确保了：</p>
<ol>
<li><strong>模块化</strong>：每个工具职责单一，易于维护</li>
<li><strong>复用性</strong>：核心功能通过库共享</li>
<li><strong>可扩展性</strong>：便于添加新的 CLI 工具</li>
</ol>
<h2 id="相关链接"><a class="header" href="#相关链接">相关链接</a></h2>
<ul>
<li><a href="https://github.com/wp-labs/warp-parse">项目主页</a></li>
<li><a href="https://github.com/wp-labs/warp-parse/releases">下载页面</a></li>
<li><a href="10-user/02-config">配置参考</a></li>
<li><a href="10-user">用户文档</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="gettingstarted"><a class="header" href="#gettingstarted">GettingStarted</a></h1>
<h2 id="前置准备"><a class="header" href="#前置准备">前置准备</a></h2>
<ul>
<li><a href="https://github.com/wp-labs/warp-parse/releases">下载 wparse</a></li>
<li>copy到可执行路径下。如 /usr/local/bin 或 /${HOME}/bin</li>
</ul>
<h2 id="一初始化工作目录"><a class="header" href="#一初始化工作目录">一、初始化工作目录</a></h2>
<ul>
<li>清理并初始化配置与模板
<pre><code class="language-bash">wproj init --mode full
wproj check 
</code></pre>
</li>
</ul>
<p>执行完成后，工作目录将包含：</p>
<pre><code>├── conf
│   ├── wparse.toml
│   └── wpgen.toml
├── connectors
│   ├── sink.d
│   └── source.d
├── data
│   ├── in_dat
│   ├── logs
│   ├── out_dat
│   └── rescue
├── models
│   ├── knowledge
│   ├── oml
│   └── wpl
└── topology
    ├── sinks
    └── sources
</code></pre>
<h2 id="二生成数据与清理"><a class="header" href="#二生成数据与清理">二、生成数据与清理</a></h2>
<pre><code class="language-bash">wproj data clean 
wpgen data clean 

# 生成样本（示例 3000 行，3 秒统计间隔）
wpgen sample -n 3000 --stat 3
</code></pre>
<h2 id="三运行解析"><a class="header" href="#三运行解析">三、运行解析</a></h2>
<pre><code class="language-bash"># 批处理（-n 指定条数，-p 打印统计；失败时查看 ./logs/ 下日志）
wparse batch --stat 3 -p  
</code></pre>
<h2 id="四统计与校验"><a class="header" href="#四统计与校验">四、统计与校验</a></h2>
<pre><code class="language-bash"># 同时统计源与文件型 sink
wproj  data stat
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wproj"><a class="header" href="#wproj">Wproj</a></h1>
<p>wproj 是 Warp Parse 项目管理工具，提供完整的项目生命周期管理功能，包括项目初始化和配置管理、数据源的检查和统计、模型管理和知识库创建维护。</p>
<h2 id="命令概览"><a class="header" href="#命令概览">命令概览</a></h2>
<pre><code>wproj &lt;COMMAND&gt;

Commands:
  rule   规则工具：解析规则的管理和调试 | Rule tools: management and debugging of parsing rules
  init   一键初始化完整工程骨架 | Initialize complete project skeleton
  check  批量检查项目配置和文件完整性 | Batch check project configuration and file integrity
  data   数据管理工具：清理、统计、验证 | Data management tools: cleanup, statistics, validation
  model  模型管理工具：规则、源、汇、知识库 | Model management tools: rules, sources, sinks, knowledge base
</code></pre>
<hr>
<h2 id="init---项目初始化"><a class="header" href="#init---项目初始化">init - 项目初始化</a></h2>
<p>一键创建项目目录结构和默认配置。</p>
<pre><code class="language-bash">wproj init [OPTIONS]
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>短选项</th><th>长选项</th><th>默认值</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>mode</td><td><code>-m</code></td><td><code>--mode</code></td><td><code>conf</code></td><td>初始化模式</td></tr>
</tbody>
</table>
</div>
<p><strong>初始化模式：</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>模式</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>full</code></td><td>完整项目（配置+模型+数据+示例+链接器）</td></tr>
<tr><td><code>normal</code></td><td>完整项目（配置+模型+数据+示例）</td></tr>
<tr><td><code>model</code></td><td>仅模型文件</td></tr>
<tr><td><code>conf</code></td><td>仅配置文件</td></tr>
<tr><td><code>data</code></td><td>仅数据目录</td></tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 初始化配置（默认）
wproj init -w /project

# 初始化完整项目
wproj init -w /project --mode full
</code></pre>
<hr>
<h2 id="check---项目检查"><a class="header" href="#check---项目检查">check - 项目检查</a></h2>
<p>批量检查项目配置和文件完整性。</p>
<pre><code class="language-bash">wproj check [OPTIONS]
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>短选项</th><th>长选项</th><th>默认值</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>work_root</td><td><code>-w</code></td><td><code>--work-root</code></td><td><code>.</code></td><td>根目录</td></tr>
<tr><td>what</td><td>-</td><td><code>--what</code></td><td><code>all</code></td><td>检查项</td></tr>
<tr><td>console</td><td>-</td><td><code>--console</code></td><td>false</td><td>控制台日志输出</td></tr>
<tr><td>fail_fast</td><td>-</td><td><code>--fail-fast</code></td><td>false</td><td>首次失败即退出</td></tr>
<tr><td>json</td><td>-</td><td><code>--json</code></td><td>false</td><td>JSON 格式输出</td></tr>
<tr><td>only_fail</td><td>-</td><td><code>--only-fail</code></td><td>false</td><td>仅输出失败项</td></tr>
</tbody>
</table>
</div>
<p><strong>检查项（–what）：</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>值</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>conf</code></td><td>主配置文件</td></tr>
<tr><td><code>connectors</code></td><td>连接器配置</td></tr>
<tr><td><code>sources</code></td><td>数据源配置</td></tr>
<tr><td><code>sinks</code></td><td>数据汇配置</td></tr>
<tr><td><code>wpl</code></td><td>WPL 规则语法</td></tr>
<tr><td><code>oml</code></td><td>OML 模型语法</td></tr>
<tr><td><code>all</code></td><td>全部检查（默认）</td></tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 全面检查
wproj check -w /project --what all

# 仅检查配置和规则，首次失败即退出
wproj check -w /project --what conf,wpl --fail-fast

# JSON 输出，仅显示失败项
wproj check -w /project --json --only-fail
</code></pre>
<hr>
<h2 id="data---数据管理"><a class="header" href="#data---数据管理">data - 数据管理</a></h2>
<pre><code class="language-bash">wproj data &lt;SUBCOMMAND&gt;

Subcommands:
  clean     清理本地输出文件
  check     检查数据源连通性
  stat      统计数据量和性能
  validate  验证数据分布和比例
</code></pre>
<h3 id="data-clean"><a class="header" href="#data-clean">data clean</a></h3>
<p>清理项目输出数据。</p>
<pre><code class="language-bash">wproj data clean
</code></pre>
<h3 id="data-stat"><a class="header" href="#data-stat">data stat</a></h3>
<p>统计数据量。</p>
<pre><code class="language-bash">wproj data stat 
</code></pre>
<h3 id="data-validate"><a class="header" href="#data-validate">data validate</a></h3>
<p>验证数据分布和比例。</p>
<pre><code class="language-bash">wproj data validate [OPTIONS]
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>短选项</th><th>长选项</th><th>默认值</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>input_cnt</td><td>-</td><td><code>--input-cnt</code></td><td>-</td><td>输入总数（分母）</td></tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 清理输出数据
wproj data clean 

# 统计源+SINK文件行数
wproj data stat 

# 验证数据分布
wproj data validate 
</code></pre>
<hr>
<h2 id="model---模型管理"><a class="header" href="#model---模型管理">model - 模型管理</a></h2>
<p>TODO!</p>
<hr>
<h2 id="rule---规则工具"><a class="header" href="#rule---规则工具">rule - 规则工具</a></h2>
<p>离线解析测试，验证 WPL 规则。</p>
<pre><code class="language-bash">wproj rule parse [OPTIONS]
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 使用规则执行离线解析测试
wproj rule parse 
</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="wparse"><a class="header" href="#wparse">Wparse</a></h1>
<h2 id="运行模式"><a class="header" href="#运行模式">运行模式</a></h2>
<ul>
<li>两种运行模式：<code>wparse daemon</code>（常驻服务）和 <code>wparse batch</code>（批处理）</li>
<li>批处理模式读完文件后自动退出，daemon 模式需信号触发退出</li>
</ul>
<h2 id="命令行参数"><a class="header" href="#命令行参数">命令行参数</a></h2>
<pre><code>wparse &lt;COMMAND&gt;

Commands:
  daemon  守护进程模式（常驻服务）
  batch   批处理模式（读完即退）
</code></pre>
<h3 id="通用参数"><a class="header" href="#通用参数">通用参数</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>短选项</th><th>长选项</th><th>默认值</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>parse_workers</td><td><code>-w</code></td><td><code>--parse-workers</code></td><td>-</td><td>解析线程数</td></tr>
<tr><td>stat_sec</td><td>-</td><td><code>--stat</code></td><td>-</td><td>统计输出间隔（秒）</td></tr>
<tr><td>stat_print</td><td><code>-p</code></td><td><code>--print_stat</code></td><td>false</td><td>周期打印统计信息</td></tr>
<tr><td>wpl_dir</td><td>-</td><td><code>--wpl</code></td><td>-</td><td>WPL 规则目录覆盖</td></tr>
</tbody>
</table>
</div>
<h2 id="使用示例"><a class="header" href="#使用示例">使用示例</a></h2>
<pre><code class="language-bash"># 批处理模式：处理 3000 条后退出，每 2 秒输出统计
wparse batch -n 3000 --stat 2 -p

# 批处理模式：指定工作目录和多线程
wparse batch  -w 4 --parse-workers 4

# 守护进程模式：常驻服务，每 5 秒输出统计
wparse daemon --stat 5 -p

# 自定义日志和规则目录
wparse daemon --log-profile custom.toml --wpl /custom/rules
</code></pre>
<h2 id="退出策略"><a class="header" href="#退出策略">退出策略</a></h2>
<h3 id="批处理模式batch"><a class="header" href="#批处理模式batch">批处理模式（batch）</a></h3>
<p>单源（picker）结束条件（任一满足）：</p>
<ul>
<li>上游 EOF（文件读取完毕）</li>
<li>收到 Stop 指令</li>
<li>致命错误（触发全局停机）</li>
</ul>
<p>进程退出流程：</p>
<ol>
<li>所有数据源的 picker 结束</li>
<li>主组完成</li>
<li>sink/infra 组依序下线</li>
<li>进程退出</li>
</ol>
<p>关键日志：</p>
<ul>
<li>每个源结束：<code>数据源 '...' picker 正常结束</code></li>
<li>全局收尾：<code>all routine group await end!</code></li>
</ul>
<h3 id="守护进程模式daemon"><a class="header" href="#守护进程模式daemon">守护进程模式（daemon）</a></h3>
<ul>
<li>启动 acceptor（网络监听等）</li>
<li>进程保持常驻运行</li>
<li>退出触发方式：
<ul>
<li>SIGTERM/SIGINT/SIGQUIT 信号</li>
<li>控制总线 Stop 指令（企业版）</li>
</ul>
</li>
</ul>
<h2 id="错误与重试策略"><a class="header" href="#错误与重试策略">错误与重试策略</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>错误类型</th><th>策略</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>EOF</td><td>Terminate</td><td>优雅结束当前源</td></tr>
<tr><td>断线/可重试</td><td>FixRetry</td><td>指数退避后继续</td></tr>
<tr><td>数据/业务可容忍</td><td>Tolerant</td><td>记录后继续</td></tr>
<tr><td>致命错误</td><td>Throw</td><td>触发全局停机</td></tr>
</tbody>
</table>
</div>
<h2 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h2>
<p><strong>Q：为什么 batch 下不启动 acceptor？</strong></p>
<p>A：acceptor 是常驻组件（监听网络），会阻塞主组完成。batch 目标是“源结束 → 主组完成 → 进程退出“。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpgen"><a class="header" href="#wpgen">Wpgen</a></h1>
<p>wpgen 是 WarpParse 数据生成器，用于基于WPL规则或样本文件生成测试数据。</p>
<h2 id="命令概览-1"><a class="header" href="#命令概览-1">命令概览</a></h2>
<pre><code>wpgen &lt;COMMAND&gt;

Commands:
  rule    Generate data by rule/基于规则生成数据
  sample  Generate data from sample files/基于样本文件生成数据
  conf    Configuration commands/配置相关命令
  data    Data management commands/数据管理相关命令
</code></pre>
<h2 id="子命令详解"><a class="header" href="#子命令详解">子命令详解</a></h2>
<h3 id="rule---基于规则生成"><a class="header" href="#rule---基于规则生成">rule - 基于规则生成</a></h3>
<p>基于 WPL 规则生成测试数据，支持规则验证和性能分析。</p>
<pre><code class="language-bash">wpgen rule [OPTIONS]
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>短选项</th><th>长选项</th><th>默认值</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>wpl_dir</td><td>-</td><td><code>--wpl</code></td><td>-</td><td>WPL 规则目录覆盖</td></tr>
<tr><td>conf_name</td><td><code>-c</code></td><td><code>--conf</code></td><td><code>wpgen.toml</code></td><td>配置文件名</td></tr>
<tr><td>stat_print</td><td><code>-p</code></td><td><code>--print_stat</code></td><td>false</td><td>周期打印统计信息</td></tr>
<tr><td>line_cnt</td><td><code>-n</code></td><td>-</td><td>-</td><td>总行数覆盖</td></tr>
<tr><td>speed</td><td><code>-s</code></td><td>-</td><td>-</td><td>生成速度（行/秒）覆盖</td></tr>
<tr><td>stat_sec</td><td>-</td><td><code>--stat</code></td><td>1</td><td>统计输出间隔（秒）</td></tr>
</tbody>
</table>
</div>
<h3 id="sample---基于样本生成"><a class="header" href="#sample---基于样本生成">sample - 基于样本生成</a></h3>
<p>基于样本文件（sample.dat）生成测试数据。</p>
<pre><code class="language-bash">wpgen sample [OPTIONS]
</code></pre>
<h3 id="conf---配置管理"><a class="header" href="#conf---配置管理">conf - 配置管理</a></h3>
<pre><code class="language-bash">wpgen conf &lt;SUBCOMMAND&gt;

Subcommands:
  init   初始化生成器配置（conf/wpgen.toml）
  clean  清理生成器配置
  check  检查配置有效性
</code></pre>
<h3 id="data---数据管理-1"><a class="header" href="#data---数据管理-1">data - 数据管理</a></h3>
<pre><code class="language-bash">wpgen data &lt;SUBCOMMAND&gt;

Subcommands:
  clean  Clean generated output data according to wpgen config/根据 wpgen 配置清理已生成输出数据
  check  Not supported; reserved for future/暂不支持；保留供未来使用
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>短选项</th><th>长选项</th><th>默认值</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>conf_name</td><td><code>-c</code></td><td><code>--conf</code></td><td><code>wpgen.toml</code></td><td>配置文件名</td></tr>
</tbody>
</table>
</div>
<h2 id="运行语义"><a class="header" href="#运行语义">运行语义</a></h2>
<h3 id="count总产出条数"><a class="header" href="#count总产出条数">count（总产出条数）</a></h3>
<p>启动时按 <code>parallel</code> 精确均分到每个 worker，余数前置分配。各 worker 跑完本地任务量即退出，总量严格等于 <code>count</code>。</p>
<h3 id="speed全局速率"><a class="header" href="#speed全局速率">speed（全局速率）</a></h3>
<ul>
<li><code>speed = 0</code>：无限制（不等待）</li>
<li><code>speed &gt; 0</code>：每 worker 速率为 <code>floor(speed / parallel)</code></li>
</ul>
<h3 id="parallel并行数"><a class="header" href="#parallel并行数">parallel（并行数）</a></h3>
<p>生成 worker 的并行数。对 <code>blackhole_sink</code> 消费端也会并行，其它 sink 默认单消费者。</p>
<h2 id="使用示例-1"><a class="header" href="#使用示例-1">使用示例</a></h2>
<pre><code class="language-bash"># 配置初始化
wpgen conf init -w .
wpgen conf check -w .

# 基于规则生成 10000 条数据
wpgen sample -n 10000 -p

# 自定义规则目录和生成速度
wpgen rule 
    --wpl nginx \
    -c custom.toml \
    -s 1000 \
    --stat 2 \
    -p

# 基于样本文件生成
wpgen sample  -n 50000 -s 5000 --stat 5 -p

# 清理生成的数据
wpgen data clean -c wpgen.toml --local
</code></pre>
<h2 id="常见问题-2"><a class="header" href="#常见问题-2">常见问题</a></h2>
<p><strong>Q：产出不足预期？</strong></p>
<p>A：<code>count</code> 被精确分配给每个 worker。检查日志中 <code>limit : …</code> 是否符合预期。</p>
<h2 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h2>
<p>默认配置文件路径：<code>conf/wpgen.toml</code></p>
<p>主要配置项：</p>
<pre><code class="language-toml">[generator]
count = 10000      # 总生成条数
speed = 1000       # 生成速度（行/秒），0 表示无限制
parallel = 4       # 并行 worker 数

[output]
# 输出配置...
</code></pre>
<p>生成文件通常位于 <code>./data/in_dat/</code>，可在配置中调整目标路径。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wprescue"><a class="header" href="#wprescue">wprescue</a></h1>
<p>wprescue 是数据恢复工具，用于从救援目录中恢复数据并按照项目配置的 Sink 路由输出到目标。</p>
<h2 id="命令概览-2"><a class="header" href="#命令概览-2">命令概览</a></h2>
<pre><code>wprescue 
</code></pre>
<p><strong>重要：</strong> wprescue 仅支持 batch 模式。</p>
<h2 id="命令行参数-1"><a class="header" href="#命令行参数-1">命令行参数</a></h2>
<pre><code class="language-bash">wprescue [OPTIONS]
</code></pre>
<h2 id="工作原理"><a class="header" href="#工作原理">工作原理</a></h2>
<ol>
<li>读取救援目录（<code>./data/rescue</code>）中的数据</li>
<li>按照项目配置的 Sink 路由进行处理</li>
<li>输出到目标位置</li>
<li>处理完成后自动退出</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="配置指南"><a class="header" href="#配置指南">配置指南</a></h1>
<!-- 角色：使用配置者 | 最近验证：2025-12-21 -->
<p>本文聚焦 wparse 运行所依赖的配置。建议从“运行主配置（wparse.toml）”开始，随后按需阅读源/汇与连接器章节。</p>
<p>推荐阅读顺序</p>
<ul>
<li>Wparse 运行配置（主配置）：wparse.toml（本目录）
<ul>
<li><a href="10-user/02-config/01-wparse_config.html">Wparse 运行配置规范（wparse.toml）</a></li>
</ul>
</li>
<li>源（Sources）与连接器
<ul>
<li><a href="#sources配置">源配置总览（sources）</a></li>
<li>连接器（source.d）见“源配置总览”内的查找规则与示例</li>
</ul>
</li>
<li>汇（Sinks）与连接器
<ul>
<li><a href="10-user/02-config/04-sinks_config.html">Sinks 设计与配置（目录式 V2）</a></li>
<li><a href="10-user/02-config/03-sinks_minimal.html">Sinks 最小可运行骨架</a></li>
<li>连接器（sink.d）与 route 细节见“设计与配置”</li>
</ul>
</li>
</ul>
<p>相关参考</p>
<ul>
<li>参考参数与规格：docs/80-reference 下各 Source/Sink/Spec 文档</li>
<li>CLI：docs/cli/wparse.md（快速查看常用选项）</li>
</ul>
<p>提示</p>
<ul>
<li>使用 <code>wproj conf init --work-root .</code> 可初始化标准目录与模板（conf/、connectors/ 与部分 models 目录）。若需要知识库（KnowDB）模板，请另行执行 <code>wproj knowdb init</code>。</li>
<li>修改场景流程后，建议运行 <code>usecase/core/getting_started/case_verify.sh</code> 验证端到端产出。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wparse配置"><a class="header" href="#wparse配置">Wparse配置</a></h1>
<p>完整示例（推荐默认）</p>
<pre><code class="language-toml">version = "1.0"
robust  = "normal"           # debug|normal|strict

[models]
wpl     = "./models/wpl"
oml     = "./models/oml"

[topology]
sources = "./topology/sources"
sinks   = "./topology/sinks"

[performance]
rate_limit_rps = 10000        # 限速（records/second）
parse_workers  = 2            # 解析并发 worker 数

[rescue]
path = "./data/rescue"        

[log_conf]
output = "File"               # Console|File|Both
level  = "warn,ctrl=info"

[log_conf.file]
path = "./data/logs"          # 文件输出目录；文件名自动取可执行名（wparse.log）

[stat]

[[stat.pick]]                 # 采集阶段统计
key    = "pick_stat"
target = "*"

[[stat.parse]]                # 解析阶段统计
key    = "parse_stat"
target = "*"

[[stat.sink]]                 # 下游阶段统计
key    = "sink_stat"
target = "*"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sources配置"><a class="header" href="#sources配置">Sources配置</a></h1>
<h2 id="概览"><a class="header" href="#概览">概览</a></h2>
<p>Source（源）是 warp-parse 系统中负责数据输入的组件，支持多种数据源和协议。采用统一的连接器架构，提供灵活的数据接入能力。</p>
<h3 id="定位与目录"><a class="header" href="#定位与目录">定位与目录</a></h3>
<ul>
<li><strong>配置文件</strong>：<code>$WORK_ROOT/topology/sources/wpsrc.toml</code></li>
<li><strong>连接器定义</strong>：从 <code>$WORK_ROOT/models/sources</code> 起向上查找最近的 <code>connectors/source.d/*.toml</code></li>
</ul>
<h3 id="核心概念"><a class="header" href="#核心概念">核心概念</a></h3>
<ul>
<li><strong>连接器</strong>：可复用的输入连接定义，包含 <code>id/type/params/allow_override</code></li>
<li><strong>参数覆写</strong>：通过白名单机制安全覆写连接器参数</li>
<li><strong>标签系统</strong>：支持为数据源添加标签，便于路由和过滤</li>
</ul>
<h2 id="支持的-source-类型"><a class="header" href="#支持的-source-类型">支持的 Source 类型</a></h2>
<h3 id="内置-source"><a class="header" href="#内置-source">内置 Source</a></h3>
<ul>
<li><strong>file</strong>：文件输入，支持监控和轮询</li>
<li><strong>syslog</strong>：Syslog 协议输入（UDP/TCP）</li>
<li><strong>tcp</strong>：协议输入</li>
</ul>
<h3 id="扩展-source"><a class="header" href="#扩展-source">扩展 Source</a></h3>
<ul>
<li><strong>kafka</strong>：Apache Kafka 消息队列输入</li>
</ul>
<h2 id="配置规则"><a class="header" href="#配置规则">配置规则</a></h2>
<h3 id="基本规则"><a class="header" href="#基本规则">基本规则</a></h3>
<ul>
<li>仅支持 <code>[[sources]] + connect/params</code> 格式</li>
<li>覆写键必须 ∈ connector <code>allow_override</code> 白名单；超出即报错</li>
<li><code>enable</code> 字段控制是否启用（默认 true）</li>
<li><code>tags</code> 字段支持添加数据源标签</li>
</ul>
<h3 id="配置结构"><a class="header" href="#配置结构">配置结构</a></h3>
<pre><code class="language-toml">[[sources]]
key = "source_identifier"           # 源的唯一标识
connect = "connector_id"            # 引用的连接器 ID
enable = true                       # 是否启用（可选，默认 true）
tags = ["source:tag1", "type:log"]  # 标签（可选）
params = {                 # 参数覆写（可选）
    # 覆写连接器参数
}
</code></pre>
<h2 id="配置示例"><a class="header" href="#配置示例">配置示例</a></h2>
<h3 id="最小示例"><a class="header" href="#最小示例">最小示例</a></h3>
<pre><code class="language-toml">[[sources]]
key = "file_1"
connect = "file_src"
params = { base = "data/in_dat", file = "gen.dat" }
</code></pre>
<h3 id="文件输入示例"><a class="header" href="#文件输入示例">文件输入示例</a></h3>
<pre><code class="language-toml"># models/sources/wpsrc.toml
[[sources]]
key = "access_log"
connect = "file_src"
params = {
    base = "./logs",
    file = "access.log",
    encode = "text"
}
tags = ["type:access", "env:prod"]
</code></pre>
<h3 id="syslog-输入示例"><a class="header" href="#syslog-输入示例">Syslog 输入示例</a></h3>
<pre><code class="language-toml">
# models/sources/wpsrc.toml
[[sources]]
key = "syslog_udp"
connect = "syslog_udp_src"
params = {
    port = 1514,
    header_mode = "parse",
    prefer_newline = true
}
tags = ["protocol:syslog", "transport:udp"]
</code></pre>
<h3 id="tcp-输入示例通用-tcp-行长度分帧"><a class="header" href="#tcp-输入示例通用-tcp-行长度分帧">TCP 输入示例（通用 TCP 行/长度分帧）</a></h3>
<pre><code class="language-toml">
# models/sources/wpsrc.toml
[[sources]]
key = "tcp_in"
connect = "tcp_src"
enable = true
params= {
  port = 19000,
  framing = "auto",
  prefer_newline = true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sink-配置"><a class="header" href="#sink-配置">Sink 配置</a></h1>
<h2 id="目录与文件组织"><a class="header" href="#目录与文件组织">目录与文件组织</a></h2>
<ul>
<li>
<p>sink_root：用例内通常为 <code>&lt;case&gt;/sink</code></p>
<ul>
<li>business.d/**/*.toml：业务组路由（场景输出，支持子目录）</li>
<li>infra.d/**/*.toml：基础组路由（default/miss/residue/intercept/error/monitor，支持子目录）</li>
<li>defaults.toml：默认组级期望 [defaults.expect]</li>
</ul>
</li>
<li>
<p>connectors/sink.d/*.toml：连接器定义（loader 自 sink_root 向上查找最近的该目录）</p>
</li>
</ul>
<h2 id="路由文件格式"><a class="header" href="#路由文件格式">路由文件格式</a></h2>
<ul>
<li>顶层
<ul>
<li>version（可选）</li>
<li>sink_group
<ul>
<li>name：组名（字符串）</li>
<li>oml / rule：推荐扁平写法；均可为字符串或字符串数组；用于匹配模型或规则。</li>
<li>expect：可选，组级期望（覆盖 defaults）</li>
<li>sinks：数组，每项为单个 sink 定义</li>
</ul>
</li>
</ul>
</li>
<li>单个 sink 字段
<ul>
<li>name：该 sink 的名称（组内唯一）；未提供则按 [index] 回退</li>
<li>connect：引用连接器 id（兼容读取 <code>use</code>/<code>connector</code>）</li>
<li>params：对连接器默认参数的白名单覆盖（keys 必须在连接器 allow_override 列表中）</li>
<li>expect：可选，单 sink 期望（仅 ratio/tol/min/max，互斥关系：ratio/tol 与 min/max 不可混用）</li>
<li>filter：可选，拦截条件文件路径；命中 true 时丢弃该 sink 并发送至 intercept</li>
</ul>
</li>
</ul>
<h2 id="配置示例-1"><a class="header" href="#配置示例-1">配置示例：</a></h2>
<h3 id="基础组"><a class="header" href="#基础组">基础组</a></h3>
<pre><code class="language-toml">version = "2.0"
[sink_group]
name = "intercept"

[[sink_group.sinks]]
name = "intercept"
connect = "file_kv_sink"
params = { base = "./out", file = "intercept.dat" }
</code></pre>
<h3 id="业务组filter"><a class="header" href="#业务组filter">业务组（filter）</a></h3>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "/sink/filter"
oml  = ["/oml/sh*"]

[[sink_group.sinks]]
name = "all"
connect = "file_kv_sink"
params = { base = "./out/sink", file = "all.dat" }

[[sink_group.sinks]]
name = "safe"
connect = "file_kv_sink"
filter = "./sink/business.d/filter.conf"   # 命中 -&gt; 拦截，不写 safe
params = { base = "./out/sink", file = "safe.dat" }
</code></pre>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<ul>
<li>标识规则
<ul>
<li>组名：sink_group.name（例如 /sink/example/simple）</li>
<li>sink 名：name（组内唯一；未显式提供时按索引回退为 [0]/[1]/…）</li>
</ul>
</li>
<li>过滤语义（filter）
<ul>
<li>filter 是“拦截条件”：表达式求值为 true 时，该条数据不写入该 sink，而是转发到基础组 intercept（framework/intercept）</li>
<li>每个 sink 可独立设置 filter；与 expect 相互独立</li>
</ul>
</li>
</ul>
<h2 id="校验提示"><a class="header" href="#校验提示">校验提示</a></h2>
<ul>
<li>分母决定：
<ul>
<li>basis = total_input：总输入</li>
<li>basis = group_input：该组各 sink 行数之和（或 stats 中该组输入）</li>
<li>basis = model：按模型粒度统计（目前以组内 sinks 行数之和替代）</li>
</ul>
</li>
<li>min_samples：当分母为 0 或小于该值时，组校验被忽略（打印提示，不 fail）</li>
<li>当 route 为非文件类写入 fmt 时，validate 会提示“fmt 由后端决定，已忽略”。</li>
</ul>
<h2 id="常见排错"><a class="header" href="#常见排错">常见排错</a></h2>
<ul>
<li>连接器未找到：检查 connectors/sink.d 是否存在对应 id；<code>wproj sinks list</code> 可查看引用关系</li>
<li>覆盖参数不生效：检查 allow_override 白名单</li>
<li>filter 未生效：
<ul>
<li>路径解析相对当前工作目录（建议写相对 sink_root 的相对路径）</li>
<li>日志中会打印“found path/not found filter …”</li>
<li>表达式语法需通过 TCondParser；可先用简单表达式试验</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpgen配置"><a class="header" href="#wpgen配置">Wpgen配置</a></h1>
<p>wpgen 是数据生成工具，用于按照规则或样本生成测试数据。</p>
<h2 id="基础配置"><a class="header" href="#基础配置">基础配置</a></h2>
<p>配置文件路径：<code>conf/wpgen.toml</code></p>
<pre><code class="language-toml">version = "1.0"

[generator]
mode = "sample"          # 生成模式：rule | sample
count = 1000             # 生成总条数（可选）
duration_secs = 60       # 生成持续时间（秒，可选，与 count 二选一）
speed = 1000             # 恒定速率（行/秒），0 为无限速
parallel = 1             # 并行度
rule_root = "./rules"    # 规则目录（mode=rule 时使用）
sample_pattern = "*.txt" # 样本文件匹配模式（mode=sample 时使用）

[output]
# 引用 connectors/sink.d 中的连接器 id
connect = "file_kv_sink"
name = "gen_out"
# 覆写连接器参数（仅 allow_override 白名单内的键）
params = { base = "./src_dat", file = "gen.dat" }

[logging]
level = "warn"
output = "file"
file_path = "./data/logs/"
</code></pre>
<h2 id="动态速度模型"><a class="header" href="#动态速度模型">动态速度模型</a></h2>
<p>除了使用 <code>speed</code> 字段指定恒定速率外，还可以使用 <code>speed_profile</code> 配置动态速度变化模型。
当 <code>speed_profile</code> 存在时，<code>speed</code> 字段将被忽略。</p>
<h3 id="恒定速率-constant"><a class="header" href="#恒定速率-constant">恒定速率 (constant)</a></h3>
<p>固定速率生成数据。</p>
<pre><code class="language-toml">[generator.speed_profile]
type = "constant"
rate = 5000              # 每秒生成行数
</code></pre>
<h3 id="正弦波动-sinusoidal"><a class="header" href="#正弦波动-sinusoidal">正弦波动 (sinusoidal)</a></h3>
<p>速率按正弦曲线周期性波动，模拟周期性负载变化。</p>
<pre><code class="language-toml">[generator.speed_profile]
type = "sinusoidal"
base = 5000              # 基准速率（行/秒）
amplitude = 2000         # 波动幅度（行/秒）
period_secs = 60.0       # 周期长度（秒）
</code></pre>
<p>速率范围：<code>[base - amplitude, base + amplitude]</code>，即上例中为 3000-7000 行/秒。</p>
<h3 id="阶梯变化-stepped"><a class="header" href="#阶梯变化-stepped">阶梯变化 (stepped)</a></h3>
<p>速率按预定义的阶梯序列变化，适合模拟分阶段负载测试。</p>
<pre><code class="language-toml">[generator.speed_profile]
type = "stepped"
# 格式：[[持续时间(秒), 速率], ...]
steps = [
    [30.0, 1000],        # 前 30 秒：1000 行/秒
    [30.0, 5000],        # 接下来 30 秒：5000 行/秒
    [30.0, 2000]         # 最后 30 秒：2000 行/秒
]
loop_forever = true      # 是否循环执行（默认 false）
</code></pre>
<h3 id="突发模式-burst"><a class="header" href="#突发模式-burst">突发模式 (burst)</a></h3>
<p>在基准速率上随机触发高速突发，模拟突发流量场景。</p>
<pre><code class="language-toml">[generator.speed_profile]
type = "burst"
base = 1000              # 基准速率（行/秒）
burst_rate = 10000       # 突发时速率（行/秒）
burst_duration_ms = 500  # 突发持续时间（毫秒）
burst_probability = 0.05 # 每秒触发突发的概率（0.0-1.0）
</code></pre>
<h3 id="渐进模式-ramp"><a class="header" href="#渐进模式-ramp">渐进模式 (ramp)</a></h3>
<p>速率从起始值线性变化到目标值，适合压力递增测试。</p>
<pre><code class="language-toml">[generator.speed_profile]
type = "ramp"
start = 100              # 起始速率（行/秒）
end = 10000              # 目标速率（行/秒）
duration_secs = 300.0    # 变化持续时间（秒）
</code></pre>
<p>达到目标速率后将保持该速率。支持正向（递增）和反向（递减）。</p>
<h3 id="随机波动-random_walk"><a class="header" href="#随机波动-random_walk">随机波动 (random_walk)</a></h3>
<p>速率在基准值附近随机波动，模拟不规则负载。</p>
<pre><code class="language-toml">[generator.speed_profile]
type = "random_walk"
base = 5000              # 基准速率（行/秒）
variance = 0.3           # 波动范围（0.0-1.0），0.3 表示 ±30%
</code></pre>
<p>速率范围：<code>[base * (1 - variance), base * (1 + variance)]</code></p>
<h3 id="复合模式-composite"><a class="header" href="#复合模式-composite">复合模式 (composite)</a></h3>
<p>组合多个速度模型，支持多种组合方式。</p>
<pre><code class="language-toml">[generator.speed_profile]
type = "composite"
combine_mode = "average" # 组合方式：average | max | min | sum

# 子模型列表
[[generator.speed_profile.profiles]]
type = "sinusoidal"
base = 5000
amplitude = 2000
period_secs = 60.0

[[generator.speed_profile.profiles]]
type = "random_walk"
base = 5000
variance = 0.1
</code></pre>
<p>组合方式说明：</p>
<ul>
<li><code>average</code>：取所有子模型速率的平均值（默认）</li>
<li><code>max</code>：取所有子模型速率的最大值</li>
<li><code>min</code>：取所有子模型速率的最小值</li>
<li><code>sum</code>：累加所有子模型速率</li>
</ul>
<h2 id="配置示例-2"><a class="header" href="#配置示例-2">配置示例</a></h2>
<h3 id="示例-1简单恒定速率"><a class="header" href="#示例-1简单恒定速率">示例 1：简单恒定速率</a></h3>
<pre><code class="language-toml">version = "1.0"

[generator]
mode = "sample"
count = 10000
speed = 5000
parallel = 2

[output]
connect = "file_json_sink"
params = { base = "./data", file = "output.dat" }

[logging]
level = "info"
output = "file"
file_path = "./logs"
</code></pre>
<h3 id="示例-2渐进压力测试"><a class="header" href="#示例-2渐进压力测试">示例 2：渐进压力测试</a></h3>
<pre><code class="language-toml">version = "1.0"

[generator]
mode = "rule"
duration_secs = 600      # 运行 10 分钟
parallel = 4
rule_root = "./rules"

[generator.speed_profile]
type = "ramp"
start = 100
end = 20000
duration_secs = 300.0    # 5 分钟内从 100 提升到 20000

[output]
connect = "kafka_sink"
params = { topic = "test-topic" }

[logging]
level = "warn"
output = "file"
file_path = "./logs"
</code></pre>
<h3 id="示例-3模拟真实业务负载"><a class="header" href="#示例-3模拟真实业务负载">示例 3：模拟真实业务负载</a></h3>
<pre><code class="language-toml">version = "1.0"

[generator]
mode = "sample"
duration_secs = 3600     # 运行 1 小时
parallel = 8

[generator.speed_profile]
type = "composite"
combine_mode = "average"

# 基础周期性波动（模拟日间/夜间流量差异）
[[generator.speed_profile.profiles]]
type = "sinusoidal"
base = 10000
amplitude = 5000
period_secs = 300.0

# 叠加随机噪声
[[generator.speed_profile.profiles]]
type = "random_walk"
base = 10000
variance = 0.15

[output]
connect = "tcp_sink"
params = { host = "127.0.0.1", port = 9000 }

[logging]
level = "info"
output = "both"
file_path = "./logs"
</code></pre>
<h2 id="运行规则"><a class="header" href="#运行规则">运行规则</a></h2>
<ul>
<li>
<p><code>wpgen</code> 会在加载 <code>conf/wpgen.toml</code> 时，若检测到 <code>[output].connect</code>：</p>
<ul>
<li>从 <code>ENGINE_CONF.sink_root</code> 向上查找最近的 <code>connectors/sink.d/</code> 目录</li>
<li>读取目标连接器并与 <code>params</code> 合并（仅允许 <code>allow_override</code> 中的键）</li>
</ul>
</li>
<li>
<p>当配置了 <code>parallel &gt; 1</code> 时，速度模型会自动按并行度分配，确保总速率符合预期</p>
</li>
<li>
<p><code>count</code> 和 <code>duration_secs</code> 二选一：</p>
<ul>
<li>设置 <code>count</code> 时，生成指定条数后停止</li>
<li>设置 <code>duration_secs</code> 时，运行指定秒数后停止</li>
<li>两者都未设置时，将持续运行直到手动停止</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="knowdb-配置"><a class="header" href="#knowdb-配置">KnowDB 配置</a></h1>
<p>本指南描述知识库（KnowDB）的目录式配置与装载规范。</p>
<p>适用范围</p>
<ul>
<li>初始化权威库（CSV → SQLite），用于 wparse/wproj 等工具在启动时装载</li>
</ul>
<p>核心原则</p>
<ul>
<li>SQL 外置：每张表的 DDL/DML 均放在对应目录下的 .sql 文件中</li>
<li>安全：运行期只允许访问配置里声明过的表名；SQL 仅支持 {table} 占位符</li>
<li>默认可用：多数字段可省略，内置默认值与自动探测能满足常见场景</li>
</ul>
<p>目录布局（推荐）</p>
<pre><code>models/knowledge/
  knowdb.toml                     # 本配置
  example/
    create.sql
    insert.sql
    data.csv                     # 单一数据文件（表目录根）
  address/
    create.sql
    insert.sql
    data.csv
</code></pre>
<p>顶层配置（models/knowledge/knowdb.toml）</p>
<pre><code class="language-toml">version = 2

[[tables]]
name = "example"
# dir 省略时等于 name；此示例即使用目录 models/knowledge/example
# data_file 省略时使用表目录下的 data.csv
columns.by_header = ["name", "pinying"]

# 如需更多表，追加 [[tables]] 段落
</code></pre>
<p>SQL 文件规范</p>
<ul>
<li>create.sql：建表语句，必须存在；可使用占位符 <code>{table}</code>；允许包含多条语句（如 <code>CREATE INDEX</code>）</li>
<li>insert.sql：插入语句，必须存在；参数位置用 <code>?1..?N</code>；允许 <code>{table}</code></li>
<li>clean.sql：可选；若不存在，装载前默认执行 <code>DELETE FROM {table}</code></li>
</ul>
<p>列映射（columns）</p>
<ul>
<li>推荐 <code>by_header=[..]</code>，按 CSV 表头名映射到 <code>insert.sql</code> 中的列</li>
<li>若 <code>has_header=false</code>，必须提供 <code>by_index=[..]</code></li>
<li>可选增强（实现层）：若未配置 columns，且 <code>insert.sql</code> 显式了列清单，可解析 insert 的列名作为 <code>by_header</code></li>
</ul>
<p>装载策略（默认可省略）</p>
<ul>
<li>默认：<code>transaction=true</code>、<code>batch_size=2000</code>、<code>on_error="fail"</code></li>
<li>on_error:
<ul>
<li>fail：遇到坏行（缺列/解析失败）即失败回滚</li>
<li>skip：跳过坏行并计数告警</li>
</ul>
</li>
</ul>
<p>自动探测（当 data_file 未配置）</p>
<ul>
<li>使用 <code>{base_dir}/{tables.dir}/data.csv</code></li>
<li>不存在则报错</li>
</ul>
<p>安全约束</p>
<ul>
<li>运行时（facade/query_cipher/SQL 评估）仅允许使用 <code>[[tables]].name</code> 中声明的表名</li>
<li>SQL 模板仅允许 <code>{table}</code> 占位符；禁止其它动态拼接</li>
</ul>
<p>最小可运行示例</p>
<ol>
<li>目录</li>
</ol>
<pre><code>models/knowledge/knowdb.toml
models/knowledge/example/{create.sql, insert.sql, data.csv}
</code></pre>
<ol start="2">
<li>create.sql</li>
</ol>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS {table} (
  id      INTEGER PRIMARY KEY,
  name    TEXT NOT NULL,
  pinying TEXT NOT NULL
);
</code></pre>
<ol start="3">
<li>insert.sql</li>
</ol>
<pre><code class="language-sql">INSERT INTO {table} (name, pinying) VALUES (?1, ?2);
</code></pre>
<ol start="4">
<li>data.csv</li>
</ol>
<pre><code>name,pinying
令狐冲,linghuchong
任盈盈,renyingying
</code></pre>
<ol start="5">
<li>knowdb.toml（最小化）</li>
</ol>
<pre><code class="language-toml">version = 2
base_dir = "./models/knowledge"
[[tables]]
name = "example"
dir  = "example"
columns.by_header = ["name", "pinying"]
[tables.expected_rows]
min = 1
max = 100
</code></pre>
<p>常见错误与排障</p>
<ul>
<li>缺少 create.sql / insert.sql：启动时失败并指向缺失文件</li>
<li><code>has_header=false</code> 但未提供 <code>by_index</code>：装载报错</li>
<li><code>expected_rows.min</code> 未满足：数据不足，装载失败</li>
<li>数据源未找到：既未配置 <code>data_file</code>，也不存在默认路径 <code>data.csv</code></li>
<li>运行期 SQL 访问未声明的表：安全校验失败</li>
</ul>
<p>与应用的关系</p>
<ul>
<li>wparse/wproj 等会在启动处加载 knowdb：创建权威库并设置 Query Provider</li>
<li>曾用于隐私模块的 <code>query_cipher(table)</code>（加载单列表词表）在当前版本默认不启用；如需脱敏请在业务侧实现</li>
</ul>
<p>内置 SQL 函数（UDF）</p>
<ul>
<li>运行时注册：
<ul>
<li>导入阶段（权威库写连接）与查询阶段（线程克隆的只读连接）均自动注册。</li>
<li>可在 <code>INSERT/SELECT/WHERE</code> 中直接使用（DDL 不涉及）。</li>
</ul>
</li>
<li>签名与语义：
<ul>
<li><code>ip4_int(text) -&gt; integer</code>：点分 IPv4 转 32 位整数；容忍空白/引号；非法返回 <code>0</code>。</li>
<li><code>ip4_between(ip_text, start_text, end_text) -&gt; integer</code>：是否在闭区间 <code>[start,end]</code> 内（1/0）。</li>
<li><code>cidr4_min(text) -&gt; integer</code>：CIDR 起始地址（含），如 <code>10.0.0.0/8</code>。</li>
<li><code>cidr4_max(text) -&gt; integer</code>：CIDR 结束地址（含）。</li>
<li><code>cidr4_contains(ip_text, cidr_text) -&gt; integer</code>：IP 是否落在 CIDR 段内（1/0）。</li>
<li><code>ip4_text(integer|string) -&gt; text</code>：32 位整数转点分 IPv4（便于调试/展示）。</li>
<li><code>trim_quotes(text) -&gt; text</code>：去除两端成对引号（’ 或 “），容忍前后空白；未成对则原样返回（去掉空白）。</li>
</ul>
</li>
<li>导入示例（insert.sql）：
<pre><code class="language-sql">INSERT INTO {table} (ip_start_int, ip_end_int, zone)
VALUES (ip4_int(?1), ip4_int(?2), trim_quotes(?3));
</code></pre>
</li>
<li>查询示例（普通 SQL）：
<pre><code class="language-sql">-- 区间命中（推荐整数比较写法，避免在 WHERE 中直接比较函数返回）
SELECT zone FROM zone
WHERE ip_start_int &lt;= ip4_int(:ip)
  AND ip_end_int   &gt;= ip4_int(:ip)
LIMIT 1;

-- CIDR 命中
SELECT zone FROM zone
WHERE cidr4_contains(:ip, :cidr) = 1;

-- 调试回显
SELECT ip4_text(ip_start_int) AS ip_start, ip4_text(ip_end_int) AS ip_end, zone
FROM zone
LIMIT 5;
</code></pre>
</li>
<li>OML 中的 SQL 精确求值：
<ul>
<li>OML 的 <code>select … from … where …;</code> 语法对列段做了标识符白名单限制，不建议在列段直接写函数。</li>
<li>推荐在上游产出数值型 IP（如 <code>src_ip_int</code>），在 OML 的 where 中用整数比较：
<pre><code class="language-sql">from_zone: chars = sql(
  select zone from zone
  where ip_start_int &lt;= read(src_ip_int)
    and ip_end_int   &gt;= read(src_ip_int);
)
</code></pre>
</li>
</ul>
</li>
<li>注意事项：
<ul>
<li>目前非法 IPv4/CIDR 输入返回 <code>0</code>（或匹配失败），为提高导入韧性；如需严格行为可定制。</li>
<li>SQLite 原生已提供 <code>lower/upper/trim</code> 等字符串函数，可与上述 UDF 组合使用。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="日志配置"><a class="header" href="#日志配置">日志配置</a></h1>
<p>本文面向使用者与一线开发，给出在 Warp Parse 中开启/调整日志与进行常见问题定位的实操指南。</p>
<ul>
<li>目标域（targets）见《开发者文档：Logging Targets And Levels》。</li>
<li>文件日志默认滚动：10MB/10 份，gzip 压缩。</li>
</ul>
<h2 id="快速上手"><a class="header" href="#快速上手">快速上手</a></h2>
<h3 id="wparse--wprescue--confwparsetoml"><a class="header" href="#wparse--wprescue--confwparsetoml">wparse / wprescue  （conf/wparse.toml）</a></h3>
<p>生产推荐（文件输出 + 低噪声）：</p>
<pre><code class="language-toml">[log_conf]
output = "File"   # Console|File|Both
level  = "warn,ctrl=info，dfx=info"
[log_conf.file]
path = "./data/logs"   # 目录会自动创建；文件名按可执行名自动命名，如 wparse.log
</code></pre>
<p>本地联调（同时输出到控制台）：</p>
<pre><code class="language-toml">[log_conf]
output = "Both"
level  = "debug"
[log_conf.file]
path = "./data/logs"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-规则语言"><a class="header" href="#wpl-规则语言">WPL 规则语言</a></h1>
<p>WPL (Warp Processing Language) 是 Warp Parse 解析子系统（warp-parse）使用的规则语言，用于描述字段抽取、协议解析与简单判定逻辑。</p>
<hr>
<h2 id="-文档导航"><a class="header" href="#-文档导航">📚 文档导航</a></h2>
<h3 id="按学习路径"><a class="header" href="#按学习路径">按学习路径</a></h3>
<pre><code>🆕 新手入门
   ↓
01-quickstart.md ────→ 5分钟上手，复制即用
   ↓
07-complete-types-examplemd ──→ 🌟 完整功能演示（强烈推荐）
   ↓
02-core-concepts.md ──→ 理解设计理念和核心概念
   ↓
03-practical-guide.md → 按任务查找解决方案
   ↓
04-language-reference.md → 查阅类型和语法
   ↓
05-functions-reference.md → 查阅函数
</code></pre>
<h3 id="按用户角色"><a class="header" href="#按用户角色">按用户角色</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>我是…</th><th>推荐阅读</th></tr>
</thead>
<tbody>
<tr><td><strong>WPL 新手</strong></td><td><a href="#wpl-快速入门">01-quickstart.md</a> → <a href="#wpl-核心概念">02-core-concepts.md</a></td></tr>
<tr><td><strong>日常使用者</strong></td><td><a href="#wpl-实战指南">03-practical-guide.md</a> - 按任务查找</td></tr>
<tr><td><strong>开发者/集成</strong></td><td><a href="#wpl-语言参考">04-language-reference.md</a> + <a href="#wpl-函数参考">05-functions-reference.md</a></td></tr>
<tr><td><strong>编译器开发</strong></td><td><a href="#wpl-语法参考ebnf">06-grammar-reference.md</a> - EBNF 语法</td></tr>
</tbody>
</table>
</div>
<h3 id="按任务查找"><a class="header" href="#按任务查找">按任务查找</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>我想…</th><th>查看文档</th></tr>
</thead>
<tbody>
<tr><td>🚀 快速上手</td><td><a href="#wpl-快速入门">01-quickstart.md</a></td></tr>
<tr><td>🎯 <strong>查看完整类型示例</strong></td><td><strong><a href="#wpl-完整类型系统示例">07-complete-types-example.md</a></strong></td></tr>
<tr><td>💡 理解概念</td><td><a href="#wpl-核心概念">02-core-concepts.md</a></td></tr>
<tr><td>📝 解析 Nginx 日志</td><td><a href="#1-解析-web-服务器日志">03-practical-guide.md § 1</a></td></tr>
<tr><td>📊 解析 JSON 数据</td><td><a href="#2-解析-json-数据">03-practical-guide.md § 2</a></td></tr>
<tr><td>🔑 解析 KV 键值对</td><td><a href="#3-解析-kv-键值对">03-practical-guide.md § 3</a></td></tr>
<tr><td>🔐 处理 Base64 编码</td><td><a href="#4-处理编码数据">03-practical-guide.md § 4</a></td></tr>
<tr><td>✅ 验证字段</td><td><a href="#5-字段验证与过滤">03-practical-guide.md § 5</a></td></tr>
<tr><td>🔍 查某个类型</td><td><a href="#📋-类型系统">04-language-reference.md § 类型系统</a></td></tr>
<tr><td>⚙️ 查某个函数</td><td><a href="#wpl-函数参考">05-functions-reference.md</a></td></tr>
<tr><td>📖 查语法规则</td><td><a href="#wpl-语法参考ebnf">06-grammar-reference.md</a></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-文档列表"><a class="header" href="#-文档列表">📖 文档列表</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>文档</th><th>内容</th><th>适合人群</th></tr>
</thead>
<tbody>
<tr><td><a href="#wpl-快速入门">01-quickstart.md</a></td><td>5 分钟快速入门 + 3 个最常用场景 + 练习</td><td>所有人</td></tr>
<tr><td><strong><a href="#wpl-完整类型系统示例">07-complete-types-example.md</a></strong></td><td><strong>完整类型系统示例 - 23 种类型速查</strong></td><td><strong>所有人</strong></td></tr>
<tr><td><a href="#wpl-核心概念">02-core-concepts.md</a></td><td>设计理念 + 类型系统 + 匹配语义 + 管道系统</td><td>想深入理解的用户</td></tr>
<tr><td><a href="#wpl-实战指南">03-practical-guide.md</a></td><td>按任务组织的实战示例 + 常见问题</td><td>日常使用者</td></tr>
<tr><td><a href="#wpl-语言参考">04-language-reference.md</a></td><td>完整类型列表 + 语法元素 + 速查表</td><td>开发者</td></tr>
<tr><td><a href="#wpl-函数参考">05-functions-reference.md</a></td><td>所有函数的标准化参考</td><td>开发者</td></tr>
<tr><td><a href="#wpl-语法参考ebnf">06-grammar-reference.md</a></td><td>EBNF 形式化语法定义</td><td>编译器开发者</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-快速示例"><a class="header" href="#-快速示例">⚡ 快速示例</a></h2>
<h3 id="nginx-访问日志"><a class="header" href="#nginx-访问日志">Nginx 访问日志</a></h3>
<pre><code class="language-wpl">package nginx {
  rule access_log {
    (
      ip:client_ip,
      2*_,
      time/clf&lt;[,]&gt;:time,
      http/request":request,
      digit:status,
      digit:bytes
    )
  }
}
</code></pre>
<h3 id="json-api-响应"><a class="header" href="#json-api-响应">JSON API 响应</a></h3>
<pre><code class="language-wpl">package api {
  rule response {
    (json(
      chars@user,
      digit@code,
      chars@message
    ))
  }
}
</code></pre>
<h3 id="华为防火墙日志base64"><a class="header" href="#华为防火墙日志base64">华为防火墙日志（Base64）</a></h3>
<pre><code class="language-wpl">package firewall {
  rule huawei_log {
    |decode/base64|
    (
      digit:id,
      time:timestamp,
      sn:serial,
      chars:type\:,
      opt(kvarr),
      kvarr
    )
  }
}
</code></pre>
<p>更多示例请查看：<a href="#wpl-快速入门">01-quickstart.md</a> 和 <a href="#wpl-实战指南">03-practical-guide.md</a></p>
<hr>
<h2 id="-完整类型系统示例"><a class="header" href="#-完整类型系统示例">🎯 完整类型系统示例</a></h2>
<p><strong>想快速了解 WPL 支持的所有数据类型？</strong></p>
<p>👉 <strong><a href="#wpl-完整类型系统示例">查看完整类型示例</a></strong> - 一个示例展示 23 种主要数据类型</p>
<p>该文档包含：</p>
<ul>
<li>✅ <strong>完整可运行</strong>的输入数据 + WPL 规则 + 输出结果</li>
<li>✅ <strong>23 种类型</strong>：基础、时间、网络、结构化、协议、编码</li>
<li>✅ <strong>每种类型详解</strong>：语法、示例、使用场景</li>
<li>✅ <strong>常见组合模式</strong>：复制即用的类型组合</li>
</ul>
<p><strong>适合：</strong></p>
<ul>
<li>🆕 新手快速了解 WPL 能力</li>
<li>📚 开发者作为类型速查手册</li>
<li>🔍 遇到陌生数据格式时快速查找对应类型</li>
</ul>
<hr>
<h2 id="-核心特性"><a class="header" href="#-核心特性">🎯 核心特性</a></h2>
<ul>
<li><strong>声明式</strong>：描述“是什么“，而非“怎么做“</li>
<li><strong>类型安全</strong>：自动验证和转换（IP、时间、JSON 等）</li>
<li><strong>组合性</strong>：小规则组合成复杂规则</li>
<li><strong>强大的管道</strong>：预处理（Base64/Hex 解码）+ 字段级验证</li>
<li><strong>灵活的匹配</strong>：顺序、择一、可选、重复</li>
<li><strong>子字段提取</strong>：JSON/KV 嵌套字段</li>
</ul>
<hr>
<h2 id="-快速帮助"><a class="header" href="#-快速帮助">💬 快速帮助</a></h2>
<h3 id="常见问题-3"><a class="header" href="#常见问题-3">常见问题</a></h3>
<p><strong>Q: 从哪里开始学习？</strong>
A: 从 <a href="#wpl-快速入门">01-quickstart.md</a> 开始，5 分钟即可上手。</p>
<p><strong>Q: 如何解析我的日志格式？</strong>
A: 查看 <a href="#wpl-实战指南">03-practical-guide.md</a>，找到相似的场景并调整。</p>
<p><strong>Q: 某个类型/函数怎么用？</strong>
A: 查看 <a href="#wpl-语言参考">04-language-reference.md</a> 或 <a href="#wpl-函数参考">05-functions-reference.md</a>。</p>
<p><strong>Q: 解析失败怎么调试？</strong>
A: 参考 <a href="#快速调试技巧">01-quickstart.md § 调试技巧</a> 或 <a href="#7-常见问题">03-practical-guide.md § 常见问题</a>。</p>
<hr>
<p><strong>开始学习：</strong> <a href="#wpl-快速入门">01-quickstart.md</a> - 5分钟快速入门</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-完整类型系统示例"><a class="header" href="#wpl-完整类型系统示例">WPL 完整类型系统示例</a></h1>
<blockquote>
<p>一个示例展示 WPL 支持的所有主要数据类型</p>
</blockquote>
<p>本文档提供一个完整的、可运行的 WPL 规则示例，展示 23 种主要数据类型的使用方法。这是学习 WPL 类型系统的<strong>最佳参考</strong>。</p>
<hr>
<h2 id="-文档导航-1"><a class="header" href="#-文档导航-1">📑 文档导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>章节</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><a href="#-类型覆盖清单">类型覆盖清单</a></td><td>本示例包含的所有类型</td></tr>
<tr><td><a href="#-完整示例">完整示例</a></td><td>输入数据、WPL 规则、输出结果</td></tr>
<tr><td><a href="#-类型详解">类型详解</a></td><td>每种类型的详细说明</td></tr>
<tr><td><a href="#-使用建议">使用建议</a></td><td>学习路径和实战建议</td></tr>
<tr><td><a href="#-快速导航">快速导航</a></td><td>快速跳转到需要的内容</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-类型覆盖清单"><a class="header" href="#-类型覆盖清单">📋 类型覆盖清单</a></h2>
<p>本示例包含以下类型：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类别</th><th>包含类型</th><th>数量</th></tr>
</thead>
<tbody>
<tr><td><strong>基础类型</strong></td><td><code>peek_symbol</code>、<code>symbol</code>、<code>bool</code>、<code>chars</code>、<code>digit</code>、<code>float</code>、<code>_</code></td><td>7</td></tr>
<tr><td><strong>时间类型</strong></td><td><code>time_3339</code>、<code>time_2822</code>、<code>time/clf</code>、<code>time_timestamp</code></td><td>4</td></tr>
<tr><td><strong>网络类型</strong></td><td><code>ip</code>、<code>ip_net</code>、<code>port</code></td><td>3</td></tr>
<tr><td><strong>结构化类型</strong></td><td><code>kvarr</code>、<code>json</code></td><td>2</td></tr>
<tr><td><strong>协议类型</strong></td><td><code>http/request</code>、<code>http/status</code>、<code>http/agent</code>、<code>http/method</code></td><td>4</td></tr>
<tr><td><strong>编码类型</strong></td><td><code>hex</code>、<code>base64</code></td><td>2</td></tr>
<tr><td><strong>特殊类型</strong></td><td><code>sn</code></td><td>1</td></tr>
<tr><td><strong>总计</strong></td><td></td><td><strong>23 种类型</strong></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-完整示例"><a class="header" href="#-完整示例">🚀 完整示例</a></h2>
<h3 id="输入数据"><a class="header" href="#输入数据">输入数据</a></h3>
<pre><code>peek_symbol symbol true "hello world" 123 3.14 2026-01-19T12:34:56Z 2022-03-21T12:34:56+00:00 Mon, 07 Jul 2025 09:20:32 +0000 [06/Aug/2019:12:12:19 +0800] 1647849600 192.168.1.100 192.168.0.0/24 name=test {"strict":true} "GET /api/users HTTP/1.1" 200 "Mozilla/5.0" "POST" 8080 ABC123XYZ 0x1A2B YmFzZTY0ZGF0YQ==
</code></pre>
<h3 id="wpl-规则"><a class="header" href="#wpl-规则">WPL 规则</a></h3>
<pre><code class="language-wpl">package wpl_example {
  rule full_types {
    (
      // 1. peek_symbol - 预读符号（不消费）
      peek_symbol(peek_symbol):peek_sym,

      // 2. symbol - 精确匹配符号
      symbol(symbol):sym,

      // 3. bool - 布尔值
      bool:bool_val,

      // 4. chars - 字符串（带引号）
      chars":quoted_str,

      // 5. digit - 整数
      digit:integer,

      // 6. float - 浮点数
      float:float_val,

      // 7. time_3339 - ISO 8601 / RFC3339
      time_3339:time_iso,

      // 8. time_3339 - RFC3339（带时区）
      time_3339:time_rfc3339,

      // 9. time_2822 - RFC2822（邮件时间格式）
      time_2822:time_rfc2822,

      // 10. time/clf - Common Log Format（Apache/Nginx）
      time/clf&lt;[,]&gt;:time_clf,

      // 11. time_timestamp - Unix 时间戳
      time_timestamp:timestamp,

      // 12. ip - IP 地址
      ip:ip_addr,

      // 13. ip_net - IP 网段（CIDR）
      ip_net:ip_network,

      // 14. kvarr - 键值对
      kvarr(chars@name):kv_data,

      // 15. json - JSON 对象
      json(bool@strict):json_data,

      // 16. http/request - HTTP 请求行
      http/request":http_req,

      // 17. http/status - HTTP 状态码
      http/status:http_status,

      // 18. http/agent - User-Agent
      http/agent":user_agent,

      // 19. http/method - HTTP 方法
      http/method":http_method,

      // 20. port - 端口号
      port:port_num,

      // 21. sn - 序列号
      sn:serial,

      // 22. hex - 十六进制
      hex:hex_data,

      // 23. base64 - Base64 编码
      base64:base64_data
    )
  }
}
</code></pre>
<h3 id="输出结果"><a class="header" href="#输出结果">输出结果</a></h3>
<pre><code class="language-json">{
  "peek_sym": "peek_symbol",
  "sym": "symbol",
  "bool_val": true,
  "quoted_str": "hello world",
  "integer": 123,
  "float_val": 3.14,
  "time_iso": "2026-01-19 12:34:56",
  "time_rfc3339": "2022-03-21 12:34:56",
  "time_rfc2822": "2025-07-07 09:20:32",
  "time_clf": "2019-08-06 12:12:19",
  "timestamp": 1647849600,
  "ip_addr": "192.168.1.100",
  "ip_network": "192.168.0.0/24",
  "kv_data": {"name": "test"},
  "json_data": {"strict": true},
  "http_req": "GET /api/users HTTP/1.1",
  "http_status": 200,
  "user_agent": "Mozilla/5.0",
  "http_method": "POST",
  "port_num": 8080,
  "serial": "ABC123XYZ",
  "hex_data": "0x1A2B",
  "base64_data": "YmFzZTY0ZGF0YQ=="
}
</code></pre>
<hr>
<h2 id="-类型详解"><a class="header" href="#-类型详解">📖 类型详解</a></h2>
<h3 id="基础类型"><a class="header" href="#基础类型">基础类型</a></h3>
<h4 id="1-peek_symbol---预读符号"><a class="header" href="#1-peek_symbol---预读符号">1. peek_symbol - 预读符号</a></h4>
<pre><code class="language-wpl">peek_symbol(peek_symbol):peek_sym
</code></pre>
<ul>
<li><strong>作用</strong>：预读匹配但不消费输入</li>
<li><strong>用途</strong>：用于向前查看而不影响后续解析</li>
</ul>
<h4 id="2-symbol---精确匹配符号"><a class="header" href="#2-symbol---精确匹配符号">2. symbol - 精确匹配符号</a></h4>
<pre><code class="language-wpl">symbol(symbol):sym
</code></pre>
<ul>
<li><strong>作用</strong>：精确匹配指定字符串</li>
<li><strong>用途</strong>：匹配固定关键字、分隔符等</li>
</ul>
<h4 id="3-bool---布尔值"><a class="header" href="#3-bool---布尔值">3. bool - 布尔值</a></h4>
<pre><code class="language-wpl">bool:bool_val
</code></pre>
<ul>
<li><strong>匹配</strong>：<code>true</code> 或 <code>false</code></li>
<li><strong>输出</strong>：布尔类型</li>
</ul>
<h4 id="4-chars---字符串"><a class="header" href="#4-chars---字符串">4. chars - 字符串</a></h4>
<pre><code class="language-wpl">chars":quoted_str
</code></pre>
<ul>
<li><strong>格式</strong>：支持引号包裹 <code>"hello"</code> 或裸字符串 <code>hello</code></li>
<li><strong>用途</strong>：提取任意字符串</li>
</ul>
<h4 id="5-digit---整数"><a class="header" href="#5-digit---整数">5. digit - 整数</a></h4>
<pre><code class="language-wpl">digit:integer
</code></pre>
<ul>
<li><strong>匹配</strong>：整数，如 <code>123</code>、<code>-456</code></li>
<li><strong>输出</strong>：整数类型</li>
</ul>
<h4 id="6-float---浮点数"><a class="header" href="#6-float---浮点数">6. float - 浮点数</a></h4>
<pre><code class="language-wpl">float:float_val
</code></pre>
<ul>
<li><strong>匹配</strong>：浮点数，如 <code>3.14</code>、<code>-0.5</code></li>
<li><strong>输出</strong>：浮点数类型</li>
</ul>
<hr>
<h3 id="时间类型"><a class="header" href="#时间类型">时间类型</a></h3>
<h4 id="7-8-time_3339---rfc3339iso-8601"><a class="header" href="#7-8-time_3339---rfc3339iso-8601">7-8. time_3339 - RFC3339/ISO 8601</a></h4>
<pre><code class="language-wpl">time_3339:time_iso           // 2026-01-19T12:34:56Z
time_3339:time_rfc3339       // 2022-03-21T12:34:56+00:00
</code></pre>
<ul>
<li><strong>格式</strong>：ISO 8601 / RFC3339 标准</li>
<li><strong>支持</strong>：带时区或不带时区</li>
</ul>
<h4 id="9-time_2822---rfc2822邮件时间"><a class="header" href="#9-time_2822---rfc2822邮件时间">9. time_2822 - RFC2822（邮件时间）</a></h4>
<pre><code class="language-wpl">time_2822:time_rfc2822
</code></pre>
<ul>
<li><strong>格式</strong>：<code>Mon, 07 Jul 2025 09:20:32 +0000</code></li>
<li><strong>用途</strong>：邮件头、RSS 等</li>
</ul>
<h4 id="10-timeclf---common-log-format"><a class="header" href="#10-timeclf---common-log-format">10. time/clf - Common Log Format</a></h4>
<pre><code class="language-wpl">time/clf&lt;[,]&gt;:time_clf
</code></pre>
<ul>
<li><strong>格式</strong>：<code>[06/Aug/2019:12:12:19 +0800]</code></li>
<li><strong>用途</strong>：Apache/Nginx 日志</li>
</ul>
<h4 id="11-time_timestamp---unix-时间戳"><a class="header" href="#11-time_timestamp---unix-时间戳">11. time_timestamp - Unix 时间戳</a></h4>
<pre><code class="language-wpl">time_timestamp:timestamp
</code></pre>
<ul>
<li><strong>格式</strong>：秒级时间戳，如 <code>1647849600</code></li>
<li><strong>输出</strong>：时间类型</li>
</ul>
<hr>
<h3 id="网络类型"><a class="header" href="#网络类型">网络类型</a></h3>
<h4 id="12-ip---ip-地址"><a class="header" href="#12-ip---ip-地址">12. ip - IP 地址</a></h4>
<pre><code class="language-wpl">ip:ip_addr
</code></pre>
<ul>
<li><strong>支持</strong>：IPv4（<code>192.168.1.100</code>）和 IPv6（<code>::1</code>）</li>
</ul>
<h4 id="13-ip_net---ip-网段"><a class="header" href="#13-ip_net---ip-网段">13. ip_net - IP 网段</a></h4>
<pre><code class="language-wpl">ip_net:ip_network
</code></pre>
<ul>
<li><strong>格式</strong>：CIDR 表示法，如 <code>192.168.0.0/24</code></li>
</ul>
<h4 id="14-port---端口号"><a class="header" href="#14-port---端口号">14. port - 端口号</a></h4>
<pre><code class="language-wpl">port:port_num
</code></pre>
<ul>
<li><strong>范围</strong>：1-65535</li>
</ul>
<hr>
<h3 id="结构化类型"><a class="header" href="#结构化类型">结构化类型</a></h3>
<h4 id="15-kvarr---键值对"><a class="header" href="#15-kvarr---键值对">15. kvarr - 键值对</a></h4>
<pre><code class="language-wpl">kvarr(chars@name):kv_data
</code></pre>
<ul>
<li><strong>格式</strong>：<code>key=value</code></li>
<li><strong>支持</strong>：自动解析或指定键提取</li>
<li><strong>示例</strong>：<code>name=test</code> → <code>{name: "test"}</code></li>
</ul>
<h4 id="16-json---json-对象"><a class="header" href="#16-json---json-对象">16. json - JSON 对象</a></h4>
<pre><code class="language-wpl">json(bool@strict):json_data
</code></pre>
<ul>
<li><strong>支持</strong>：完整 JSON 解析</li>
<li><strong>子字段</strong>：可提取嵌套字段</li>
<li><strong>示例</strong>：<code>{"strict":true}</code> → <code>{strict: true}</code></li>
</ul>
<hr>
<h3 id="协议类型"><a class="header" href="#协议类型">协议类型</a></h3>
<h4 id="17-httprequest---http-请求行"><a class="header" href="#17-httprequest---http-请求行">17. http/request - HTTP 请求行</a></h4>
<pre><code class="language-wpl">http/request":http_req
</code></pre>
<ul>
<li><strong>格式</strong>：<code>"GET /api/users HTTP/1.1"</code></li>
<li><strong>提取</strong>：方法 + 路径 + 协议版本</li>
</ul>
<h4 id="18-httpstatus---http-状态码"><a class="header" href="#18-httpstatus---http-状态码">18. http/status - HTTP 状态码</a></h4>
<pre><code class="language-wpl">http/status:http_status
</code></pre>
<ul>
<li><strong>格式</strong>：<code>200</code>、<code>404</code>、<code>500</code> 等</li>
</ul>
<h4 id="19-httpagent---user-agent"><a class="header" href="#19-httpagent---user-agent">19. http/agent - User-Agent</a></h4>
<pre><code class="language-wpl">http/agent":user_agent
</code></pre>
<ul>
<li><strong>格式</strong>：<code>"Mozilla/5.0..."</code></li>
<li><strong>用途</strong>：浏览器标识</li>
</ul>
<h4 id="20-httpmethod---http-方法"><a class="header" href="#20-httpmethod---http-方法">20. http/method - HTTP 方法</a></h4>
<pre><code class="language-wpl">http/method":http_method
</code></pre>
<ul>
<li><strong>支持</strong>：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等</li>
</ul>
<hr>
<h3 id="编码类型"><a class="header" href="#编码类型">编码类型</a></h3>
<h4 id="21-hex---十六进制"><a class="header" href="#21-hex---十六进制">21. hex - 十六进制</a></h4>
<pre><code class="language-wpl">hex:hex_data
</code></pre>
<ul>
<li><strong>格式</strong>：<code>0x1A2B</code> 或 <code>1A2B</code></li>
<li><strong>输出</strong>：十六进制字符串</li>
</ul>
<h4 id="22-base64---base64-编码"><a class="header" href="#22-base64---base64-编码">22. base64 - Base64 编码</a></h4>
<pre><code class="language-wpl">base64:base64_data
</code></pre>
<ul>
<li><strong>格式</strong>：<code>YmFzZTY0ZGF0YQ==</code></li>
<li><strong>输出</strong>：Base64 编码字符串</li>
</ul>
<hr>
<h3 id="特殊类型"><a class="header" href="#特殊类型">特殊类型</a></h3>
<h4 id="23-sn---序列号"><a class="header" href="#23-sn---序列号">23. sn - 序列号</a></h4>
<pre><code class="language-wpl">sn:serial
</code></pre>
<ul>
<li><strong>格式</strong>：字母数字组合，如 <code>ABC123XYZ</code></li>
<li><strong>用途</strong>：设备序列号、订单号等</li>
</ul>
<hr>
<h2 id="-使用建议"><a class="header" href="#-使用建议">💡 使用建议</a></h2>
<h3 id="学习路径-1"><a class="header" href="#学习路径-1">学习路径</a></h3>
<ol>
<li><strong>第一步</strong>：先理解基础类型（<code>digit</code>、<code>chars</code>、<code>ip</code>）</li>
<li><strong>第二步</strong>：掌握时间类型（根据日志格式选择）</li>
<li><strong>第三步</strong>：学习结构化类型（<code>json</code>、<code>kvarr</code>）</li>
<li><strong>第四步</strong>：了解协议类型（<code>http/*</code>）</li>
</ol>
<h3 id="实战建议"><a class="header" href="#实战建议">实战建议</a></h3>
<ul>
<li><strong>快速查阅</strong>：遇到不认识的数据格式，先在本页面搜索</li>
<li><strong>复制即用</strong>：直接复制对应类型的语法到你的规则中</li>
<li><strong>类型组合</strong>：多种类型可以自由组合使用</li>
</ul>
<h3 id="常见组合"><a class="header" href="#常见组合">常见组合</a></h3>
<pre><code class="language-wpl">// Web 日志
(ip, time/clf&lt;[,]&gt;, http/request", http/status, digit)

// API 日志
(time_3339, chars, json(chars@user, digit@code))

// 防火墙日志
(ip, port, time, kvarr)
</code></pre>
<hr>
<h2 id="-相关文档"><a class="header" href="#-相关文档">🔗 相关文档</a></h2>
<ul>
<li><strong>快速入门</strong>：<a href="#wpl-快速入门">01-quickstart.md</a> - 5 分钟上手</li>
<li><strong>核心概念</strong>：<a href="#wpl-核心概念">02-core-concepts.md</a> - 深入理解类型系统</li>
<li><strong>实战指南</strong>：<a href="#wpl-实战指南">03-practical-guide.md</a> - 按任务查找解决方案</li>
<li><strong>语言参考</strong>：<a href="#wpl-语言参考">04-language-reference.md</a> - 完整类型列表</li>
<li><strong>函数参考</strong>：<a href="#wpl-函数参考">05-functions-reference.md</a> - 所有函数详解</li>
</ul>
<hr>
<h2 id="-快速导航"><a class="header" href="#-快速导航">📌 快速导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>我想…</th><th>查看章节</th></tr>
</thead>
<tbody>
<tr><td>查看完整示例代码</td><td><a href="#-完整示例">完整示例</a></td></tr>
<tr><td>了解某个类型详情</td><td><a href="#-类型详解">类型详解</a></td></tr>
<tr><td>学习如何使用</td><td><a href="#-使用建议">使用建议</a></td></tr>
<tr><td>查找常见组合</td><td><a href="#常见组合">常见组合</a></td></tr>
</tbody>
</table>
</div>
<hr>
<p><strong>提示</strong>：将本页面加入书签，作为 WPL 类型系统的速查手册！</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-快速入门"><a class="header" href="#wpl-快速入门">WPL 快速入门</a></h1>
<p>5 分钟上手 WPL，立即解析你的日志数据。</p>
<hr>
<h2 id="-快速导航-1"><a class="header" href="#-快速导航-1">📚 快速导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>主题</th><th>内容</th></tr>
</thead>
<tbody>
<tr><td><a href="#什么是-wpl"><strong>什么是 WPL</strong></a></td><td>WPL 简介、核心特点、适用场景</td></tr>
<tr><td><a href="#-完整类型系统"><strong>完整类型系统</strong></a></td><td>23 种数据类型总览</td></tr>
<tr><td><a href="#最简示例nginx-日志"><strong>最简示例</strong></a></td><td>Nginx 日志解析</td></tr>
<tr><td><a href="#3-个最常用场景"><strong>3 个最常用场景</strong></a></td><td>空格分隔、JSON、KV 键值对</td></tr>
<tr><td><a href="#基本语法速览"><strong>基本语法速览</strong></a></td><td>结构、类型、匹配模式</td></tr>
<tr><td><a href="#常见模式速查"><strong>常见模式速查</strong></a></td><td>引号字段、可选字段、重复字段等</td></tr>
<tr><td><a href="#快速调试技巧"><strong>快速调试技巧</strong></a></td><td>调试方法</td></tr>
<tr><td><a href="#实战练习"><strong>实战练习</strong></a></td><td>3 个练习题</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="什么是-wpl"><a class="header" href="#什么是-wpl">什么是 WPL</a></h2>
<p>WPL (Warp Processing Language) 是一种<strong>声明式规则语言</strong>，用于描述如何从日志、消息等文本数据中<strong>提取字段</strong>和<strong>解析结构</strong>。</p>
<h3 id="核心特点"><a class="header" href="#核心特点">核心特点</a></h3>
<ul>
<li><strong>声明式</strong>：描述“数据是什么“，而非“如何提取“</li>
<li><strong>类型安全</strong>：自动验证和转换（IP、时间、JSON 等 37 种类型）</li>
<li><strong>强大灵活</strong>：支持 JSON/KV 嵌套提取、Base64 解码、字段验证等</li>
<li><strong>易于学习</strong>：5 分钟即可上手基础用法</li>
</ul>
<h3 id="适用场景"><a class="header" href="#适用场景">适用场景</a></h3>
<ul>
<li>解析 Web 服务器日志（Nginx、Apache）</li>
<li>提取 JSON/KV 结构化数据</li>
<li>处理编码数据（Base64、Hex）</li>
<li>防火墙、安全设备日志解析</li>
<li>自定义日志格式解析</li>
</ul>
<hr>
<h2 id="-完整类型系统"><a class="header" href="#-完整类型系统">📚 完整类型系统</a></h2>
<p><strong>WPL 支持 23 种主要数据类型</strong>，涵盖基础类型、时间、网络、结构化数据、协议和编码等。</p>
<p>👉 <strong>查看完整示例：</strong> <a href="#wpl-完整类型系统示例">07-complete-types-example.md</a></p>
<p>该文档包含：</p>
<ul>
<li>✅ 所有 23 种类型的完整示例代码</li>
<li>✅ 可运行的输入数据和 WPL 规则</li>
<li>✅ 每种类型的详细说明和使用建议</li>
<li>✅ 常见类型组合模式</li>
</ul>
<p><strong>快速预览主要类型：</strong></p>
<ul>
<li><strong>基础</strong>：<code>digit</code>、<code>float</code>、<code>chars</code>、<code>bool</code></li>
<li><strong>时间</strong>：<code>time/clf</code>、<code>time_3339</code>、<code>time_2822</code>、<code>time_timestamp</code></li>
<li><strong>网络</strong>：<code>ip</code>、<code>ip_net</code>、<code>port</code>、<code>domain</code>、<code>url</code></li>
<li><strong>结构化</strong>：<code>json</code>、<code>kvarr</code>、<code>array</code></li>
<li><strong>协议</strong>：<code>http/request</code>、<code>http/status</code>、<code>http/method</code>、<code>http/agent</code></li>
<li><strong>编码</strong>：<code>hex</code>、<code>base64</code></li>
</ul>
<hr>
<h2 id="最简示例nginx-日志"><a class="header" href="#最简示例nginx-日志">最简示例：Nginx 日志</a></h2>
<p><strong>输入数据：</strong></p>
<pre><code>192.168.1.2 - - [06/Aug/2019:12:12:19 +0800] "GET /index.html HTTP/1.1" 200 1024
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package nginx {
  rule access_log {
    (
      ip:client_ip,
      2*_,
      time/clf&lt;[,]&gt;:time,
      http/request":request,
      digit:status,
      digit:bytes
    )
  }
}
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>client_ip: 192.168.1.2
time: 2019-08-06 12:12:19
request: GET /index.html HTTP/1.1
status: 200
bytes: 1024
</code></pre>
<p><strong>说明：</strong></p>
<ul>
<li><code>ip:client_ip</code> - 提取 IP 地址，命名为 client_ip</li>
<li><code>2*_</code> - 忽略 2 个字段（两个 <code>-</code>）</li>
<li><code>time/clf&lt;[,]&gt;</code> - 提取方括号包裹的 CLF 时间</li>
<li><code>http/request"</code> - 提取引号包裹的 HTTP 请求</li>
<li><code>digit</code> - 提取数字</li>
</ul>
<hr>
<h2 id="3-个最常用场景"><a class="header" href="#3-个最常用场景">3 个最常用场景</a></h2>
<h3 id="场景-1空格分隔的日志"><a class="header" href="#场景-1空格分隔的日志">场景 1：空格分隔的日志</a></h3>
<p><strong>输入：</strong></p>
<pre><code>200 192.168.1.1 2023-01-01T12:00:00 login_success
</code></pre>
<p><strong>WPL：</strong></p>
<pre><code class="language-wpl">package demo {
  rule simple_log {
    (digit:code, ip:client, time:ts, chars:action)
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>code: 200
client: 192.168.1.1
ts: 2023-01-01 12:00:00
action: login_success
</code></pre>
<hr>
<h3 id="场景-2json-数据"><a class="header" href="#场景-2json-数据">场景 2：JSON 数据</a></h3>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"user":"admin","code":200,"message":"success"}
</code></pre>
<p><strong>WPL：</strong></p>
<pre><code class="language-wpl">package api {
  rule json_response {
    (json(
      chars@user,
      digit@code,
      chars@message
    ))
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>user: admin
code: 200
message: success
</code></pre>
<hr>
<h3 id="场景-3kv-键值对"><a class="header" href="#场景-3kv-键值对">场景 3：KV 键值对</a></h3>
<p><strong>输入：</strong></p>
<pre><code>host=server1;port=8080;user=admin;status=online
</code></pre>
<p><strong>WPL：</strong></p>
<pre><code class="language-wpl">package config {
  rule kv_log {
    (kvarr)
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>host: server1
port: 8080
user: admin
status: online
</code></pre>
<hr>
<h2 id="基本语法速览"><a class="header" href="#基本语法速览">基本语法速览</a></h2>
<h3 id="结构"><a class="header" href="#结构">结构</a></h3>
<pre><code class="language-wpl">package 包名 {
  rule 规则名 {
    (字段列表)
  }
}
</code></pre>
<h3 id="常用字段类型"><a class="header" href="#常用字段类型">常用字段类型</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类型</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><code>digit</code></td><td>整数</td><td><code>200</code>, <code>8080</code></td></tr>
<tr><td><code>chars</code></td><td>字符串</td><td><code>"hello"</code>, <code>admin</code></td></tr>
<tr><td><code>ip</code></td><td>IP 地址</td><td><code>192.168.1.1</code></td></tr>
<tr><td><code>time</code></td><td>时间</td><td><code>2023-01-01 12:00:00</code></td></tr>
<tr><td><code>time/clf</code></td><td>CLF 时间</td><td><code>[06/Aug/2019:12:12:19 +0800]</code></td></tr>
<tr><td><code>json</code></td><td>JSON 对象</td><td><code>{"key":"value"}</code></td></tr>
<tr><td><code>kv</code></td><td>键值对</td><td><code>key=value</code></td></tr>
<tr><td><code>http/request</code></td><td>HTTP 请求</td><td><code>GET /path HTTP/1.1</code></td></tr>
<tr><td><code>http/status</code></td><td>HTTP 状态码</td><td><code>200</code></td></tr>
</tbody>
</table>
</div>
<h3 id="字段命名"><a class="header" href="#字段命名">字段命名</a></h3>
<pre><code class="language-wpl">type:name              # 命名字段
digit:status           # status = 数字
ip:client_ip           # client_ip = IP地址
</code></pre>
<h3 id="忽略字段"><a class="header" href="#忽略字段">忽略字段</a></h3>
<pre><code class="language-wpl">_                      # 忽略 1 个字段
2*_                    # 忽略 2 个字段
5*_                    # 忽略 5 个字段
</code></pre>
<h3 id="格式控制"><a class="header" href="#格式控制">格式控制</a></h3>
<pre><code class="language-wpl">&lt;[,]&gt;                  # 方括号包裹：[content]
&lt;{,}&gt;                  # 花括号包裹：{content}
"                      # 引号包裹："content"
^N                     # 固定 N 个字符
</code></pre>
<h3 id="重复模式"><a class="header" href="#重复模式">重复模式</a></h3>
<pre><code class="language-wpl">kvarr                  # 自动解析所有KV
3*ip                   # 重复 3 次
12*digit               # 重复 12 次
</code></pre>
<h3 id="子字段提取"><a class="header" href="#子字段提取">子字段提取</a></h3>
<pre><code class="language-wpl"># JSON 子字段
json(chars@name, digit@age)

# KV 子字段
kvarr(chars@host, digit@port)

# 嵌套字段
json(chars@user/name, digit@user/age)
</code></pre>
<hr>
<h2 id="常见模式速查"><a class="header" href="#常见模式速查">常见模式速查</a></h2>
<h3 id="解析带引号的字段"><a class="header" href="#解析带引号的字段">解析带引号的字段</a></h3>
<pre><code class="language-wpl">chars":url             # "http://example.com"
http/agent":ua         # "Mozilla/5.0..."
</code></pre>
<h3 id="解析带特殊分隔符的数据"><a class="header" href="#解析带特殊分隔符的数据">解析带特殊分隔符的数据</a></h3>
<pre><code class="language-wpl"># 逗号分隔
(digit, ip, chars)\,

# 分号分隔
(digit, ip, chars)\;

# 字段级分隔符（优先级更高）
digit\,, ip\;, chars\s
</code></pre>
<h3 id="可选字段"><a class="header" href="#可选字段">可选字段</a></h3>
<pre><code class="language-wpl">opt(chars)             # 可选字段
(digit, opt(chars), time)
</code></pre>
<h3 id="base64-解码"><a class="header" href="#base64-解码">Base64 解码</a></h3>
<pre><code class="language-wpl">|decode/base64|
(json(chars@data))
</code></pre>
<hr>
<h2 id="快速调试技巧"><a class="header" href="#快速调试技巧">快速调试技巧</a></h2>
<h3 id="1-从简单开始"><a class="header" href="#1-从简单开始">1. 从简单开始</a></h3>
<pre><code class="language-wpl"># 第 1 步：最简单
(digit)

# 第 2 步：添加字段
(digit, ip)

# 第 3 步：添加命名
(digit:status, ip:client)

# 第 4 步：添加复杂类型
(digit:status, ip:client, json(chars@name))
</code></pre>
<h3 id="2-使用-opt-定位问题"><a class="header" href="#2-使用-opt-定位问题">2. 使用 opt() 定位问题</a></h3>
<pre><code class="language-wpl"># 如果某个字段导致失败，用 opt 包裹
(digit, opt(ip), time, chars)
# 如果 ip 解析失败，其他字段仍然可以解析
</code></pre>
<h3 id="3-检查分隔符"><a class="header" href="#3-检查分隔符">3. 检查分隔符</a></h3>
<p>打印原始数据，确认字段间的分隔符：</p>
<pre><code>数据：200,192.168.1.1,admin
分隔符：逗号
规则：(digit, ip, chars)\,
</code></pre>
<hr>
<h2 id="下一步-1"><a class="header" href="#下一步-1">下一步</a></h2>
<h3 id="理解概念"><a class="header" href="#理解概念">理解概念</a></h3>
<p>→ <a href="#wpl-核心概念">02-core-concepts.md</a> - 理解 WPL 的设计理念</p>
<p><strong>你将学到：</strong></p>
<ul>
<li>为什么 WPL 这样设计？</li>
<li>类型系统的作用</li>
<li>匹配语义（seq/alt/opt/some_of）</li>
<li>管道系统原理</li>
<li>分隔符优先级</li>
</ul>
<hr>
<h3 id="解决实际问题"><a class="header" href="#解决实际问题">解决实际问题</a></h3>
<p>→ <a href="#wpl-实战指南">03-practical-guide.md</a> - 按任务查找解决方案</p>
<p><strong>你将学到：</strong></p>
<ul>
<li>解析 Web 服务器日志（Nginx/Apache）</li>
<li>解析 JSON 数据（嵌套、反转义）</li>
<li>解析 KV 键值对（多种分隔符）</li>
<li>处理编码数据（Base64/Hex）</li>
<li>字段验证与过滤</li>
<li>复杂场景（重复模式、可选字段）</li>
</ul>
<hr>
<h3 id="查阅参考"><a class="header" href="#查阅参考">查阅参考</a></h3>
<p>→ <a href="#wpl-语言参考">04-language-reference.md</a> - 完整类型和语法参考
→ <a href="#wpl-函数参考">05-functions-reference.md</a> - 所有函数参考</p>
<hr>
<h2 id="实战练习"><a class="header" href="#实战练习">实战练习</a></h2>
<h3 id="练习-1解析自定义日志"><a class="header" href="#练习-1解析自定义日志">练习 1：解析自定义日志</a></h3>
<p><strong>数据：</strong></p>
<pre><code>[2023-01-01 12:00:00] INFO 192.168.1.1 user=admin action=login
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>时间在方括号中</li>
<li>INFO 可以忽略</li>
<li>后面是 IP 和 KV</li>
</ul>
<details>
<summary>查看答案</summary>
<pre><code class="language-wpl">package practice {
  rule custom_log {
    (
      time&lt;[,]&gt;:timestamp,
      _,
      ip:client,
      kvarr
    )
  }
}
</code></pre>
</details>
<hr>
<h3 id="练习-2解析嵌套-json"><a class="header" href="#练习-2解析嵌套-json">练习 2：解析嵌套 JSON</a></h3>
<p><strong>数据：</strong></p>
<pre><code class="language-json">{"user":{"name":"Alice","age":25},"status":"active"}
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>使用 @path/to/field 提取嵌套字段</li>
</ul>
<details>
<summary>查看答案</summary>
<pre><code class="language-wpl">package practice {
  rule nested_json {
    (json(
      chars@user/name,
      digit@user/age,
      chars@status
    ))
  }
}
</code></pre>
</details>
<hr>
<h3 id="练习-3解析-base64-编码日志"><a class="header" href="#练习-3解析-base64-编码日志">练习 3：解析 Base64 编码日志</a></h3>
<p><strong>数据（Base64）：</strong></p>
<pre><code>eyJ1c2VyIjoiYWRtaW4iLCJjb2RlIjoyMDB9
</code></pre>
<p><strong>解码后：</strong></p>
<pre><code class="language-json">{"user":"admin","code":200}
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>使用 <code>|decode/base64|</code> 预处理</li>
</ul>
<details>
<summary>查看答案</summary>
<pre><code class="language-wpl">package practice {
  rule base64_log {
    |decode/base64|
    (json(
      chars@user,
      digit@code
    ))
  }
}
</code></pre>
</details>
<hr>
<h2 id="相关资源"><a class="header" href="#相关资源">相关资源</a></h2>
<ul>
<li>核心概念：<a href="#wpl-核心概念">02-core-concepts.md</a></li>
<li>实战指南：<a href="#wpl-实战指南">03-practical-guide.md</a></li>
<li>语言参考：<a href="#wpl-语言参考">04-language-reference.md</a></li>
<li>函数参考：<a href="#wpl-函数参考">05-functions-reference.md</a></li>
<li>语法规范：<a href="#wpl-语法参考ebnf">06-grammar-reference.md</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-核心概念"><a class="header" href="#wpl-核心概念">WPL 核心概念</a></h1>
<p>本文档帮助你理解 WPL 的设计理念和核心概念，建立正确的思维模型。</p>
<hr>
<h2 id="-文档导航-2"><a class="header" href="#-文档导航-2">📚 文档导航</a></h2>
<h3 id="快速导航"><a class="header" href="#快速导航">快速导航</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>主题</th><th>内容</th></tr>
</thead>
<tbody>
<tr><td><a href="#wpl-设计理念"><strong>设计理念</strong></a></td><td>为什么需要 WPL、核心思想、声明式设计</td></tr>
<tr><td><a href="#类型系统"><strong>类型系统</strong></a></td><td>类型的作用、类型层次、类型组合</td></tr>
<tr><td><a href="#匹配语义"><strong>匹配语义</strong></a></td><td>seq 顺序、alt 择一、opt 可选、some_of 重复</td></tr>
<tr><td><a href="#管道系统"><strong>管道系统</strong></a></td><td>预处理管道、字段级管道、两者区别</td></tr>
<tr><td><a href="#子字段与嵌套"><strong>子字段与嵌套</strong></a></td><td>JSON 子字段、KV 子字段、数组</td></tr>
<tr><td><a href="#分隔符优先级"><strong>分隔符优先级</strong></a></td><td>优先级规则、分隔符类型、实际应用</td></tr>
<tr><td><a href="#设计原则总结"><strong>设计原则</strong></a></td><td>声明式、类型安全、组合性、明确性</td></tr>
<tr><td><a href="#常见误解"><strong>常见误解</strong></a></td><td>WPL vs 正则、字段连续性、格式灵活性</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="wpl-设计理念"><a class="header" href="#wpl-设计理念">WPL 设计理念</a></h2>
<h3 id="为什么需要-wpl"><a class="header" href="#为什么需要-wpl">为什么需要 WPL？</a></h3>
<p><strong>问题：</strong> 如何从非结构化文本中提取结构化数据？</p>
<pre><code>输入（文本）：192.168.1.1 - - [06/Aug/2019:12:12:19 +0800] "GET /index.html" 200
输出（结构）：
  client_ip: 192.168.1.1
  time: 2019-08-06 12:12:19
  request: GET /index.html
  status: 200
</code></pre>
<p><strong>传统方法的问题：</strong></p>
<ul>
<li>正则表达式：难写、难读、难维护</li>
<li>手写解析器：代码冗长、容易出错</li>
<li>固定格式解析：不够灵活</li>
</ul>
<p><strong>WPL 的解决方案：</strong></p>
<ul>
<li><strong>声明式</strong>：描述“是什么“，而非“怎么做“</li>
<li><strong>类型安全</strong>：自动验证和转换</li>
<li><strong>组合性</strong>：小的规则组合成复杂规则</li>
</ul>
<hr>
<h3 id="核心思想规则--模式匹配--字段提取"><a class="header" href="#核心思想规则--模式匹配--字段提取">核心思想：规则 = 模式匹配 + 字段提取</a></h3>
<pre><code class="language-wpl">package demo {
  rule example {
    (ip:client, digit:status, time:ts)
  }
}
</code></pre>
<p><strong>这个规则表达：</strong></p>
<ol>
<li><strong>模式</strong>：数据格式是“IP 数字 时间“</li>
<li><strong>提取</strong>：提取 3 个字段，分别命名为 client、status、ts</li>
<li><strong>验证</strong>：自动验证 IP 格式、数字格式、时间格式</li>
<li><strong>转换</strong>：自动转换为对应类型</li>
</ol>
<hr>
<h2 id="类型系统"><a class="header" href="#类型系统">类型系统</a></h2>
<h3 id="类型的作用"><a class="header" href="#类型的作用">类型的作用</a></h3>
<p>类型在 WPL 中有三个作用：</p>
<ol>
<li><strong>验证</strong>：确保数据符合预期格式</li>
<li><strong>转换</strong>：自动转换为标准格式</li>
<li><strong>语义</strong>：表达数据的含义</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl"># 输入：06/Aug/2019:12:12:19 +0800
time/clf:access_time

# 类型 time/clf 做了 3 件事：
# 1. 验证：是否符合 CLF 时间格式
# 2. 转换：转换为标准时间格式 2019-08-06 12:12:19
# 3. 语义：表达"这是访问时间"
</code></pre>
<hr>
<h3 id="类型的层次"><a class="header" href="#类型的层次">类型的层次</a></h3>
<pre><code>基础类型 ────→ 结构化类型 ────→ 协议类型
   ↓              ↓               ↓
 digit          json          http/request
 chars           kvarr        http/status
  ip           array          time/clf
 time           obj
</code></pre>
<p><strong>基础类型</strong>：原子数据</p>
<ul>
<li><code>digit</code> - 整数</li>
<li><code>chars</code> - 字符串</li>
<li><code>ip</code> - IP 地址</li>
<li><code>time</code> - 时间</li>
</ul>
<p><strong>结构化类型</strong>：复合数据</p>
<ul>
<li><code>json</code> - JSON 对象（包含多个字段）</li>
<li><code>kvarr</code> - 键值对</li>
<li><code>array</code> - 数组</li>
</ul>
<p><strong>协议类型</strong>：领域特定格式</p>
<ul>
<li><code>http/request</code> - HTTP 请求行</li>
<li><code>http/status</code> - HTTP 状态码</li>
<li><code>time/clf</code> - CLF 时间格式</li>
</ul>
<hr>
<h3 id="类型组合示例"><a class="header" href="#类型组合示例">类型组合示例</a></h3>
<pre><code class="language-wpl"># 简单组合
(digit, ip, time)

# 嵌套组合
(digit, json(chars@name, digit@age), time)

# 数组组合
array/digit              # 数字数组
array/array/chars        # 二维字符串数组
</code></pre>
<hr>
<h2 id="匹配语义"><a class="header" href="#匹配语义">匹配语义</a></h2>
<p>WPL 提供 4 种匹配语义，满足不同场景需求。</p>
<h3 id="seq顺序匹配--默认"><a class="header" href="#seq顺序匹配--默认">seq（顺序匹配）- 默认</a></h3>
<p><strong>语义</strong>：按顺序依次匹配每个字段</p>
<pre><code class="language-wpl"># 显式写法
seq(ip, digit, time)

# 隐式写法（默认）
(ip, digit, time)
</code></pre>
<p><strong>匹配过程：</strong></p>
<pre><code>输入：192.168.1.1 200 2023-01-01
      ↓           ↓   ↓
     ip         digit time
</code></pre>
<p><strong>何时使用：</strong> 字段顺序固定（90% 的场景）</p>
<hr>
<h3 id="alt择一匹配"><a class="header" href="#alt择一匹配">alt（择一匹配）</a></h3>
<p><strong>语义</strong>：尝试多种类型，匹配其中一个</p>
<pre><code class="language-wpl">alt(ip, digit)
</code></pre>
<p><strong>匹配过程：</strong></p>
<pre><code>输入：192.168.1.1
尝试：ip ✓ → 成功，返回 ip
      digit ✗ → 不尝试

输入：12345
尝试：ip ✗ → 失败
      digit ✓ → 成功，返回 digit
</code></pre>
<p><strong>何时使用：</strong> 同一位置可能是不同类型</p>
<p><strong>示例场景：</strong></p>
<pre><code class="language-wpl"># 日志中 user_id 可能是数字或字符串
(time, alt(digit, chars):user_id, chars:action)
</code></pre>
<hr>
<h3 id="opt可选匹配"><a class="header" href="#opt可选匹配">opt（可选匹配）</a></h3>
<p><strong>语义</strong>：字段可选，失败不报错</p>
<pre><code class="language-wpl">opt(chars)
</code></pre>
<p><strong>匹配过程：</strong></p>
<pre><code>输入：有内容 → 尝试匹配，成功则提取
输入：无内容 → 跳过，继续下一个字段
</code></pre>
<p><strong>何时使用：</strong> 某些字段可能不存在</p>
<p><strong>示例场景：</strong></p>
<pre><code class="language-wpl"># HTTP 日志中 referer 可能为空
(ip, time, http/request, digit, opt(chars):referer)
</code></pre>
<hr>
<h3 id="some_of尽可能多"><a class="header" href="#some_of尽可能多">some_of（尽可能多）</a></h3>
<p><strong>语义</strong>：循环匹配，尽可能多地消费字段</p>
<pre><code class="language-wpl">some_of(kvarr, ip, digit)
</code></pre>
<p><strong>匹配过程：</strong></p>
<pre><code>输入：k1=v1 192.168.1.1 200 k2=v2 300

循环 1：尝试 kvarr ✓ → 提取 k1=v1
循环 2：尝试 kvarr ✗, 尝试 ip ✓ → 提取 192.168.1.1
循环 3：尝试 kvarr ✗, 尝试 ip ✗, 尝试 digit ✓ → 提取 200
循环 4：尝试 kvarr ✓ → 提取 k2=v2
循环 5：尝试 kvarr ✗, 尝试 ip ✗, 尝试 digit ✓ → 提取 300
循环 6：全部失败 → 停止
</code></pre>
<p><strong>何时使用：</strong> 不确定数量和顺序的混合字段</p>
<hr>
<h3 id="匹配语义对比"><a class="header" href="#匹配语义对比">匹配语义对比</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>语义</th><th>用途</th><th>示例</th><th>匹配次数</th></tr>
</thead>
<tbody>
<tr><td><code>seq</code></td><td>顺序固定</td><td><code>(ip, digit, time)</code></td><td>每个字段 1 次</td></tr>
<tr><td><code>alt</code></td><td>类型不定</td><td><code>alt(ip, digit)</code></td><td>其中 1 个</td></tr>
<tr><td><code>opt</code></td><td>可选字段</td><td><code>opt(chars)</code></td><td>0 或 1 次</td></tr>
<tr><td><code>some_of</code></td><td>混合重复</td><td><code>some_of(kvarr, ip)</code></td><td>尽可能多</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="管道系统"><a class="header" href="#管道系统">管道系统</a></h2>
<p>WPL 的管道系统分为两层：<strong>预处理管道</strong>（整行级）和<strong>字段级管道</strong>（字段级）。</p>
<h3 id="预处理管道整行级"><a class="header" href="#预处理管道整行级">预处理管道（整行级）</a></h3>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|step1|step2|
(字段列表)
</code></pre>
<p><strong>作用域：</strong> 整行原始输入</p>
<p><strong>执行时机：</strong> 在字段解析之前</p>
<p><strong>常用场景：</strong></p>
<pre><code class="language-wpl"># Base64 解码
|decode/base64|
(json)

# 多步处理
|decode/base64|unquote/unescape|
(json(chars@path))
</code></pre>
<p><strong>为什么需要预处理管道？</strong></p>
<ul>
<li>某些日志整行都是 Base64 编码（如华为防火墙）</li>
<li>需要先解码，才能进行字段解析</li>
<li>预处理一次，所有字段都受益</li>
</ul>
<hr>
<h3 id="字段级管道字段级"><a class="header" href="#字段级管道字段级">字段级管道（字段级）</a></h3>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">(fields) |function1| |function2|
</code></pre>
<p><strong>作用域：</strong> 解析后的字段集合</p>
<p><strong>执行时机：</strong> 在字段解析之后</p>
<p><strong>常用场景：</strong></p>
<pre><code class="language-wpl"># 验证字段
(json |f_has(status) |f_digit_in(status, [200, 201]))

# 转换字段
(json(chars@message) |take(message) |json_unescape())
</code></pre>
<p><strong>为什么需要字段级管道？</strong></p>
<ul>
<li>需要验证某个字段是否存在</li>
<li>需要验证字段值是否符合条件</li>
<li>需要对特定字段进行转换</li>
</ul>
<hr>
<h3 id="两种管道的区别"><a class="header" href="#两种管道的区别">两种管道的区别</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>预处理管道</th><th>字段级管道</th></tr>
</thead>
<tbody>
<tr><td>作用域</td><td>整行输入</td><td>解析后字段</td></tr>
<tr><td>执行时机</td><td>解析前</td><td>解析后</td></tr>
<tr><td>语法</td><td><code>|step|</code></td><td><code>|function()|</code></td></tr>
<tr><td>典型用途</td><td>解码、反转义</td><td>验证、转换</td></tr>
</tbody>
</table>
</div>
<p><strong>示例对比：</strong></p>
<pre><code class="language-wpl"># 预处理管道：整行 Base64 解码
|decode/base64|
(json(chars@user))

# 字段级管道：单字段 Base64 解码
(json(chars@payload) |take(payload) |base64_decode())
</code></pre>
<hr>
<h2 id="子字段与嵌套"><a class="header" href="#子字段与嵌套">子字段与嵌套</a></h2>
<h3 id="为什么需要子字段"><a class="header" href="#为什么需要子字段">为什么需要子字段？</a></h3>
<p><strong>问题：</strong> JSON/KV 等结构化数据包含多个字段，如何提取？</p>
<pre><code class="language-json">{"user":"admin","code":200,"data":{"result":"ok"}}
</code></pre>
<p><strong>解决方案：</strong> 使用子字段语法</p>
<pre><code class="language-wpl">json(
  chars@user,              # 提取 user 字段
  digit@code,              # 提取 code 字段
  chars@data/result        # 提取 data.result 字段
)
</code></pre>
<hr>
<h3 id="json-子字段"><a class="header" href="#json-子字段">JSON 子字段</a></h3>
<p><strong>基本语法：</strong></p>
<pre><code class="language-wpl">json(type@key, type@key, ...)
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl"># 提取指定字段
json(chars@name, digit@age)

# 嵌套路径
json(chars@user/name, digit@user/age)

# 可选字段
json(chars@name, opt(chars)@email)
</code></pre>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"user":{"name":"Alice","age":25},"status":"active"}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>user/name: Alice
user/age: 25
status: active
</code></pre>
<hr>
<h3 id="kv-子字段"><a class="header" href="#kv-子字段">KV 子字段</a></h3>
<p><strong>基本语法：</strong></p>
<pre><code class="language-wpl">kvarr(type@key, type@key, ...)
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">kvarr(chars@hostname, digit@port, opt(chars)@user)
</code></pre>
<p><strong>输入：</strong></p>
<pre><code>hostname=server1 port=3306 user=root
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>hostname: server1
port: 3306
user: root
</code></pre>
<hr>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<p><strong>基本语法：</strong></p>
<pre><code class="language-wpl">array[/subtype]
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">array/digit:nums          # [1,2,3] → nums/[0]=1, nums/[1]=2, nums/[2]=3
array/chars:items         # ["a","b"] → items/[0]="a", items/[1]="b"
array/array/digit         # [[1,2],[3,4]] → 嵌套数组
</code></pre>
<hr>
<h2 id="分隔符优先级"><a class="header" href="#分隔符优先级">分隔符优先级</a></h2>
<h3 id="为什么需要优先级"><a class="header" href="#为什么需要优先级">为什么需要优先级？</a></h3>
<p><strong>问题：</strong> 不同来源的分隔符可能冲突</p>
<pre><code class="language-wpl"># 字段级分隔符
digit\,

# 组级分隔符
(digit, ip)\;

# 上游分隔符（来自 json/kvarr 等）
</code></pre>
<p><strong>解决方案：</strong> 定义优先级规则</p>
<hr>
<h3 id="优先级规则"><a class="header" href="#优先级规则">优先级规则</a></h3>
<pre><code>字段级(3) &gt; 组级(2) &gt; 上游(1)
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl"># 字段级覆盖组级
(digit\;, ip, chars)\,
# digit 用分号，ip 和 chars 用逗号

# 组级覆盖上游
json(...) (digit, ip)\;
# 即使 json 内部默认空格，组级分号生效
</code></pre>
<hr>
<h3 id="分隔符类型"><a class="header" href="#分隔符类型">分隔符类型</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>分隔符</th><th>写法</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>逗号</td><td><code>\,</code></td><td>最常用</td></tr>
<tr><td>分号</td><td><code>\;</code></td><td>常用于 KV</td></tr>
<tr><td>空格</td><td><code>\s</code></td><td>默认</td></tr>
<tr><td>冒号</td><td><code>\:</code></td><td>键值分隔</td></tr>
<tr><td>行尾</td><td><code>\0</code></td><td>读到行尾</td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="实际应用"><a class="header" href="#实际应用">实际应用</a></h3>
<p><strong>场景 1：不同字段不同分隔符</strong></p>
<pre><code class="language-wpl">(digit\;, ip\,, chars\s)
# digit 用分号，ip 用逗号，chars 用空格
</code></pre>
<p><strong>场景 2：组级统一分隔符</strong></p>
<pre><code class="language-wpl">(digit, ip, time)\,
# 所有字段都用逗号
</code></pre>
<p><strong>场景 3：最后一个字段读到行尾</strong></p>
<pre><code class="language-wpl">(digit, ip, chars\0)
# chars 读取所有剩余内容
</code></pre>
<hr>
<h2 id="设计原则总结"><a class="header" href="#设计原则总结">设计原则总结</a></h2>
<h3 id="1-声明式优于命令式"><a class="header" href="#1-声明式优于命令式">1. 声明式优于命令式</a></h3>
<pre><code class="language-wpl"># WPL（声明式）
(ip, digit, time)

# 命令式伪代码
ip = parse_ip(input)
digit = parse_digit(input)
time = parse_time(input)
</code></pre>
<hr>
<h3 id="2-类型安全优于字符串匹配"><a class="header" href="#2-类型安全优于字符串匹配">2. 类型安全优于字符串匹配</a></h3>
<pre><code class="language-wpl"># 带类型验证
ip:client_ip              # 自动验证 IP 格式

# 纯字符串
chars:client_ip           # 不验证格式
</code></pre>
<hr>
<h3 id="3-组合优于重复"><a class="header" href="#3-组合优于重复">3. 组合优于重复</a></h3>
<pre><code class="language-wpl"># 可组合
rule base_fields { (ip, time) }
rule extended { (ip, time, json) }   # 复用基础部分

# 不可组合
rule log1 { (ip, time, chars) }
rule log2 { (ip, time, json) }       # 重复 ip, time
</code></pre>
<hr>
<h3 id="4-明确优于隐含"><a class="header" href="#4-明确优于隐含">4. 明确优于隐含</a></h3>
<pre><code class="language-wpl"># 明确指定
time/clf&lt;[,]&gt;:access_time

# 隐含（可能失败）
time:access_time
</code></pre>
<hr>
<h2 id="常见误解"><a class="header" href="#常见误解">常见误解</a></h2>
<h3 id="误解-1wpl-是正则表达式"><a class="header" href="#误解-1wpl-是正则表达式">误解 1：WPL 是正则表达式</a></h3>
<p><strong>错误认知：</strong> WPL 和正则表达式类似</p>
<p><strong>正确理解：</strong> WPL 是类型化的模式匹配语言</p>
<ul>
<li>正则：字符级匹配</li>
<li>WPL：类型级匹配 + 验证 + 转换</li>
</ul>
<hr>
<h3 id="误解-2所有字段必须连续"><a class="header" href="#误解-2所有字段必须连续">误解 2：所有字段必须连续</a></h3>
<p><strong>错误认知：</strong> 字段之间不能有空隙</p>
<p><strong>正确理解：</strong> 使用 <code>_</code> 跳过不需要的字段</p>
<pre><code class="language-wpl">(ip, 3*_, time)           # 跳过 3 个字段
</code></pre>
<hr>
<h3 id="误解-3只能解析固定格式"><a class="header" href="#误解-3只能解析固定格式">误解 3：只能解析固定格式</a></h3>
<p><strong>错误认知：</strong> WPL 只能解析固定格式的数据</p>
<p><strong>正确理解：</strong> 支持可选、重复、择一等灵活模式</p>
<pre><code class="language-wpl">opt(chars)                # 可选
kvarr                     # 自动解析KV
alt(ip, digit)            # 择一
</code></pre>
<hr>
<h2 id="下一步-2"><a class="header" href="#下一步-2">下一步</a></h2>
<h3 id="实战应用"><a class="header" href="#实战应用">实战应用</a></h3>
<p>→ <a href="#wpl-实战指南">03-practical-guide.md</a> - 按任务查找解决方案</p>
<p><strong>你将学到：</strong></p>
<ul>
<li>解析各种 Web 服务器日志</li>
<li>处理 JSON 和 KV 数据</li>
<li>使用预处理管道</li>
<li>字段验证与过滤</li>
<li>复杂场景处理</li>
</ul>
<hr>
<h3 id="深入参考"><a class="header" href="#深入参考">深入参考</a></h3>
<p>→ <a href="#wpl-语言参考">04-language-reference.md</a> - 完整类型和语法
→ <a href="#wpl-函数参考">05-functions-reference.md</a> - 所有函数详解</p>
<hr>
<h2 id="相关资源-1"><a class="header" href="#相关资源-1">相关资源</a></h2>
<ul>
<li>快速入门：<a href="#wpl-快速入门">01-quickstart.md</a></li>
<li>实战指南：<a href="#wpl-实战指南">03-practical-guide.md</a></li>
<li>语言参考：<a href="#wpl-语言参考">04-language-reference.md</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-实战指南"><a class="header" href="#wpl-实战指南">WPL 实战指南</a></h1>
<p>本文档采用任务导向的方式，帮助你快速找到解决方案。</p>
<hr>
<h2 id="-任务导航"><a class="header" href="#-任务导航">📚 任务导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>任务类型</th><th>跳转</th></tr>
</thead>
<tbody>
<tr><td><a href="#1-解析-web-服务器日志">解析 Web 服务器日志</a></td><td>Nginx/Apache 访问日志、错误日志</td></tr>
<tr><td><a href="#2-解析-json-数据">解析 JSON 数据</a></td><td>提取 JSON 字段、嵌套 JSON</td></tr>
<tr><td><a href="#3-解析-kv-键值对">解析 KV 键值对</a></td><td>基础 KV、嵌套 KV、混合格式</td></tr>
<tr><td><a href="#4-处理编码数据">处理编码数据</a></td><td>Base64、Hex 解码</td></tr>
<tr><td><a href="#5-字段验证与过滤">字段验证与过滤</a></td><td>检查字段、IP 范围、端口范围</td></tr>
<tr><td><a href="#6-复杂场景">复杂场景</a></td><td>可变字段、多格式、嵌套结构</td></tr>
<tr><td><a href="#7-常见问题">常见问题</a></td><td>调试技巧、性能优化</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-快速参考"><a class="header" href="#-快速参考">📋 快速参考</a></h2>
<h3 id="常用模式速查"><a class="header" href="#常用模式速查">常用模式速查</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>模式</th><th>语法</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><strong>可选字段</strong></td><td><code>opt(type:name)</code></td><td>字段可能不存在</td></tr>
<tr><td><strong>重复字段</strong></td><td><code>some_of(type:name)</code></td><td>匹配 1 到多个</td></tr>
<tr><td><strong>跳过字段</strong></td><td><code>_</code> 或 <code>n*_</code></td><td>跳过 1 个或 n 个字段</td></tr>
<tr><td><strong>JSON 提取</strong></td><td><code>json(type@path:name)</code></td><td>提取 JSON 字段</td></tr>
<tr><td><strong>KV 提取</strong></td><td><code>kvarr</code></td><td>解析键值对</td></tr>
<tr><td><strong>Base64 解码</strong></td><td><code>|decode/base64|</code></td><td>预处理管道</td></tr>
<tr><td><strong>字段验证</strong></td><td><code>type/check</code></td><td>验证字段值</td></tr>
<tr><td><strong>择一匹配</strong></td><td><code>one_of(...)</code></td><td>多个模式选一个</td></tr>
</tbody>
</table>
</div>
<h3 id="常用类型速查"><a class="header" href="#常用类型速查">常用类型速查</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类型</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><code>ip</code></td><td>IP 地址</td><td><code>192.168.1.1</code></td></tr>
<tr><td><code>digit</code></td><td>整数</td><td><code>8080</code></td></tr>
<tr><td><code>chars</code></td><td>字符串</td><td><code>hello</code></td></tr>
<tr><td><code>time/clf</code></td><td>Apache 时间格式</td><td><code>[06/Aug/2019:12:12:19 +0800]</code></td></tr>
<tr><td><code>http/request</code></td><td>HTTP 请求</td><td><code>GET /index.html HTTP/1.1</code></td></tr>
<tr><td><code>json</code></td><td>JSON 数据</td><td><code>{"key":"value"}</code></td></tr>
<tr><td><code>kvarr</code></td><td>键值对数组</td><td><code>key1=val1;key2=val2</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-如何使用本指南"><a class="header" href="#-如何使用本指南">📖 如何使用本指南</a></h2>
<p>根据你的任务，找到对应章节，复制规则并根据实际情况调整。</p>
<hr>
<h2 id="1-解析-web-服务器日志"><a class="header" href="#1-解析-web-服务器日志">1. 解析 Web 服务器日志</a></h2>
<h3 id="任务-11解析-nginxapache-访问日志"><a class="header" href="#任务-11解析-nginxapache-访问日志">任务 1.1：解析 Nginx/Apache 访问日志</a></h3>
<p><strong>场景：</strong> 标准 Nginx/Apache 访问日志</p>
<p><strong>输入：</strong></p>
<pre><code>192.168.1.2 - - [06/Aug/2019:12:12:19 +0800] "GET /index.html HTTP/1.1" 200 1024 "http://example.com/" "Mozilla/5.0"
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package nginx {
  rule access_log {
    (
      ip:client_ip,
      2*_,
      time/clf&lt;[,]&gt;:time,
      http/request":request,
      http/status:status,
      digit:bytes,
      chars":referer,
      http/agent":user_agent
    )
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>client_ip: 192.168.1.2
time: 2019-08-06 12:12:19
request: GET /index.html HTTP/1.1
status: 200
bytes: 1024
referer: http://example.com/
user_agent: Mozilla/5.0
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>2*_</code> 忽略两个 <code>-</code> 字段</li>
<li><code>time/clf&lt;[,]&gt;</code> 解析方括号包裹的 CLF 时间</li>
<li><code>http/request"</code> 自动解析引号包裹的 HTTP 请求并提取方法、路径、协议</li>
<li><code>chars"</code> 提取引号包裹的字符串</li>
</ul>
<hr>
<h3 id="任务-12解析带变量的-nginx-日志"><a class="header" href="#任务-12解析带变量的-nginx-日志">任务 1.2：解析带变量的 Nginx 日志</a></h3>
<p><strong>场景：</strong> 自定义 Nginx log_format</p>
<p><strong>输入：</strong></p>
<pre><code>2023-01-01T12:00:00+08:00|INFO|192.168.1.1|GET|/api/users|200|0.123
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package nginx {
  rule custom_log {
    (
      time_3339:timestamp,
      chars:level,
      ip:client_ip,
      http/method:method,
      chars:path,
      http/status:status,
      float:response_time
    )\|
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>timestamp: 2023-01-01 12:00:00
level: INFO
client_ip: 192.168.1.1
method: GET
path: /api/users
status: 200
response_time: 0.123
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>)\|</code> 指定组级分隔符为管道符 <code>|</code></li>
<li><code>time_3339</code> 解析 RFC 3339 时间格式</li>
<li><code>http/method</code> 专门解析 HTTP 方法</li>
<li><code>float</code> 解析浮点数（响应时间）</li>
</ul>
<hr>
<h3 id="任务-13解析带-referer-为空的日志"><a class="header" href="#任务-13解析带-referer-为空的日志">任务 1.3：解析带 referer 为空的日志</a></h3>
<p><strong>场景：</strong> referer 可能为 <code>-</code> 或空</p>
<p><strong>输入：</strong></p>
<pre><code>192.168.1.1 [06/Aug/2019:12:12:19 +0800] "GET /index.html" 200 1024 "-"
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package nginx {
  rule access_log_optional {
    (
      ip:client_ip,
      time/clf&lt;[,]&gt;:time,
      http/request":request,
      http/status:status,
      digit:bytes,
      opt(chars"):referer
    )
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>client_ip: 192.168.1.1
time: 2019-08-06 12:12:19
request: GET /index.html
status: 200
bytes: 1024
referer: -
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>opt(chars")</code> 将 referer 标记为可选字段</li>
<li>即使 referer 解析失败，其他字段仍能正常提取</li>
</ul>
<hr>
<h2 id="2-解析-json-数据"><a class="header" href="#2-解析-json-数据">2. 解析 JSON 数据</a></h2>
<h3 id="任务-21提取-json-字段"><a class="header" href="#任务-21提取-json-字段">任务 2.1：提取 JSON 字段</a></h3>
<p><strong>场景：</strong> API 响应日志</p>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"user":"admin","code":200,"message":"success","timestamp":"2023-01-01T12:00:00"}
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package api {
  rule response {
    (json(
      chars@user,
      digit@code,
      chars@message,
      time_3339@timestamp
    ))
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>user: admin
code: 200
message: success
timestamp: 2023-01-01 12:00:00
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>json(type@key)</code> 语法提取指定键的值</li>
<li>类型自动验证和转换（<code>time_3339</code> 转换时间格式）</li>
</ul>
<hr>
<h3 id="任务-22处理嵌套-json"><a class="header" href="#任务-22处理嵌套-json">任务 2.2：处理嵌套 JSON</a></h3>
<p><strong>场景：</strong> 嵌套的 JSON 结构</p>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"user":{"name":"Alice","age":25,"profile":{"city":"Beijing"}},"status":"active"}
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package api {
  rule nested_json {
    (json(
      chars@user/name,
      digit@user/age,
      chars@user/profile/city,
      chars@status
    ))
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>user/name: Alice
user/age: 25
user/profile/city: Beijing
status: active
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li>使用 <code>/</code> 分隔嵌套路径：<code>@user/name</code>, <code>@user/profile/city</code></li>
<li>路径层级无限制</li>
</ul>
<hr>
<h3 id="任务-23json-反转义"><a class="header" href="#任务-23json-反转义">任务 2.3：JSON 反转义</a></h3>
<p><strong>场景：</strong> JSON 字符串包含转义字符</p>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"path":"c:\\users\\admin\\file.txt","message":"line1\nline2"}
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package api {
  rule json_unescape {
    (json(chars@path, chars@message) |json_unescape())
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>path: c:\users\admin\file.txt
message: line1
line2
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>|json_unescape()</code> 将 <code>\\n</code> 转换为实际换行符</li>
<li><code>\\\\</code> 转换为 <code>\</code></li>
<li><code>\\\"</code> 转换为 <code>"</code></li>
</ul>
<hr>
<h3 id="任务-24可选-json-字段"><a class="header" href="#任务-24可选-json-字段">任务 2.4：可选 JSON 字段</a></h3>
<p><strong>场景：</strong> 某些字段可能不存在</p>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"user":"admin","code":200}
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package api {
  rule optional_fields {
    (json(
      chars@user,
      digit@code,
      opt(chars)@message,
      opt(chars)@data
    ))
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>user: admin
code: 200
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>opt(type)@key</code> 标记字段为可选</li>
<li>不存在的字段不会导致解析失败</li>
</ul>
<hr>
<h2 id="3-解析-kv-键值对"><a class="header" href="#3-解析-kv-键值对">3. 解析 KV 键值对</a></h2>
<h3 id="任务-31基础-kv-解析分号分隔"><a class="header" href="#任务-31基础-kv-解析分号分隔">任务 3.1：基础 KV 解析（分号分隔）</a></h3>
<p><strong>场景：</strong> 简单的 KV 格式日志</p>
<p><strong>输入：</strong></p>
<pre><code>host=server1;port=8080;user=admin;status=online
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package config {
  rule kv_semicolon {
    (kvarr)
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>host: server1
port: 8080
user: admin
status: online
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>kvarr</code> 自动解析所有KV对</li>
<li>自动识别分隔符</li>
</ul>
<hr>
<h3 id="任务-32固定数量-kv逗号分隔"><a class="header" href="#任务-32固定数量-kv逗号分隔">任务 3.2：固定数量 KV（逗号分隔）</a></h3>
<p><strong>场景：</strong> 华为防火墙日志（12 个固定 KV）</p>
<p><strong>输入：</strong></p>
<pre><code>k1=v1,k2=v2,k3=v3,k4=v4,k5=v5,k6=v6,k7=v7,k8=v8,k9=v9,k10=v10,k11=v11,k12=v12
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package firewall {
  rule fixed_kv {
    (kvarr)
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>k1: v1
k2: v2
...
k12: v12
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>kvarr</code> 自动解析所有KV对</li>
<li>不需要指定数量</li>
</ul>
<hr>
<h3 id="任务-33提取指定-kv-字段"><a class="header" href="#任务-33提取指定-kv-字段">任务 3.3：提取指定 KV 字段</a></h3>
<p><strong>场景：</strong> 只提取需要的字段</p>
<p><strong>输入：</strong></p>
<pre><code>hostname=server1 port=3306 user=root db=test timeout=30
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package database {
  rule extract_kv {
    (kvarr(
      chars@hostname,
      digit@port,
      chars@user,
      opt(chars)@db
    ))
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>hostname: server1
port: 3306
user: root
db: test
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>kvarr(type@key)</code> 提取指定键的值</li>
<li>未列出的键（如 <code>timeout</code>）被忽略</li>
<li><code>opt(type)@key</code> 标记可选字段</li>
</ul>
<hr>
<h3 id="任务-34混合-kv-格式"><a class="header" href="#任务-34混合-kv-格式">任务 3.4：混合 KV 格式</a></h3>
<p><strong>场景：</strong> 可选 KV + 多个 KV</p>
<p><strong>输入：</strong></p>
<pre><code>1234,2023-01-01T12:00:00,ABC123,LOGIN:host=server;user=admin,port=8080,action=success
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package firewall {
  rule mixed_kv {
    (
      digit:id,
      time:timestamp,
      sn:serial,
      chars:type\:,
      opt(kvarr),
      kvarr
    )
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>id: 1234
timestamp: 2023-01-01 12:00:00
serial: ABC123
type: LOGIN
host: server
user: admin
port: 8080
action: success
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>chars:type\:</code> 冒号作为分隔符</li>
<li><code>opt(kvarr)</code> 可选的KV</li>
<li><code>kvarr</code> 自动解析KV</li>
</ul>
<hr>
<h2 id="4-处理编码数据"><a class="header" href="#4-处理编码数据">4. 处理编码数据</a></h2>
<h3 id="任务-41base64-解码"><a class="header" href="#任务-41base64-解码">任务 4.1：Base64 解码</a></h3>
<p><strong>场景：</strong> 华为防火墙日志（整行 Base64 编码）</p>
<p><strong>输入（Base64）：</strong></p>
<pre><code>MTIzNCwyMDIzLTAxLTAxVDEyOjAwOjAwLEFCQzEyMyxMT0dJTjpob3N0PXNlcnZlcjt1c2VyPWFkbWluLHBvcnQ9ODA4MCxhY3Rpb249c3VjY2Vzcw==
</code></pre>
<p><strong>解码后：</strong></p>
<pre><code>1234,2023-01-01T12:00:00,ABC123,LOGIN:host=server;user=admin,port=8080,action=success
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package firewall {
  rule huawei_log {
    |decode/base64|
    (
      digit:id,
      time:timestamp,
      sn:serial,
      chars:type\:,
      opt(kvarr),
      kvarr
    )
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>id: 1234
timestamp: 2023-01-01 12:00:00
serial: ABC123
type: LOGIN
host: server
user: admin
port: 8080
action: success
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>|decode/base64|</code> 预处理管道，对整行进行 Base64 解码</li>
<li>解码后再进行字段解析</li>
</ul>
<hr>
<h3 id="任务-42十六进制解码"><a class="header" href="#任务-42十六进制解码">任务 4.2：十六进制解码</a></h3>
<p><strong>场景：</strong> 二进制数据的十六进制表示</p>
<p><strong>输入：</strong></p>
<pre><code>48656c6c6f20576f726c64
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package binary {
  rule hex_decode {
    |decode/hex|
    (chars:data)
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>data: Hello World
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>|decode/hex|</code> 将十六进制字符串解码为原始文本</li>
</ul>
<hr>
<h3 id="任务-43组合多步预处理"><a class="header" href="#任务-43组合多步预处理">任务 4.3：组合多步预处理</a></h3>
<p><strong>场景：</strong> Base64 + JSON 反转义</p>
<p><strong>输入（Base64）：</strong></p>
<pre><code>eyJwYXRoIjoiY1xcXFx1c2Vyc1xcXFxmaWxlIiwidGV4dCI6ImxpbmUxXG5saW5lMiJ9
</code></pre>
<p><strong>解码后：</strong></p>
<pre><code class="language-json">{"path":"c:\\users\\file","text":"line1\nline2"}
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package security {
  rule multi_step {
    |decode/base64|unquote/unescape|
    (json(chars@path, chars@text))
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>path: c:\users\file
text: line1
line2
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li>可以链接多个预处理步骤</li>
<li>执行顺序：从左到右</li>
</ul>
<hr>
<h2 id="5-字段验证与过滤"><a class="header" href="#5-字段验证与过滤">5. 字段验证与过滤</a></h2>
<h3 id="任务-51检查字段存在"><a class="header" href="#任务-51检查字段存在">任务 5.1：检查字段存在</a></h3>
<p><strong>场景：</strong> 确保必需字段存在</p>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"status":"ok","message":"success","data":null}
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package api {
  rule check_required {
    (json |f_has(status) |f_has(message))
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>status: ok
message: success
data: null
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>|f_has(field)</code> 检查字段是否存在</li>
<li>字段不存在时解析失败</li>
</ul>
<hr>
<h3 id="任务-52验证状态码"><a class="header" href="#任务-52验证状态码">任务 5.2：验证状态码</a></h3>
<p><strong>场景：</strong> 只处理成功的响应（200/201/204）</p>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"code":200,"status":"success","data":"result"}
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package api {
  rule validate_success {
    (json |f_digit_in(code, [200, 201, 204]))
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>code: 200
status: success
data: result
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>|f_digit_in(field, [list])</code> 验证数字字段值在列表中</li>
<li>不在列表中时解析失败</li>
</ul>
<hr>
<h3 id="任务-53过滤特定方法"><a class="header" href="#任务-53过滤特定方法">任务 5.3：过滤特定方法</a></h3>
<p><strong>场景：</strong> 只处理 GET/POST 请求</p>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"method":"GET","path":"/api/users","status":200}
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package api {
  rule filter_methods {
    (json |f_chars_in(method, [GET, POST]))
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>method: GET
path: /api/users
status: 200
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>|f_chars_in(field, [list])</code> 验证字符串字段值在列表中</li>
</ul>
<hr>
<h3 id="任务-54链式验证"><a class="header" href="#任务-54链式验证">任务 5.4：链式验证</a></h3>
<p><strong>场景：</strong> 多个条件组合</p>
<p><strong>输入：</strong></p>
<pre><code class="language-json">{"user":"admin","age":25,"status":"active"}
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package api {
  rule chain_validation {
    (json(chars@user, digit@age, chars@status)
      |take(user)
      |chars_has(admin)
      |take(age)
      |digit_in([18, 25, 30])
      |take(status)
      |chars_has(active)
    )
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>user: admin
age: 25
status: active
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>take(field)</code> 选择字段为活跃字段</li>
<li>然后对活跃字段进行验证</li>
<li>可以链式调用多个验证</li>
</ul>
<hr>
<h2 id="6-复杂场景"><a class="header" href="#6-复杂场景">6. 复杂场景</a></h2>
<h3 id="任务-61可变数量字段some_of"><a class="header" href="#任务-61可变数量字段some_of">任务 6.1：可变数量字段（some_of）</a></h3>
<p><strong>场景：</strong> 字段数量和顺序不固定</p>
<p><strong>输入：</strong></p>
<pre><code>192.168.1.1 k1=v1 200 k2=v2 300 k3=v3
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package mixed {
  rule variable_fields {
    some_of(ip, kv, digit)
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>ip: 192.168.1.1
k1: v1
digit: 200
k2: v2
digit: 300
k3: v3
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>some_of(...)</code> 循环匹配所有可能的类型</li>
<li>尽可能多地消费字段</li>
</ul>
<hr>
<h3 id="任务-62择一匹配alt"><a class="header" href="#任务-62择一匹配alt">任务 6.2：择一匹配（alt）</a></h3>
<p><strong>场景：</strong> 某个位置可能是不同类型</p>
<p><strong>输入：</strong></p>
<pre><code>user_id:12345 action:login
user_id:admin action:logout
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package auth {
  rule flexible_user_id {
    (
      chars:key1,
      alt(digit, chars):user_id,
      chars:key2,
      chars:action
    )
  }
}
</code></pre>
<p><strong>输出（输入 1）：</strong></p>
<pre><code>key1: user_id
user_id: 12345
key2: action
action: login
</code></pre>
<p><strong>输出（输入 2）：</strong></p>
<pre><code>key1: user_id
user_id: admin
key2: action
action: logout
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>alt(type1, type2)</code> 尝试多种类型</li>
<li>匹配第一个成功的类型</li>
</ul>
<hr>
<h3 id="任务-63读到行尾"><a class="header" href="#任务-63读到行尾">任务 6.3：读到行尾</a></h3>
<p><strong>场景：</strong> 最后一个字段包含所有剩余内容</p>
<p><strong>输入：</strong></p>
<pre><code>2023-01-01 ERROR This is a very long error message with many details
</code></pre>
<p><strong>WPL 规则：</strong></p>
<pre><code class="language-wpl">package log {
  rule read_to_end {
    (
      time:timestamp,
      chars:level,
      chars\0:message
    )
  }
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>timestamp: 2023-01-01
level: ERROR
message: This is a very long error message with many details
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>\0</code> 表示读到行尾</li>
<li>常用于日志的 message 字段</li>
</ul>
<hr>
<h2 id="7-常见问题"><a class="header" href="#7-常见问题">7. 常见问题</a></h2>
<h3 id="q1-如何处理可变数量的字段"><a class="header" href="#q1-如何处理可变数量的字段">Q1: 如何处理可变数量的字段？</a></h3>
<p><strong>答案：</strong> 使用 <code>N*type</code> 或 <code>some_of</code></p>
<pre><code class="language-wpl"># KV 自动解析
kvarr

# 混合类型
some_of(ip, digit, kvarr)
</code></pre>
<hr>
<h3 id="q2-如何忽略某些字段"><a class="header" href="#q2-如何忽略某些字段">Q2: 如何忽略某些字段？</a></h3>
<p><strong>答案：</strong> 使用 <code>_</code> 或 <code>N*_</code></p>
<pre><code class="language-wpl"># 忽略 1 个字段
(ip, _, time)

# 忽略 3 个字段
(ip, 3*_, time)
</code></pre>
<hr>
<h3 id="q3-分隔符不一致怎么办"><a class="header" href="#q3-分隔符不一致怎么办">Q3: 分隔符不一致怎么办？</a></h3>
<p><strong>答案：</strong> 使用字段级分隔符优先级</p>
<pre><code class="language-wpl"># 不同字段不同分隔符
(digit\;, ip\,, chars\s)

# 或使用组级分隔符
(digit, ip, chars)\,
</code></pre>
<hr>
<h3 id="q4-json-字段可能不存在怎么办"><a class="header" href="#q4-json-字段可能不存在怎么办">Q4: JSON 字段可能不存在怎么办？</a></h3>
<p><strong>答案：</strong> 使用 <code>opt(type)@key</code></p>
<pre><code class="language-wpl">json(
  chars@user,
  opt(chars)@email,
  opt(digit)@age
)
</code></pre>
<hr>
<h3 id="q5-如何提取嵌套-json-字段"><a class="header" href="#q5-如何提取嵌套-json-字段">Q5: 如何提取嵌套 JSON 字段？</a></h3>
<p><strong>答案：</strong> 使用路径语法 <code>@path/to/field</code></p>
<pre><code class="language-wpl">json(
  chars@user/name,
  digit@user/age,
  chars@data/result
)
</code></pre>
<hr>
<h3 id="q6-预处理管道失败怎么办"><a class="header" href="#q6-预处理管道失败怎么办">Q6: 预处理管道失败怎么办？</a></h3>
<p><strong>答案：</strong> 检查以下几点</p>
<ol>
<li>管道名称是否正确</li>
<li>是否以 <code>|</code> 结尾</li>
<li>输入数据格式是否正确</li>
</ol>
<pre><code class="language-wpl"># 正确
|decode/base64|

# 错误：缺少结尾 |
|decode/base64
</code></pre>
<hr>
<h3 id="q7-如何调试解析失败的规则"><a class="header" href="#q7-如何调试解析失败的规则">Q7: 如何调试解析失败的规则？</a></h3>
<p><strong>步骤：</strong></p>
<ol>
<li>简化规则，从最简单的字段开始</li>
<li>使用 <code>opt()</code> 标记可疑字段</li>
<li>检查分隔符是否正确</li>
<li>检查格式控制符（引号、括号等）</li>
</ol>
<pre><code class="language-wpl"># 原规则（失败）
(digit, time, chars, json)

# 调试规则
(digit, opt(time), opt(chars), opt(json))
# 逐步确定哪个字段导致失败
</code></pre>
<hr>
<h2 id="下一步-3"><a class="header" href="#下一步-3">下一步</a></h2>
<h3 id="查阅参考-1"><a class="header" href="#查阅参考-1">查阅参考</a></h3>
<p>→ <a href="#wpl-语言参考">04-language-reference.md</a> - 完整类型和语法
→ <a href="#wpl-函数参考">05-functions-reference.md</a> - 所有函数详解</p>
<h3 id="深入理解"><a class="header" href="#深入理解">深入理解</a></h3>
<p>→ <a href="#wpl-核心概念">02-core-concepts.md</a> - 理解 WPL 设计理念</p>
<hr>
<h2 id="相关资源-2"><a class="header" href="#相关资源-2">相关资源</a></h2>
<ul>
<li>快速入门：<a href="#wpl-快速入门">01-quickstart.md</a></li>
<li>核心概念：<a href="#wpl-核心概念">02-core-concepts.md</a></li>
<li>语言参考：<a href="#wpl-语言参考">04-language-reference.md</a></li>
<li>函数参考：<a href="#wpl-函数参考">05-functions-reference.md</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-语言参考"><a class="header" href="#wpl-语言参考">WPL 语言参考</a></h1>
<p>本文档提供 WPL 的完整语言元素参考，用于快速查阅类型、语法和结构。</p>
<hr>
<h2 id="-文档导航-3"><a class="header" href="#-文档导航-3">📑 文档导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>章节</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><a href="#-类型系统">类型系统</a></td><td>所有数据类型速查表</td></tr>
<tr><td><a href="#-语法元素">语法元素</a></td><td>基本结构、字段定义、格式控制</td></tr>
<tr><td><a href="#-子字段语法">子字段语法</a></td><td>JSON、KV、数组子字段</td></tr>
<tr><td><a href="#-注解">注解</a></td><td>tag、copy_raw 注解</td></tr>
<tr><td><a href="#-语法速查">语法速查</a></td><td>常用模式快速参考</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-类型系统"><a class="header" href="#-类型系统">📋 类型系统</a></h2>
<h3 id="基础类型-1"><a class="header" href="#基础类型-1">基础类型</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>类型</th><th>标识符</th><th>样例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>预读符号</td><td><code>peek_symbol(xxx)</code></td><td><code>peek_symbol(GET)</code></td><td>预读但不消费</td></tr>
<tr><td>2</td><td>忽略</td><td><code>_</code></td><td><code>_</code>, <code>2*_</code>, <code>3*_</code></td><td>忽略该字段</td></tr>
<tr><td>3</td><td>符号</td><td><code>symbol(xxx)</code></td><td><code>symbol(HTTP)</code></td><td>精确匹配</td></tr>
<tr><td>4</td><td>布尔</td><td><code>bool</code></td><td><code>true</code>, <code>false</code></td><td>布尔值</td></tr>
<tr><td>5</td><td>字符串</td><td><code>chars</code></td><td><code>"hello"</code></td><td>任意字符串</td></tr>
<tr><td>6</td><td>整数</td><td><code>digit</code></td><td><code>123</code>, <code>8080</code></td><td>整数</td></tr>
<tr><td>7</td><td>浮点</td><td><code>float</code></td><td><code>3.14</code>, <code>0.01</code></td><td>浮点数</td></tr>
<tr><td>8</td><td>序列号</td><td><code>sn</code></td><td><code>ABC123XYZ</code></td><td>自动生成序列号</td></tr>
</tbody>
</table>
</div>
<h3 id="时间类型-1"><a class="header" href="#时间类型-1">时间类型</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>类型</th><th>标识符</th><th>样例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>9</td><td>通用时间</td><td><code>time</code></td><td><code>2023-05-15 07:09:12</code></td><td>自动识别多种格式</td></tr>
<tr><td>10</td><td>ISO 8601</td><td><code>time_iso</code></td><td><code>2023-05-15T07:09:12Z</code></td><td>ISO 8601 标准</td></tr>
<tr><td>11</td><td>RFC 3339</td><td><code>time_3339</code></td><td><code>2022-03-21T12:34:56+00:00</code></td><td>RFC3339 标准</td></tr>
<tr><td>12</td><td>RFC 2822</td><td><code>time_2822</code></td><td><code>Mon, 07 Jul 2025 09:20:32 +0000</code></td><td>邮件时间格式</td></tr>
<tr><td>13</td><td>CLF 时间</td><td><code>time/clf</code></td><td><code>06/Aug/2019:12:12:19 +0800</code></td><td>Apache/Nginx 日志</td></tr>
<tr><td>14</td><td>Unix时间戳</td><td><code>time_timestamp</code></td><td><code>1647849600</code></td><td>Unix 秒级时间戳</td></tr>
</tbody>
</table>
</div>
<h3 id="网络类型-1"><a class="header" href="#网络类型-1">网络类型</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>类型</th><th>标识符</th><th>样例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>15</td><td>IP地址</td><td><code>ip</code></td><td><code>192.168.1.100</code>, <code>::1</code></td><td>IPv4/IPv6 地址</td></tr>
<tr><td>16</td><td>IP网段</td><td><code>ip_net</code></td><td><code>192.168.0.0/24</code></td><td>CIDR 网段</td></tr>
<tr><td>17</td><td>域名</td><td><code>domain</code></td><td><code>example.com</code></td><td>域名</td></tr>
<tr><td>18</td><td>邮箱</td><td><code>email</code></td><td><code>user@example.com</code></td><td>邮箱地址</td></tr>
<tr><td>19</td><td>端口</td><td><code>port</code></td><td><code>8080</code>, <code>443</code></td><td>端口号</td></tr>
<tr><td>20</td><td>URL</td><td><code>url</code></td><td><code>http://example.com/path</code></td><td>完整 URL</td></tr>
</tbody>
</table>
</div>
<h3 id="编码类型-1"><a class="header" href="#编码类型-1">编码类型</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>类型</th><th>标识符</th><th>样例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>21</td><td>十六进制</td><td><code>hex</code></td><td><code>48656c6c6f</code></td><td>十六进制数据</td></tr>
<tr><td>22</td><td>Base64</td><td><code>base64</code></td><td><code>aGVsbG8=</code></td><td>Base64 编码</td></tr>
</tbody>
</table>
</div>
<h3 id="结构化类型-1"><a class="header" href="#结构化类型-1">结构化类型</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>类型</th><th>标识符</th><th>样例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>23</td><td>键值对</td><td><code>kvarr</code></td><td><code>key=value</code></td><td>KV 格式</td></tr>
<tr><td>24</td><td>JSON</td><td><code>json</code></td><td><code>{"k":"v"}</code></td><td>JSON 对象</td></tr>
<tr><td>25</td><td>严格JSON</td><td><code>exact_json</code></td><td><code>{"k":"v"}</code></td><td>严格验证 JSON</td></tr>
<tr><td>26</td><td>对象</td><td><code>obj</code></td><td>嵌套对象</td><td>通用对象</td></tr>
<tr><td>27</td><td>数组</td><td><code>array</code></td><td><code>[1,2,3]</code></td><td>数组</td></tr>
<tr><td>28</td><td>数字数组</td><td><code>array/digit</code></td><td><code>[1,2,3]</code></td><td>数字数组</td></tr>
<tr><td>29</td><td>字符串数组</td><td><code>array/chars</code></td><td><code>["a","b"]</code></td><td>字符串数组</td></tr>
</tbody>
</table>
</div>
<h3 id="协议类型-1"><a class="header" href="#协议类型-1">协议类型</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>类型</th><th>标识符</th><th>样例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>30</td><td>HTTP请求</td><td><code>http/request</code></td><td><code>GET /path HTTP/1.1</code></td><td>HTTP 请求行</td></tr>
<tr><td>31</td><td>HTTP状态</td><td><code>http/status</code></td><td><code>200</code>, <code>404</code></td><td>HTTP 状态码</td></tr>
<tr><td>32</td><td>User-Agent</td><td><code>http/agent</code></td><td><code>Mozilla/5.0...</code></td><td>浏览器 UA</td></tr>
<tr><td>33</td><td>HTTP方法</td><td><code>http/method</code></td><td><code>GET</code>, <code>POST</code></td><td>HTTP 方法</td></tr>
</tbody>
</table>
</div>
<h3 id="特殊类型-1"><a class="header" href="#特殊类型-1">特殊类型</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>类型</th><th>标识符</th><th>样例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>34</td><td>身份证</td><td><code>id_card</code></td><td><code>110101199001011234</code></td><td>18 位身份证</td></tr>
<tr><td>35</td><td>手机号</td><td><code>mobile_phone</code></td><td><code>13800138000</code></td><td>11 位手机号</td></tr>
<tr><td>36</td><td>协议文本</td><td><code>proto_text</code></td><td>协议格式</td><td>协议文本解析</td></tr>
<tr><td>37</td><td>自动识别</td><td><code>auto</code></td><td>自动推断</td><td>自动类型推断</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-语法元素"><a class="header" href="#-语法元素">🔧 语法元素</a></h2>
<h3 id="基本结构"><a class="header" href="#基本结构">基本结构</a></h3>
<pre><code class="language-wpl">package 包名 {
  rule 规则名 {
    |预处理管道|
    (字段列表)
  }
}
</code></pre>
<h3 id="字段定义完整语法"><a class="header" href="#字段定义完整语法">字段定义完整语法</a></h3>
<pre><code>[N*] DataType [ (symbol) ] [ (subfields) ] [:name] [ [len] ] [ format ] [ sep ] { | pipe }
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>部分</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><code>[N*]</code></td><td>重复计数</td><td><code>kvarr</code>, <code>3*ip</code></td></tr>
<tr><td><code>DataType</code></td><td>数据类型</td><td><code>digit</code>, <code>ip</code>, <code>json</code></td></tr>
<tr><td><code>(symbol)</code></td><td>符号内容</td><td><code>symbol(GET)</code></td></tr>
<tr><td><code>(subfields)</code></td><td>子字段列表</td><td><code>json(chars@name)</code></td></tr>
<tr><td><code>:name</code></td><td>字段命名</td><td><code>:status</code>, <code>:client_ip</code></td></tr>
<tr><td><code>[len]</code></td><td>长度限制</td><td><code>[100]</code></td></tr>
<tr><td><code>format</code></td><td>格式控制</td><td><code>&lt;[,]&gt;</code>, <code>"</code>, <code>^10</code></td></tr>
<tr><td><code>sep</code></td><td>分隔符</td><td><code>\,</code>, <code>\;</code>, <code>\0</code></td></tr>
<tr><td><code>| pipe</code></td><td>管道函数</td><td><code>|f_has(name)|</code></td></tr>
</tbody>
</table>
</div>
<h3 id="格式控制-1"><a class="header" href="#格式控制-1">格式控制</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>格式</th><th>语法</th><th>示例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>范围定界</td><td><code>&lt;beg,end&gt;</code></td><td><code>&lt;[,]&gt;</code>, <code>&lt;{,}&gt;</code></td><td>起止符号</td></tr>
<tr><td>引号</td><td><code>"</code></td><td><code>chars"</code></td><td>引号包裹</td></tr>
<tr><td>字符计数</td><td><code>N*</code></td><td><code>10*chars</code>, <code>5*_</code></td><td>按字符数</td></tr>
</tbody>
</table>
</div>
<h3 id="分组元信息"><a class="header" href="#分组元信息">分组元信息</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>元信息</th><th>说明</th><th>示例</th><th>匹配行为</th></tr>
</thead>
<tbody>
<tr><td><code>seq</code></td><td>顺序匹配（默认）</td><td><code>seq(ip, digit, time)</code></td><td>按顺序依次匹配</td></tr>
<tr><td><code>alt</code></td><td>择一匹配</td><td><code>alt(ip, digit)</code></td><td>匹配其中一个</td></tr>
<tr><td><code>opt</code></td><td>可选匹配</td><td><code>opt(chars)</code></td><td>失败不报错</td></tr>
<tr><td><code>some_of</code></td><td>尽可能多</td><td><code>some_of(ip, digit)</code></td><td>循环匹配</td></tr>
</tbody>
</table>
</div>
<h3 id="分隔符优先级-1"><a class="header" href="#分隔符优先级-1">分隔符优先级</a></h3>
<pre><code>字段级(3) &gt; 组级(2) &gt; 上游(1)
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>分隔符</th><th>写法</th><th>说明</th><th>优先级</th></tr>
</thead>
<tbody>
<tr><td>逗号</td><td><code>\,</code></td><td>逗号分隔</td><td>字段级 (3)</td></tr>
<tr><td>分号</td><td><code>\;</code></td><td>分号分隔</td><td>字段级 (3)</td></tr>
<tr><td>冒号</td><td><code>\:</code></td><td>冒号分隔</td><td>字段级 (3)</td></tr>
<tr><td>空格</td><td><code>\s</code></td><td>空格分隔</td><td>字段级 (3)</td></tr>
<tr><td>行尾</td><td><code>\0</code></td><td>读到行尾</td><td>字段级 (3)</td></tr>
<tr><td>组分隔</td><td><code>(...)\sep</code></td><td>组级分隔</td><td>组级 (2)</td></tr>
<tr><td>默认</td><td>无</td><td>继承上游</td><td>上游 (1)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-子字段语法"><a class="header" href="#-子字段语法">🎯 子字段语法</a></h2>
<h3 id="json-子字段-1"><a class="header" href="#json-子字段-1">JSON 子字段</a></h3>
<pre><code class="language-wpl">json(type@key, type@key, ...)
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl"># 基本提取
json(chars@name, digit@age)

# 嵌套路径
json(chars@user/name, digit@user/age)

# 可选字段
json(chars@name, opt(chars)@email)
</code></pre>
<h3 id="kv-子字段-1"><a class="header" href="#kv-子字段-1">KV 子字段</a></h3>
<pre><code class="language-wpl">kvarr(type@key, type@key, ...)
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">kvarr(chars@hostname, digit@port, opt(chars)@user)
</code></pre>
<h3 id="数组-1"><a class="header" href="#数组-1">数组</a></h3>
<pre><code class="language-wpl">array[/subtype]
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">array/digit:nums          # [1,2,3]
array/chars:items         # ["a","b"]
array/array/digit         # 嵌套数组
</code></pre>
<hr>
<h2 id="-注解"><a class="header" href="#-注解">📝 注解</a></h2>
<h3 id="tag-注解"><a class="header" href="#tag-注解">tag 注解</a></h3>
<pre><code class="language-wpl">#[tag(key1:"value1", key2:"value2")]
package demo {
  rule x { (digit, time) }
}
</code></pre>
<h3 id="copy_raw-注解"><a class="header" href="#copy_raw-注解">copy_raw 注解</a></h3>
<pre><code class="language-wpl">#[copy_raw(name:"raw_log")]
rule nginx_log {
  (ip, time, chars)
}
</code></pre>
<h3 id="原始字符串避免转义"><a class="header" href="#原始字符串避免转义">原始字符串（避免转义）</a></h3>
<pre><code class="language-wpl">#[tag(path:r#"C:\Program Files\App"#)]
package demo {
  rule x { (digit) }
}
</code></pre>
<hr>
<h2 id="-语法速查"><a class="header" href="#-语法速查">💡 语法速查</a></h2>
<h3 id="常用模式"><a class="header" href="#常用模式">常用模式</a></h3>
<pre><code class="language-wpl"># 字段命名
type:name              # digit:status

# 忽略字段
_                      # 忽略 1 个
N*_                    # 忽略 N 个

# 重复模式
kvarr                  # 自动解析KV
N*ip                   # 固定 N 次

# 可选字段
opt(chars)             # 单个可选
opt(kvarr)             # 可选 KV

# 格式控制
&lt;[,]&gt;                  # 方括号包裹
"                      # 引号包裹
^10                    # 固定 10 字符

# 分隔符
\,                     # 逗号
\;                     # 分号
\0                     # 行尾

# 子字段
json(chars@key)        # JSON 字段
kvarr(digit@port)      # KV 字段
@path/to/field         # 嵌套路径
</code></pre>
<hr>
<h2 id="相关文档-1"><a class="header" href="#相关文档-1">相关文档</a></h2>
<ul>
<li>快速入门：<a href="#wpl-快速入门">01-quickstart.md</a></li>
<li>核心概念：<a href="#wpl-核心概念">02-core-concepts.md</a></li>
<li>实战指南：<a href="#wpl-实战指南">03-practical-guide.md</a></li>
<li>函数参考：<a href="#wpl-函数参考">05-functions-reference.md</a></li>
<li>语法规范：<a href="#wpl-语法参考ebnf">06-grammar-reference.md</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-函数参考"><a class="header" href="#wpl-函数参考">WPL 函数参考</a></h1>
<p>本文档提供所有 WPL 函数的标准化参考。</p>
<hr>
<h2 id="-wpl-所有函数速查"><a class="header" href="#-wpl-所有函数速查">📋 WPL 所有函数速查</a></h2>
<h3 id="预处理管道函数"><a class="header" href="#预处理管道函数">预处理管道函数</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><a href="#decodebase64"><code>decode/base64</code></a></td><td>对整行 Base64 解码</td><td><code>|decode/base64|</code></td></tr>
<tr><td><a href="#decodehex"><code>decode/hex</code></a></td><td>对整行十六进制解码</td><td><code>|decode/hex|</code></td></tr>
<tr><td><a href="#unquoteunescape"><code>unquote/unescape</code></a></td><td>移除引号并还原转义</td><td><code>|unquote/unescape|</code></td></tr>
<tr><td><a href="#plg_pipename"><code>plg_pipe/&lt;name&gt;</code></a></td><td>自定义预处理扩展</td><td><code>|plg_pipe/dayu|</code></td></tr>
</tbody>
</table>
</div>
<h3 id="选择器函数"><a class="header" href="#选择器函数">选择器函数</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><a href="#take"><code>take(name)</code></a></td><td>选择指定字段为活跃字段</td><td><code>|take(name)|</code></td></tr>
<tr><td><a href="#last"><code>last()</code></a></td><td>选择最后一个字段为活跃字段</td><td><code>|last()|</code></td></tr>
</tbody>
</table>
</div>
<h3 id="字段集操作函数f_-前缀"><a class="header" href="#字段集操作函数f_-前缀">字段集操作函数（f_ 前缀）</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><a href="#f_has"><code>f_has(name)</code></a></td><td>检查字段是否存在</td><td><code>|f_has(status)|</code></td></tr>
<tr><td><a href="#f_chars_has"><code>f_chars_has(name, val)</code></a></td><td>检查字段值等于字符串</td><td><code>|f_chars_has(status, success)|</code></td></tr>
<tr><td><a href="#f_chars_not_has"><code>f_chars_not_has(name, val)</code></a></td><td>检查字段值不等于字符串</td><td><code>|f_chars_not_has(level, error)|</code></td></tr>
<tr><td><a href="#f_chars_in"><code>f_chars_in(name, [...])</code></a></td><td>检查字段值在字符串列表</td><td><code>|f_chars_in(method, [GET, POST])|</code></td></tr>
<tr><td><a href="#f_digit_has"><code>f_digit_has(name, num)</code></a></td><td>检查字段值等于数字</td><td><code>|f_digit_has(code, 200)|</code></td></tr>
<tr><td><a href="#f_digit_in"><code>f_digit_in(name, [...])</code></a></td><td>检查字段值在数字列表</td><td><code>|f_digit_in(status, [200, 201])|</code></td></tr>
<tr><td><a href="#f_ip_in"><code>f_ip_in(name, [...])</code></a></td><td>检查 IP 在列表</td><td><code>|f_ip_in(client_ip, [127.0.0.1])|</code></td></tr>
</tbody>
</table>
</div>
<h3 id="活跃字段操作函数"><a class="header" href="#活跃字段操作函数">活跃字段操作函数</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><a href="#has"><code>has()</code></a></td><td>检查活跃字段存在</td><td><code>|take(name)| has()|</code></td></tr>
<tr><td><a href="#chars_has"><code>chars_has(val)</code></a></td><td>检查活跃字段等于字符串</td><td><code>|take(status)| chars_has(success)|</code></td></tr>
<tr><td><a href="#chars_not_has"><code>chars_not_has(val)</code></a></td><td>检查活跃字段不等于字符串</td><td><code>|take(level)| chars_not_has(error)|</code></td></tr>
<tr><td><a href="#chars_in"><code>chars_in([...])</code></a></td><td>检查活跃字段在字符串列表</td><td><code>|take(method)| chars_in([GET, POST])|</code></td></tr>
<tr><td><a href="#digit_has"><code>digit_has(num)</code></a></td><td>检查活跃字段等于数字</td><td><code>|take(code)| digit_has(200)|</code></td></tr>
<tr><td><a href="#digit_in"><code>digit_in([...])</code></a></td><td>检查活跃字段在数字列表</td><td><code>|take(status)| digit_in([200, 201])|</code></td></tr>
<tr><td><a href="#ip_in"><code>ip_in([...])</code></a></td><td>检查活跃 IP 在列表</td><td><code>|take(client_ip)| ip_in([127.0.0.1])|</code></td></tr>
</tbody>
</table>
</div>
<h3 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><a href="#json_unescape"><code>json_unescape()</code></a></td><td>JSON 反转义</td><td><code>|take(message)| json_unescape()|</code></td></tr>
<tr><td><a href="#base64_decode"><code>base64_decode()</code></a></td><td>Base64 解码</td><td><code>|take(payload)| base64_decode()|</code></td></tr>
</tbody>
</table>
</div>
<h3 id="常用场景速查"><a class="header" href="#常用场景速查">常用场景速查</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>我想做什么</th><th>使用方法</th></tr>
</thead>
<tbody>
<tr><td><strong>对整行 Base64 解码</strong></td><td><code>|decode/base64|</code></td></tr>
<tr><td><strong>对整行十六进制解码</strong></td><td><code>|decode/hex|</code></td></tr>
<tr><td><strong>移除引号和转义</strong></td><td><code>|unquote/unescape|</code></td></tr>
<tr><td><strong>检查字段是否存在</strong></td><td><code>|f_has(field_name)|</code></td></tr>
<tr><td><strong>检查字段值等于某字符串</strong></td><td><code>|f_chars_has(status, success)|</code></td></tr>
<tr><td><strong>检查字段值在列表中</strong></td><td><code>|f_chars_in(method, [GET, POST])|</code></td></tr>
<tr><td><strong>检查状态码是否为 200</strong></td><td><code>|f_digit_has(code, 200)|</code></td></tr>
<tr><td><strong>检查 IP 是否在白名单</strong></td><td><code>|f_ip_in(client_ip, [127.0.0.1, 192.168.1.1])|</code></td></tr>
<tr><td><strong>选择特定字段验证</strong></td><td><code>|take(status)| chars_has(ok)|</code></td></tr>
<tr><td><strong>对字段 JSON 反转义</strong></td><td><code>|take(message)| json_unescape()|</code></td></tr>
<tr><td><strong>对字段 Base64 解码</strong></td><td><code>|take(payload)| base64_decode()|</code></td></tr>
<tr><td><strong>链式验证多个条件</strong></td><td><code>|f_has(method)| f_chars_in(method, [GET, POST])|</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="预处理管道函数-1"><a class="header" href="#预处理管道函数-1">预处理管道函数</a></h2>
<h3 id="decodebase64"><a class="header" href="#decodebase64">decode/base64</a></h3>
<p><strong>说明：</strong> 对整行输入进行 Base64 解码</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|decode/base64|
</code></pre>
<p><strong>参数：</strong> 无</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule base64_log {
  |decode/base64|
  (json(chars@user, digit@code))
}
</code></pre>
<p><strong>输入（Base64）：</strong></p>
<pre><code>eyJ1c2VyIjoiYWRtaW4iLCJjb2RlIjoyMDB9
</code></pre>
<p><strong>解码后：</strong></p>
<pre><code class="language-json">{"user":"admin","code":200}
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>作用于整行原始输入</li>
<li>必须在字段解析前执行</li>
<li>解码失败会报错</li>
</ul>
<hr>
<h3 id="decodehex"><a class="header" href="#decodehex">decode/hex</a></h3>
<p><strong>说明：</strong> 对整行输入进行十六进制解码</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|decode/hex|
</code></pre>
<p><strong>参数：</strong> 无</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule hex_log {
  |decode/hex|
  (chars:data)
}
</code></pre>
<p><strong>输入：</strong></p>
<pre><code>48656c6c6f20576f726c64
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>data: Hello World
</code></pre>
<hr>
<h3 id="unquoteunescape"><a class="header" href="#unquoteunescape">unquote/unescape</a></h3>
<p><strong>说明：</strong> 移除外层引号并还原反斜杠转义</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|unquote/unescape|
</code></pre>
<p><strong>参数：</strong> 无</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule unescape_log {
  |unquote/unescape|
  (chars:message)
}
</code></pre>
<p><strong>转换效果：</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>输入</th><th>输出</th></tr>
</thead>
<tbody>
<tr><td><code>\"hello\"</code></td><td><code>hello</code></td></tr>
<tr><td><code>path\\to\\file</code></td><td><code>path\to\file</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="plg_pipe"><a class="header" href="#plg_pipe">plg_pipe/<name></name></a></h3>
<p><strong>说明：</strong> 自定义预处理扩展</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|plg_pipe/&lt;name&gt;|
</code></pre>
<p><strong>参数：</strong> <code>&lt;name&gt;</code> - 注册的扩展名称</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule custom_preproc {
  |plg_pipe/dayu|
  (json(_@_origin, _@payload/packet_data))
}
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>需要通过代码注册扩展</li>
<li>注册接口：<code>wpl::register_wpl_pipe!</code></li>
</ul>
<hr>
<h2 id="选择器函数-1"><a class="header" href="#选择器函数-1">选择器函数</a></h2>
<h3 id="take"><a class="header" href="#take">take</a></h3>
<p><strong>说明：</strong> 选择指定字段为活跃字段</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|take(&lt;field_name&gt;)|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>field_name</code> - 要选择的字段名</li>
</ul>
<p><strong>返回：</strong> 无（改变活跃字段状态）</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule take_example {
  (
    json(chars@name, digit@age)
    |take(name)              # 选择 name 为活跃字段
    |chars_has(admin)        # 验证 name 的值
  )
}
</code></pre>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要对特定字段进行验证</li>
<li>链式验证多个字段</li>
</ul>
<hr>
<h3 id="last"><a class="header" href="#last">last</a></h3>
<p><strong>说明：</strong> 选择最后一个字段为活跃字段</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|last()|
</code></pre>
<p><strong>参数：</strong> 无</p>
<p><strong>返回：</strong> 无（改变活跃字段状态）</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule last_example {
  (
    json(chars@a, chars@b, chars@c)
    |last()                  # 选择 c 为活跃字段
    |chars_has(value)        # 验证 c 的值
  )
}
</code></pre>
<hr>
<h2 id="字段集操作函数"><a class="header" href="#字段集操作函数">字段集操作函数</a></h2>
<h3 id="f_has"><a class="header" href="#f_has">f_has</a></h3>
<p><strong>说明：</strong> 检查指定字段是否存在</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|f_has(&lt;field_name&gt;)|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>field_name</code> - 要检查的字段名</li>
</ul>
<p><strong>返回：</strong> 布尔值（字段存在返回 true，否则失败）</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_field {
  (json |f_has(status) |f_has(message))
}
</code></pre>
<hr>
<h3 id="f_chars_has"><a class="header" href="#f_chars_has">f_chars_has</a></h3>
<p><strong>说明：</strong> 检查指定字段值是否等于字符串</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|f_chars_has(&lt;field_name&gt;, &lt;value&gt;)|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>field_name</code> - 字段名（或 <code>_</code> 表示活跃字段）</li>
<li><code>value</code> - 要匹配的字符串值</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_string {
  (json |f_chars_has(status, success))
}
</code></pre>
<hr>
<h3 id="f_chars_not_has"><a class="header" href="#f_chars_not_has">f_chars_not_has</a></h3>
<p><strong>说明：</strong> 检查指定字段值是否不等于字符串</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|f_chars_not_has(&lt;field_name&gt;, &lt;value&gt;)|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>field_name</code> - 字段名</li>
<li><code>value</code> - 不应匹配的字符串值</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule exclude_error {
  (json |f_chars_not_has(level, error))
}
</code></pre>
<hr>
<h3 id="f_chars_in"><a class="header" href="#f_chars_in">f_chars_in</a></h3>
<p><strong>说明：</strong> 检查指定字段值是否在字符串列表中</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|f_chars_in(&lt;field_name&gt;, [&lt;value1&gt;, &lt;value2&gt;, ...])|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>field_name</code> - 字段名</li>
<li><code>[...]</code> - 允许的字符串值列表</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_method {
  (json |f_chars_in(method, [GET, POST, PUT]))
}
</code></pre>
<hr>
<h3 id="f_digit_has"><a class="header" href="#f_digit_has">f_digit_has</a></h3>
<p><strong>说明：</strong> 检查指定字段数值是否等于指定数字</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|f_digit_has(&lt;field_name&gt;, &lt;number&gt;)|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>field_name</code> - 字段名</li>
<li><code>number</code> - 要匹配的数字</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_status {
  (json |f_digit_has(code, 200))
}
</code></pre>
<hr>
<h3 id="f_digit_in"><a class="header" href="#f_digit_in">f_digit_in</a></h3>
<p><strong>说明：</strong> 检查指定字段数值是否在数字列表中</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|f_digit_in(&lt;field_name&gt;, [&lt;num1&gt;, &lt;num2&gt;, ...])|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>field_name</code> - 字段名</li>
<li><code>[...]</code> - 允许的数字值列表</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_success {
  (json |f_digit_in(status, [200, 201, 204]))
}
</code></pre>
<hr>
<h3 id="f_ip_in"><a class="header" href="#f_ip_in">f_ip_in</a></h3>
<p><strong>说明：</strong> 检查指定 IP 字段是否在 IP 列表中</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|f_ip_in(&lt;field_name&gt;, [&lt;ip1&gt;, &lt;ip2&gt;, ...])|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>field_name</code> - 字段名</li>
<li><code>[...]</code> - 允许的 IP 地址列表（支持 IPv4/IPv6）</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_trusted {
  (json |f_ip_in(client_ip, [127.0.0.1, 192.168.1.1]))
}
</code></pre>
<hr>
<h2 id="活跃字段操作函数-1"><a class="header" href="#活跃字段操作函数-1">活跃字段操作函数</a></h2>
<h3 id="has"><a class="header" href="#has">has</a></h3>
<p><strong>说明：</strong> 检查活跃字段是否存在</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|has()|
</code></pre>
<p><strong>参数：</strong> 无</p>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_active {
  (
    json(chars@name)
    |take(name)
    |has()                   # 检查 name 是否存在
  )
}
</code></pre>
<hr>
<h3 id="chars_has"><a class="header" href="#chars_has">chars_has</a></h3>
<p><strong>说明：</strong> 检查活跃字段值是否等于指定字符串</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|chars_has(&lt;value&gt;)|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>value</code> - 要匹配的字符串值</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_value {
  (
    json(chars@status)
    |take(status)
    |chars_has(success)
  )
}
</code></pre>
<hr>
<h3 id="chars_not_has"><a class="header" href="#chars_not_has">chars_not_has</a></h3>
<p><strong>说明：</strong> 检查活跃字段值是否不等于指定字符串</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|chars_not_has(&lt;value&gt;)|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>value</code> - 不应匹配的字符串值</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule exclude_value {
  (
    json(chars@level)
    |take(level)
    |chars_not_has(error)
  )
}
</code></pre>
<hr>
<h3 id="chars_in"><a class="header" href="#chars_in">chars_in</a></h3>
<p><strong>说明：</strong> 检查活跃字段值是否在字符串列表中</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|chars_in([&lt;value1&gt;, &lt;value2&gt;, ...])|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>[...]</code> - 允许的字符串值列表</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_method {
  (
    json(chars@method)
    |take(method)
    |chars_in([GET, POST, PUT])
  )
}
</code></pre>
<hr>
<h3 id="digit_has"><a class="header" href="#digit_has">digit_has</a></h3>
<p><strong>说明：</strong> 检查活跃字段数值是否等于指定数字</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|digit_has(&lt;number&gt;)|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>number</code> - 要匹配的数字</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_code {
  (
    json(digit@code)
    |take(code)
    |digit_has(200)
  )
}
</code></pre>
<hr>
<h3 id="digit_in"><a class="header" href="#digit_in">digit_in</a></h3>
<p><strong>说明：</strong> 检查活跃字段数值是否在数字列表中</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|digit_in([&lt;num1&gt;, &lt;num2&gt;, ...])|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>[...]</code> - 允许的数字值列表</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_success {
  (
    json(digit@status)
    |take(status)
    |digit_in([200, 201, 204])
  )
}
</code></pre>
<hr>
<h3 id="ip_in"><a class="header" href="#ip_in">ip_in</a></h3>
<p><strong>说明：</strong> 检查活跃 IP 字段是否在 IP 列表中</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|ip_in([&lt;ip1&gt;, &lt;ip2&gt;, ...])|
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><code>[...]</code> - 允许的 IP 地址列表（支持 IPv4/IPv6）</li>
</ul>
<p><strong>返回：</strong> 布尔值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule check_client {
  (
    json(ip@client_ip)
    |take(client_ip)
    |ip_in([127.0.0.1, 192.168.1.1])
  )
}
</code></pre>
<hr>
<h2 id="转换函数-1"><a class="header" href="#转换函数-1">转换函数</a></h2>
<h3 id="json_unescape"><a class="header" href="#json_unescape">json_unescape</a></h3>
<p><strong>说明：</strong> 对活跃字段进行 JSON 反转义</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|json_unescape()|
</code></pre>
<p><strong>参数：</strong> 无</p>
<p><strong>转换效果：</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>输入</th><th>输出</th></tr>
</thead>
<tbody>
<tr><td><code>hello\\nworld</code></td><td><code>hello</code> + 换行 + <code>world</code></td></tr>
<tr><td><code>path\\\\to</code></td><td><code>path\to</code></td></tr>
<tr><td><code>say\\\"hi\\\"</code></td><td><code>say"hi"</code></td></tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule parse_json_log {
  (
    json(chars@message)
    |take(message)
    |json_unescape()
  )
}
</code></pre>
<hr>
<h3 id="base64_decode"><a class="header" href="#base64_decode">base64_decode</a></h3>
<p><strong>说明：</strong> 对活跃字段进行 Base64 解码</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">|base64_decode()|
</code></pre>
<p><strong>参数：</strong> 无</p>
<p><strong>转换效果：</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>输入</th><th>输出</th></tr>
</thead>
<tbody>
<tr><td><code>aGVsbG8=</code></td><td><code>hello</code></td></tr>
<tr><td><code>Zm9vYmFy</code></td><td><code>foobar</code></td></tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">rule decode_payload {
  (
    json(chars@payload)
    |take(payload)
    |base64_decode()
  )
}
</code></pre>
<hr>
<h2 id="-函数对照表"><a class="header" href="#-函数对照表">📊 函数对照表</a></h2>
<h3 id="字段集-vs-活跃字段"><a class="header" href="#字段集-vs-活跃字段">字段集 vs 活跃字段</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>功能</th><th>字段集操作（f_ 前缀）</th><th>活跃字段操作（无前缀）</th></tr>
</thead>
<tbody>
<tr><td>检查存在</td><td><code>f_has(name)</code></td><td><code>take(name) | has()</code></td></tr>
<tr><td>字符串相等</td><td><code>f_chars_has(name, val)</code></td><td><code>take(name) | chars_has(val)</code></td></tr>
<tr><td>字符串不等</td><td><code>f_chars_not_has(name, val)</code></td><td><code>take(name) | chars_not_has(val)</code></td></tr>
<tr><td>字符串在列表</td><td><code>f_chars_in(name, [a, b])</code></td><td><code>take(name) | chars_in([a, b])</code></td></tr>
<tr><td>数字相等</td><td><code>f_digit_has(name, 200)</code></td><td><code>take(name) | digit_has(200)</code></td></tr>
<tr><td>数字在列表</td><td><code>f_digit_in(name, [200, 201])</code></td><td><code>take(name) | digit_in([200, 201])</code></td></tr>
<tr><td>IP 在列表</td><td><code>f_ip_in(name, [1.1.1.1])</code></td><td><code>take(name) | ip_in([1.1.1.1])</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-使用模式"><a class="header" href="#-使用模式">💡 使用模式</a></h2>
<h3 id="链式调用"><a class="header" href="#链式调用">链式调用</a></h3>
<pre><code class="language-wpl">rule chain {
  (json
    |f_has(method)
    |f_chars_in(method, [GET, POST])
    |f_digit_in(status, [200, 201])
    |f_ip_in(client_ip, [10.0.0.1])
  )
}
</code></pre>
<h3 id="选择器--验证"><a class="header" href="#选择器--验证">选择器 + 验证</a></h3>
<pre><code class="language-wpl">rule selector {
  (json(chars@name, digit@age)
    |take(name)
    |chars_has(admin)
    |take(age)
    |digit_in([18, 19, 20])
  )
}
</code></pre>
<h3 id="预处理--字段级管道"><a class="header" href="#预处理--字段级管道">预处理 + 字段级管道</a></h3>
<pre><code class="language-wpl">rule full {
  |decode/base64|                      # 预处理：整行解码
  (json |f_has(name) |f_digit_in(age, [18, 25]))  # 字段级：验证
}
</code></pre>
<hr>
<h2 id="相关文档-2"><a class="header" href="#相关文档-2">相关文档</a></h2>
<ul>
<li>快速入门：<a href="#wpl-快速入门">01-quickstart.md</a></li>
<li>核心概念：<a href="#wpl-核心概念">02-core-concepts.md</a></li>
<li>实战指南：<a href="#wpl-实战指南">03-practical-guide.md</a></li>
<li>语言参考：<a href="#wpl-语言参考">04-language-reference.md</a></li>
<li>语法规范：<a href="#wpl-语法参考ebnf">06-grammar-reference.md</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-语法参考ebnf"><a class="header" href="#wpl-语法参考ebnf">WPL 语法参考（EBNF）</a></h1>
<p>本文档提供 WPL 的形式化语法定义，适合：</p>
<ul>
<li>编译器/解析器开发者</li>
<li>精确理解语法规则</li>
<li>工具集成开发</li>
</ul>
<p><strong>普通用户请参考：</strong></p>
<ul>
<li>快速入门：<a href="#wpl-快速入门">01-quickstart.md</a></li>
<li>核心概念：<a href="#wpl-核心概念">02-core-concepts.md</a></li>
<li>实战指南：<a href="#wpl-实战指南">03-practical-guide.md</a></li>
<li>语言参考：<a href="#wpl-语言参考">04-language-reference.md</a></li>
</ul>
<hr>
<h2 id="-文档导航-4"><a class="header" href="#-文档导航-4">📑 文档导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>章节</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><a href="#完整-ebnf-定义">完整 EBNF 定义</a></td><td>形式化语法定义</td></tr>
<tr><td><a href="#语义说明">语义说明</a></td><td>语法规则的语义解释</td></tr>
<tr><td><a href="#实现参考">实现参考</a></td><td>源代码位置</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="完整-ebnf-定义"><a class="header" href="#完整-ebnf-定义">完整 EBNF 定义</a></h2>
<p>权威实现以 <code>crates/wp-lang</code> 解析器为准；此处与源代码保持同步。</p>
<pre><code class="language-ebnf">; WPL 语法（EBNF）
; 基于 crates/wp-lang 下解析实现（winnow）整理
; 说明：本文件给出语法产生式与必要的词法约定。除显式标注外，token 之间允许可选空白 `ws`。

wpl_document     = { package_decl } ;

package_decl     = [ annotation ] "package" ws? ident ws? "{" ws? rule_decl+ ws? "}" ;

rule_decl        = [ annotation ] "rule" ws? rule_name ws? "{" ws? statement ws? "}" ;

statement        = plg_pipe_block | express ;

plg_pipe_block   = ["@"]? "plg_pipe" ws? "(" ws? "id" ws? ":" ws? key ws? ")" ws? "{" ws? express ws? "}" ;

express          = [ preproc ] group { ws? "," ws? group } ;

preproc          = "|" ws? preproc_step { ws? "|" ws? preproc_step } ws? "|" ;   ; 至少一个步骤，且以 '|' 结尾
preproc_step     = builtin_preproc | plg_pipe_step ;
builtin_preproc  = ns "/" name ;
plg_pipe_step    = "plg_pipe" ws? "/" ws? key ;                   ; 通过注册表查找自定义扩展
ns               = "decode" | "unquote" ;                        ; 命名空间白名单
name             = ("base64" | "hex") | "unescape" ;             ; 步骤名白名单

group            = [ group_meta ] ws? "(" ws? field_list_opt ws? ")" [ ws? group_len ] [ ws? group_sep ] ;
group_meta       = "alt" | "opt" | "some_of" | "seq" ;
group_len        = "[" number "]" ;
group_sep        = sep ;

; 列表：允许空、允许尾随逗号
field_list_opt   = [ field { ws? "," ws? field } [ ws? "," ] ] ;

field            = [ repeat ] data_type [ symbol_content ]
                   [ subfields ]
                   [ ":" ws? var_name ]
                   [ length ]
                   [ format ]
                   [ sep ]
                   { pipe } ;                              ; 允许多个管道

repeat           = [ number ] "*" ;                        ; "*ip" 或 "3*ip"
length           = "[" number "]" ;                       ; 仅顶层字段支持（子字段不支持）

; 复合字段（如 kvarr/json 等）的子字段列表
subfields        = "(" ws? subfields_opt ws? ")" ;
subfields_opt    = [ subfield { ws? "," ws? subfield } [ ws? "," ] ] ;
subfield         = [ opt_datatype | data_type ]
                   [ symbol_content ]
                   [ "@" ref_path ]
                   [ ":" ws? var_name ]
                   [ format ]
                   [ sep ]
                   { pipe } ;

opt_datatype     = "opt" "(" ws? data_type ws? ")" ;     ; 声明该子字段为可选

; 字段数据类型（与外部 crate wp-model-core::DataType 对应）
data_type        = builtin_type | ns_type | array_type ;

builtin_type     = "auto" | "bool" | "chars" | "symbol" | "peek_symbol"
                   | "digit" | "float" | "_" | "sn"
                   | "time" | "time/clf" | "time_iso" | "time_3339" | "time_2822" | "time_timestamp"
                   | "ip" | "ip_net" | "domain" | "email" | "port"
                   | "hex" | "base64"
                   | "kv" | "kvarr" | "json" | "exact_json"
                   | "url"
                   | "proto_text" | "obj"
                   | "id_card" | "mobile_phone" ;

ns_type          = path_ident ;                               ; 例如 http/request、http/status 等
; 注：实现层面建议对白名单前缀（如 "http/"）做校验，以避免任意路径膨胀语言面。

array_type       = "array" [ "/" key ] ;                 ; 如："array" 或 "array/ip"

; 仅当 data_type 为 symbol/peek_symbol 时允许携带内容
symbol_content   = "(" symbol_chars ")" ;

; 字段显示/抽取格式
format           = scope_fmt | quote_fmt | field_cnt ;
scope_fmt        = "&lt;" any_chars "," any_chars "&gt;" ;   ; 作用域首尾定界，如 &lt;[,]&gt;
quote_fmt        = '"' ;                                ; 等价首尾均为 '"'
field_cnt        = "^" number ;                          ; 仅 chars/_ 合法（实现约束）

; 分隔符（高/中优先级，原样拼接）。语法为反斜杠转义的字符序列，长度&gt;=1
sep              = sep_char , { sep_char } ;             ; 例："\\," =&gt; ","；"\\!\\|" =&gt; "!|"
sep_char         = '\\' , any_char ;

; 字段级管道：函数调用或嵌套分组
pipe             = "|" ws? ( fun_call | group ) ;

; 预置函数（wpl_fun.rs）：
; - 选择器函数：take, last
; - f_ 前缀表示字段集合操作（需指定字段名）
; - 无前缀表示活跃字段操作
; - 转换函数：json_unescape, base64_decode
fun_call         = selector_fun | target_fun | active_fun | transform_fun ;

; 选择器函数
selector_fun     = take_fun | last_fun ;
take_fun         = "take" "(" ws? key ws? ")" ;
last_fun         = "last" "(" ws? ")" ;

; 字段集合操作函数（f_ 前缀）
target_fun       = f_has | f_chars_has | f_chars_not_has | f_chars_in
                 | f_digit_has | f_digit_in | f_ip_in ;
f_has            = "f_has" "(" ws? key ws? ")" ;
f_chars_has      = "f_chars_has" "(" ws? key ws? "," ws? path ws? ")" ;
f_chars_not_has  = "f_chars_not_has" "(" ws? key ws? "," ws? path ws? ")" ;
f_chars_in       = "f_chars_in" "(" ws? key ws? "," ws? path_array ws? ")" ;
f_digit_has      = "f_digit_has" "(" ws? key ws? "," ws? number ws? ")" ;
f_digit_in       = "f_digit_in" "(" ws? key ws? "," ws? number_array ws? ")" ;
f_ip_in          = "f_ip_in" "(" ws? key ws? "," ws? ip_array ws? ")" ;

; 活跃字段操作函数（无前缀）
active_fun       = has_fun | chars_has | chars_not_has | chars_in
                 | digit_has | digit_in | ip_in ;
has_fun          = "has" "(" ws? ")" ;
chars_has        = "chars_has" "(" ws? path ws? ")" ;
chars_not_has    = "chars_not_has" "(" ws? path ws? ")" ;
chars_in         = "chars_in" "(" ws? path_array ws? ")" ;
digit_has        = "digit_has" "(" ws? number ws? ")" ;
digit_in         = "digit_in" "(" ws? number_array ws? ")" ;
ip_in            = "ip_in" "(" ws? ip_array ws? ")" ;

; 转换函数
transform_fun    = json_unescape | base64_decode ;
json_unescape    = "json_unescape" "(" ws? ")" ;
base64_decode    = "base64_decode" "(" ws? ")" ;

path_array       = "[" ws? path { ws? "," ws? path } ws? "]" ;
number_array     = "[" ws? number { ws? "," ws? number } ws? "]" ;
ip_array         = "[" ws? ip_addr { ws? "," ws? ip_addr } ws? "]" ;

annotation       = "#[" ws? ann_item { ws? "," ws? ann_item } ws? "]" ;
ann_item         = tag_anno | copy_raw_anno ;
tag_anno         = "tag" "(" ws? tag_kv { ws? "," ws? tag_kv } ws? ")" ;
tag_kv           = ident ":" ( quoted_string | raw_string ) ;      ; 键为标识符；值为字符串
copy_raw_anno    = "copy_raw" "(" ws? "name" ws? ":" ws? ( quoted_string | raw_string ) ws? ")" ;

; 词法与辅助记号 --------------------------------------------------------
field_name       = var_name ;
rule_name        = exact_path ;
key              = key_char { key_char } ;              ; [A-Za-z0-9_./-]+
var_name         = var_char { var_char } ;              ; [A-Za-z0-9_.-]+
ref_path         = ref_char { ref_char } ;              ; [A-Za-z0-9_./\-.[\]*]+
; 标识符与路径标识符（推荐写法）
ident            = ( letter | '_' ) { letter | digit | '_' | '.' | '-' } ;
path_ident       = ident { "/" ident } ;

exact_path       = exact_path_char { exact_path_char } ; ; 不含 '[' ']' '*'
exact_path_char  = letter | digit | '_' | '.' | '/' | '-' ;
path             = key | ref_path ;

number           = digit { digit } ;
digit            = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

key_char         = letter | digit | '_' | '.' | '/' | '-' ;
var_char         = letter | digit | '_' | '.' | '-' ;
ref_char         = key_char | '[' | ']' | '*' ;

letter           = 'A'..'Z' | 'a'..'z' ;

quoted_string    = '"' { escaped | char_no_quote_backslash } '"' ;
raw_string       = 'r' '#' '"' { any_char } '"' '#' ;          ; r#"..."#，内部不处理转义（内容可包含 '"'）
char_no_quote    = ? any char except '"' ? ;
escaped          = '\\' ( '"' | '\\' | 'n' | 't' | 'r' | 'x' hex hex ) ;
char_no_quote_backslash = ? any char except '"' and '\\' ? ;
hex              = '0'..'9' | 'a'..'f' | 'A'..'F' ;

free_string      = { fchar } ;                          ; 直至 ',' 或 ')'（不含）
fchar            = ? any char except ',' and ')' ? ;

symbol_chars     = { schar } ;                          ; 允许除 ')' 与 '\\' 外字符，或使用 '\)' 转义
schar            = char_no_close_paren_backslash | '\\' ')' ;
char_no_close_paren_backslash = ? any char except ')' and '\\' ? ;
any_chars        = { any_char } ;
any_char         = ? any character ? ;

ip_addr          = quoted_string | ipv4 | ipv6 ;        ; 支持 IPv4/IPv6 裸字面量或带引号
ipv4             = digit1 "." digit1 "." digit1 "." digit1 ;
digit1           = digit { digit } ;
ipv6             = ? valid IPv6 literal (RFC 4291), including compressed forms like "::1" ? ;

ws               = { ' ' | '\t' | '\n' | '\r' } ;

;保留关键字（不可作为标识符使用；由实现侧进行冲突校验）
ReservedKeyword  = "package" | "rule" | "alt" | "opt" | "some_of" | "seq" | "order"
                 | "tag" | "copy_raw" | "include" | "macro" ;


</code></pre>
<hr>
<h2 id="语义说明"><a class="header" href="#语义说明">语义说明</a></h2>
<h3 id="预处理管道"><a class="header" href="#预处理管道">预处理管道</a></h3>
<ul>
<li><code>preproc</code> 管道（例如 <code>|decode/base64|unquote/unescape|</code>）出现在 <code>express</code> 起始处，独立于字段级 <code>pipe</code></li>
<li>作用于整行输入，在字段解析前执行</li>
<li>执行顺序：从左到右</li>
<li>必须以 <code>|</code> 结尾</li>
</ul>
<h3 id="分组长度和分隔符"><a class="header" href="#分组长度和分隔符">分组长度和分隔符</a></h3>
<ul>
<li><code>group</code> 后可跟 <code>[n]</code> 与分隔符 <code>sep</code></li>
<li>长度会应用到组内所有字段</li>
<li><code>sep</code> 仅存储在组上，具体组合策略见实现</li>
</ul>
<h3 id="格式控制-2"><a class="header" href="#格式控制-2">格式控制</a></h3>
<ul>
<li><code>format</code> 中的 <code>field_cnt</code>（<code>^n</code>）仅适用于 <code>chars/_</code> 类型</li>
<li>其它类型将被拒绝（实现约束）</li>
</ul>
<h3 id="符号类型"><a class="header" href="#符号类型">符号类型</a></h3>
<ul>
<li><code>symbol/peek_symbol</code> 可携带 <code>symbol_content</code>，如 <code>symbol(boy)</code></li>
<li><code>peek_symbol</code> 等价于 <code>symbol</code>，且仅改变“窥探“语义（预读但不消费）</li>
</ul>
<h3 id="子字段"><a class="header" href="#子字段">子字段</a></h3>
<ul>
<li><code>subfields</code> 中未显式 <code>"@ref"</code> 时，键默认为 <code>"*"</code>（通配键）</li>
<li>子字段支持 <code>opt(type)</code> 标记为可选</li>
</ul>
<h3 id="分隔符"><a class="header" href="#分隔符">分隔符</a></h3>
<ul>
<li><code>sep</code> 写法需以反斜杠转义每个字符</li>
<li>例如 <code>\\!\\|</code> 代表字符串 <code>"!|"</code></li>
<li>优先级：字段级 &gt; 组级 &gt; 上游</li>
</ul>
<h3 id="注解"><a class="header" href="#注解">注解</a></h3>
<ul>
<li><code>annotation</code> 可用于 <code>package</code> 与 <code>rule</code></li>
<li>若同时存在，会在 <code>rule</code> 侧合并（<code>rule</code> 优先）</li>
</ul>
<hr>
<h2 id="相关文档-3"><a class="header" href="#相关文档-3">相关文档</a></h2>
<ul>
<li>快速入门：<a href="#wpl-快速入门">01-quickstart.md</a></li>
<li>核心概念：<a href="#wpl-核心概念">02-core-concepts.md</a></li>
<li>实战指南：<a href="#wpl-实战指南">03-practical-guide.md</a></li>
<li>语言参考：<a href="#wpl-语言参考">04-language-reference.md</a></li>
<li>函数参考：<a href="#wpl-函数参考">05-functions-reference.md</a></li>
</ul>
<hr>
<h2 id="实现参考"><a class="header" href="#实现参考">实现参考</a></h2>
<ul>
<li>语法实现：<code>crates/wp-lang/src/parser/</code></li>
<li>管道函数：<code>crates/wp-lang/src/parser/wpl_fun.rs</code></li>
<li>数据类型：外部 crate <code>wp-model-core</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-field-functions-函数索引"><a class="header" href="#wpl-field-functions-函数索引">WPL Field Functions 函数索引</a></h1>
<p>本文档列出了 WP-Motor WPL 语言中所有可用的 field function（字段函数）。</p>
<h2 id="字段选择函数-field-selectors"><a class="header" href="#字段选择函数-field-selectors">字段选择函数 (Field Selectors)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>take</code></td><td><code>take(field_name)</code></td><td>选择指定名称的字段作为活动字段</td><td>-</td></tr>
<tr><td><code>last</code></td><td><code>last()</code></td><td>选择最后一个字段作为活动字段</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="字符串匹配函数-string-matching"><a class="header" href="#字符串匹配函数-string-matching">字符串匹配函数 (String Matching)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>chars_has</code></td><td><code>chars_has(value)</code></td><td>检查字符串字段是否等于指定值</td><td>-</td></tr>
<tr><td><code>chars_not_has</code></td><td><code>chars_not_has(value)</code></td><td>检查字符串字段是否不等于指定值</td><td>-</td></tr>
<tr><td><code>chars_in</code></td><td><code>chars_in([value1, value2, ...])</code></td><td>检查字符串字段是否在值列表中</td><td>-</td></tr>
<tr><td><code>f_chars_has</code></td><td><code>f_chars_has(target, value)</code></td><td>检查指定字段是否等于指定值</td><td>-</td></tr>
<tr><td><code>f_chars_not_has</code></td><td><code>f_chars_not_has(target, value)</code></td><td>检查指定字段是否不等于指定值</td><td>-</td></tr>
<tr><td><code>f_chars_in</code></td><td><code>f_chars_in(target, [values])</code></td><td>检查指定字段是否在值列表中</td><td>-</td></tr>
<tr><td><code>starts_with</code></td><td><code>starts_with('prefix')</code></td><td>检查字符串是否以指定前缀开始，否则转为 ignore</td><td><a href="#starts_with-函数使用指南">📖 详细文档</a></td></tr>
<tr><td><code>regex_match</code></td><td><code>regex_match('pattern')</code></td><td>使用正则表达式匹配字符串字段</td><td><a href="#regex_match-函数使用指南">📖 详细文档</a></td></tr>
</tbody>
</table>
</div>
<h2 id="数值匹配函数-numeric-matching"><a class="header" href="#数值匹配函数-numeric-matching">数值匹配函数 (Numeric Matching)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>digit_has</code></td><td><code>digit_has(value)</code></td><td>检查数值字段是否等于指定值</td><td>-</td></tr>
<tr><td><code>digit_in</code></td><td><code>digit_in([value1, value2, ...])</code></td><td>检查数值字段是否在值列表中</td><td>-</td></tr>
<tr><td><code>digit_range</code></td><td><code>digit_range(begin, end)</code></td><td>检查数值是否在指定范围内（闭区间）</td><td><a href="#digit_range-函数使用指南">📖 详细文档</a></td></tr>
<tr><td><code>f_digit_has</code></td><td><code>f_digit_has(target, value)</code></td><td>检查指定字段是否等于指定数值</td><td>-</td></tr>
<tr><td><code>f_digit_in</code></td><td><code>f_digit_in(target, [values])</code></td><td>检查指定字段是否在数值列表中</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="ip-地址匹配函数-ip-matching"><a class="header" href="#ip-地址匹配函数-ip-matching">IP 地址匹配函数 (IP Matching)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>ip_in</code></td><td><code>ip_in([ip1, ip2, ...])</code></td><td>检查 IP 地址是否在列表中</td><td>-</td></tr>
<tr><td><code>f_ip_in</code></td><td><code>f_ip_in(target, [ips])</code></td><td>检查指定字段的 IP 地址是否在列表中</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="字段存在性检查-field-existence"><a class="header" href="#字段存在性检查-field-existence">字段存在性检查 (Field Existence)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>has</code></td><td><code>has()</code></td><td>检查当前活动字段是否存在</td><td>-</td></tr>
<tr><td><code>f_has</code></td><td><code>f_has(target)</code></td><td>检查指定字段是否存在</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="包装函数-wrapper-functions"><a class="header" href="#包装函数-wrapper-functions">包装函数 (Wrapper Functions)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>not</code></td><td><code>not(inner_function)</code></td><td>反转（取反）内部管道函数的成功/失败结果</td><td><a href="#not---结果反转包装函数">📖 详细文档</a></td></tr>
</tbody>
</table>
</div>
<h2 id="字符串转换函数-string-transformation"><a class="header" href="#字符串转换函数-string-transformation">字符串转换函数 (String Transformation)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>json_unescape</code></td><td><code>json_unescape()</code></td><td>解码 JSON 转义字符（<code>\n</code>, <code>\t</code>, <code>\"</code>, <code>\\</code> 等）</td><td>-</td></tr>
<tr><td><code>base64_decode</code></td><td><code>base64_decode()</code></td><td>Base64 解码字符串字段</td><td>-</td></tr>
<tr><td><code>chars_replace</code></td><td><code>chars_replace(target, replacement)</code></td><td>替换字符串中的子串</td><td><a href="#chars_replace-函数使用指南">📖 详细文档</a></td></tr>
</tbody>
</table>
</div>
<h2 id="函数分类总览"><a class="header" href="#函数分类总览">函数分类总览</a></h2>
<h3 id="按功能分类"><a class="header" href="#按功能分类">按功能分类</a></h3>
<h4 id="1-条件检查函数"><a class="header" href="#1-条件检查函数">1. 条件检查函数</a></h4>
<p>用于检查字段是否满足特定条件，不修改字段值。</p>
<ul>
<li>字符串检查：<code>chars_has</code>, <code>chars_not_has</code>, <code>chars_in</code>, <code>starts_with</code>, <code>regex_match</code></li>
<li>数值检查：<code>digit_has</code>, <code>digit_in</code>, <code>digit_range</code></li>
<li>IP 检查：<code>ip_in</code></li>
<li>存在性检查：<code>has</code></li>
</ul>
<h4 id="2-转换函数"><a class="header" href="#2-转换函数">2. 转换函数</a></h4>
<p>修改字段值的函数。</p>
<ul>
<li>解码：<code>json_unescape</code>, <code>base64_decode</code></li>
<li>替换：<code>chars_replace</code></li>
</ul>
<h4 id="3-字段选择函数"><a class="header" href="#3-字段选择函数">3. 字段选择函数</a></h4>
<p>用于选择特定字段作为活动字段。</p>
<ul>
<li><code>take</code>: 按名称选择</li>
<li><code>last</code>: 选择最后一个字段</li>
</ul>
<h4 id="4-包装函数"><a class="header" href="#4-包装函数">4. 包装函数</a></h4>
<p>包装其他函数以改变其行为。</p>
<ul>
<li><code>not</code>: 反转内部函数的成功/失败结果</li>
</ul>
<h3 id="按目标字段支持分类"><a class="header" href="#按目标字段支持分类">按目标字段支持分类</a></h3>
<h4 id="操作当前活动字段"><a class="header" href="#操作当前活动字段">操作当前活动字段</a></h4>
<ul>
<li><code>chars_has</code>, <code>chars_not_has</code>, <code>chars_in</code>, <code>starts_with</code></li>
<li><code>digit_has</code>, <code>digit_in</code>, <code>digit_range</code></li>
<li><code>ip_in</code></li>
<li><code>has</code></li>
<li><code>json_unescape</code>, <code>base64_decode</code>, <code>chars_replace</code></li>
<li><code>regex_match</code></li>
</ul>
<h4 id="可指定目标字段-带-f_-前缀"><a class="header" href="#可指定目标字段-带-f_-前缀">可指定目标字段 (带 <code>f_</code> 前缀)</a></h4>
<ul>
<li><code>f_chars_has</code>, <code>f_chars_not_has</code>, <code>f_chars_in</code></li>
<li><code>f_digit_has</code>, <code>f_digit_in</code></li>
<li><code>f_ip_in</code></li>
<li><code>f_has</code></li>
</ul>
<h2 id="使用示例-2"><a class="header" href="#使用示例-2">使用示例</a></h2>
<h3 id="基本流水线"><a class="header" href="#基本流水线">基本流水线</a></h3>
<pre><code class="language-wpl">rule example_pipeline {
    # 1. 选择字段
    | take(message)

    # 2. 检查条件
    | chars_has(error)

    # 3. 转换处理
    | chars_replace(error, ERROR)
}
</code></pre>
<h3 id="复杂条件组合"><a class="header" href="#复杂条件组合">复杂条件组合</a></h3>
<pre><code class="language-wpl">rule complex_filter {
    # 检查状态码范围
    | take(status)
    | digit_range(200, 299)  # 2xx 成功状态码

    # 检查消息内容
    | take(message)
    | regex_match('(?i)(success|ok|complete)')
}
</code></pre>
<h3 id="分支逻辑"><a class="header" href="#分支逻辑">分支逻辑</a></h3>
<pre><code class="language-wpl">rule branching_logic {
    # 分支 1：错误日志
    (
        | take(level)
        | chars_in([ERROR, FATAL])
    )
    |
    # 分支 2：警告日志
    (
        | take(level)
        | chars_in([WARN, WARNING])
    )
}
</code></pre>
<h2 id="性能参考"><a class="header" href="#性能参考">性能参考</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数类型</th><th>典型性能</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>字段选择</td><td>&lt; 100ns</td><td>极快，基于索引查找</td></tr>
<tr><td>字符串匹配</td><td>&lt; 1μs</td><td>简单字符串比较</td></tr>
<tr><td>数值匹配</td><td>&lt; 100ns</td><td>简单数值比较</td></tr>
<tr><td>范围检查</td><td>&lt; 500ns</td><td>线性扫描多个范围</td></tr>
<tr><td>正则匹配</td><td>1-100μs</td><td>取决于模式复杂度</td></tr>
<tr><td>Base64 解码</td><td>1-10μs</td><td>取决于字符串长度</td></tr>
<tr><td>字符串替换</td><td>1-10μs</td><td>取决于字符串长度</td></tr>
</tbody>
</table>
</div>
<h2 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h2>
<h3 id="1-合理使用函数类型"><a class="header" href="#1-合理使用函数类型">1. 合理使用函数类型</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：简单匹配使用 chars_has
| chars_has(error)

# ⚠️ 过度使用：简单匹配不需要正则
| regex_match('^error$')  # 性能较差
</code></pre>
<h3 id="2-优先使用专用函数"><a class="header" href="#2-优先使用专用函数">2. 优先使用专用函数</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：数值范围使用 digit_range
| digit_range(200, 299)

# ⚠️ 不推荐：用正则匹配数字
| regex_match('^2\d{2}$')  # 性能较差
</code></pre>
<h3 id="3-先选择字段再处理"><a class="header" href="#3-先选择字段再处理">3. 先选择字段再处理</a></h3>
<pre><code class="language-wpl"># ✅ 正确
| take(message)
| chars_replace(old, new)

# ❌ 错误：没有活动字段
| chars_replace(old, new)  # 会失败
</code></pre>
<h3 id="4-组合使用条件函数"><a class="header" href="#4-组合使用条件函数">4. 组合使用条件函数</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：先用简单条件过滤，再用复杂条件
| chars_has(error)          # 快速过滤
| regex_match('error:\d+')  # 精确匹配
</code></pre>
<h2 id="函数对比"><a class="header" href="#函数对比">函数对比</a></h2>
<h3 id="chars_has-vs-regex_match"><a class="header" href="#chars_has-vs-regex_match">chars_has vs regex_match</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>chars_has</th><th>regex_match</th></tr>
</thead>
<tbody>
<tr><td>用途</td><td>精确字符串匹配</td><td>模式匹配</td></tr>
<tr><td>性能</td><td>极快</td><td>相对较慢</td></tr>
<tr><td>灵活性</td><td>低</td><td>高</td></tr>
<tr><td>适用场景</td><td>已知固定值</td><td>复杂模式</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-wpl"># 简单匹配：使用 chars_has
| chars_has(ERROR)

# 复杂匹配：使用 regex_match
| regex_match('(?i)error:\s*\d+')
</code></pre>
<h3 id="digit_in-vs-digit_range"><a class="header" href="#digit_in-vs-digit_range">digit_in vs digit_range</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>digit_in</th><th>digit_range</th></tr>
</thead>
<tbody>
<tr><td>用途</td><td>离散值检查</td><td>范围检查</td></tr>
<tr><td>参数</td><td>值列表</td><td>范围列表</td></tr>
<tr><td>适用场景</td><td>特定值（如状态码）</td><td>连续范围</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-wpl"># 离散值：使用 digit_in
| digit_in([200, 404, 500])

# 连续范围：使用 digit_range
| digit_range(200, 299)
</code></pre>
<h3 id="目标字段函数-vs-活动字段函数"><a class="header" href="#目标字段函数-vs-活动字段函数">目标字段函数 vs 活动字段函数</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>活动字段函数</th><th>目标字段函数</th></tr>
</thead>
<tbody>
<tr><td>前缀</td><td>无</td><td><code>f_</code></td></tr>
<tr><td>字段选择</td><td>需要先 take</td><td>自动选择</td></tr>
<tr><td>性能</td><td>稍快</td><td>稍慢（需查找）</td></tr>
<tr><td>便利性</td><td>需要额外步骤</td><td>一步到位</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-wpl"># 活动字段函数
| take(status)
| digit_has(200)

# 目标字段函数（更简洁）
| f_digit_has(status, 200)
</code></pre>
<h2 id="相关文档-4"><a class="header" href="#相关文档-4">相关文档</a></h2>
<ul>
<li><strong>开发指南</strong>: <a href="10-user/guide/wpl_field_func_development_guide.html">WPL Field Function 开发指南</a></li>
<li><strong>字段引用</strong>: <a href="#wpl-字段引用使用指南">Field Reference</a></li>
<li><strong>分隔符</strong>: <a href="#wpl-分隔符使用指南">Separator Guide</a></li>
</ul>
<h2 id="版本历史"><a class="header" href="#版本历史">版本历史</a></h2>
<ul>
<li>
<p><strong>1.15.1</strong> (2026-02-07)</p>
<ul>
<li>新增 <code>not()</code> 包装函数</li>
<li>修复 <code>f_chars_not_has</code> 和 <code>chars_not_has</code> 类型检查bug</li>
</ul>
</li>
<li>
<p><strong>1.13.4</strong> (2026-02-03)</p>
<ul>
<li>新增 <code>starts_with</code> 函数</li>
<li>完善文档体系</li>
</ul>
</li>
<li>
<p><strong>1.13.1</strong> (2026-02-02)</p>
<ul>
<li>新增 <code>digit_range</code> 函数</li>
<li>新增 <code>regex_match</code> 函数</li>
<li>完善文档体系</li>
</ul>
</li>
<li>
<p><strong>1.11.0</strong> (2026-01-29)</p>
<ul>
<li>新增 <code>chars_replace</code> 函数</li>
<li>完善 Base64 和 JSON 转义支持</li>
</ul>
</li>
</ul>
<hr>
<p><strong>提示</strong>: 选择合适的函数类型可以显著提升性能。优先使用简单的专用函数，仅在需要复杂模式匹配时使用正则表达式。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-字段引用使用指南"><a class="header" href="#wpl-字段引用使用指南">WPL 字段引用使用指南</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>在 WPL 中，使用 <code>@</code> 符号来引用集合中的字段。支持两种字段名格式：</p>
<ul>
<li><strong>普通标识符</strong>：<code>@field_name</code></li>
<li><strong>单引号字符串</strong>：<code>@'@special-field'</code>（用于包含特殊字符的字段名）</li>
</ul>
<h2 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h2>
<h3 id="基本语法"><a class="header" href="#基本语法">基本语法</a></h3>
<pre><code class="language-wpl"># 引用普通字段
@field_name

# 引用带特殊字符的字段
@'special-field-name'

# 指定字段类型和别名
datatype@field_name: alias_name
</code></pre>
<h3 id="简单示例"><a class="header" href="#简单示例">简单示例</a></h3>
<pre><code class="language-wpl"># JSON 解析 - 提取字段
rule parse_json {
    json(
        @src_ip: source_ip,
        @dst_ip: dest_ip,
        @message: msg
    )
}

# 使用单引号处理特殊字段名
rule parse_json_special {
    json(
        @'@client-ip': client,
        @'event.type': event,
        @'log/level': level
    )
}
</code></pre>
<h2 id="普通字段引用"><a class="header" href="#普通字段引用">普通字段引用</a></h2>
<h3 id="支持的字符"><a class="header" href="#支持的字符">支持的字符</a></h3>
<p>普通字段名（不带引号）支持以下字符：</p>
<ul>
<li>字母和数字（a-z, A-Z, 0-9）</li>
<li>下划线（<code>_</code>）</li>
<li>斜杠（<code>/</code>）</li>
<li>连字符（<code>-</code>）</li>
<li>点号（<code>.</code>）</li>
<li>方括号（<code>[</code>, <code>]</code>）- 用于数组索引</li>
<li>星号（<code>*</code>）- 用于通配符</li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<pre><code class="language-wpl"># 简单字段名
@user_id
@username
@ip_address

# 路径式字段名
@process/name
@parent/process/pid
@network/protocol

# 数组索引
@items[0]
@data[5]/value
@process[0]/path

# 通配符
@items[*]
@logs/*/message
</code></pre>
<h2 id="单引号字段引用"><a class="header" href="#单引号字段引用">单引号字段引用</a></h2>
<h3 id="何时使用"><a class="header" href="#何时使用">何时使用</a></h3>
<p>当字段名包含以下特殊字符时，必须使用单引号：</p>
<ul>
<li><code>@</code> 符号</li>
<li>空格</li>
<li>逗号（<code>,</code>）</li>
<li>等号（<code>=</code>）</li>
<li>括号（<code>(</code>, <code>)</code>）</li>
<li>尖括号（<code>&lt;</code>, <code>&gt;</code>）</li>
<li>井号（<code>#</code>）</li>
<li>其他非标准字符</li>
</ul>
<h3 id="基本语法-1"><a class="header" href="#基本语法-1">基本语法</a></h3>
<pre><code class="language-wpl">@'field name with spaces'
@'@field-with-at-sign'
@'field,with,commas'
</code></pre>
<h3 id="转义字符"><a class="header" href="#转义字符">转义字符</a></h3>
<p><strong>双引号字符串</strong>支持以下转义序列：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>转义序列</th><th>含义</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><code>\"</code></td><td>双引号</td><td><code>@"field\"name"</code></td></tr>
<tr><td><code>\\</code></td><td>反斜杠</td><td><code>@"path\\to\\file"</code></td></tr>
<tr><td><code>\n</code></td><td>换行符</td><td><code>@"multi\nline"</code></td></tr>
<tr><td><code>\t</code></td><td>制表符</td><td><code>@"tab\tseparated"</code></td></tr>
<tr><td><code>\r</code></td><td>回车符</td><td><code>@"carriage\rreturn"</code></td></tr>
<tr><td><code>\xHH</code></td><td>十六进制字节</td><td><code>@"hex\x41value"</code></td></tr>
</tbody>
</table>
</div>
<p><strong>单引号字符串</strong>是<strong>原始字符串</strong>（raw string）：</p>
<ul>
<li><strong>只支持</strong> <code>\'</code> 转义单引号本身</li>
<li>其他所有反斜杠 <code>\</code> 都按字面意思处理</li>
<li><code>\n</code>、<code>\t</code>、<code>\\</code> 等不会被转义</li>
</ul>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<pre><code class="language-wpl"># 双引号 - 支持完整转义
@"field\"name"      # 结果: field"name
@"path\\file"       # 结果: path\file
@"line\nbreak"      # 结果: line换行break

# 单引号 - 原始字符串，只转义 \'
@'field\'s name'    # 结果: field's name
@'path\to\file'     # 结果: path\to\file (字面反斜杠)
@'raw\nstring'      # 结果: raw\nstring (字面 \n)
@'C:\Users\test'    # 结果: C:\Users\test (Windows 路径)
</code></pre>
<p><strong>推荐使用场景</strong>：</p>
<ul>
<li><strong>单引号</strong>：Windows 路径、Unix 路径、正则表达式、包含反斜杠的字符串</li>
<li><strong>双引号</strong>：需要换行符、制表符等转义字符的场景</li>
</ul>
<h2 id="实际应用场景"><a class="header" href="#实际应用场景">实际应用场景</a></h2>
<h3 id="场景-1解析-elasticsearch-日志"><a class="header" href="#场景-1解析-elasticsearch-日志">场景 1：解析 Elasticsearch 日志</a></h3>
<pre><code class="language-wpl"># Elasticsearch 字段通常使用 @ 前缀
rule elasticsearch_log {
    json(
        @'@timestamp': timestamp,
        @'@version': version,
        @message: msg,
        @'log.level': level,
        @'event.action': action
    )
}
</code></pre>
<h3 id="场景-2解析带空格的字段名"><a class="header" href="#场景-2解析带空格的字段名">场景 2：解析带空格的字段名</a></h3>
<pre><code class="language-wpl"># CSV 或其他格式可能包含带空格的列名
rule csv_with_spaces {
    (
        @'First Name': first_name,
        @'Last Name': last_name,
        @'Email Address': email,
        @'Phone Number': phone
    )
}
</code></pre>
<h3 id="场景-3解析嵌套-json-字段"><a class="header" href="#场景-3解析嵌套-json-字段">场景 3：解析嵌套 JSON 字段</a></h3>
<pre><code class="language-wpl"># JSON 字段路径包含特殊字符
rule nested_json {
    json(
        @'user.id': uid,
        @'user.profile.name': username,
        @'event#metadata': metadata,
        @'geo.location.lat': latitude,
        @'geo.location.lon': longitude
    )
}
</code></pre>
<h3 id="场景-4处理-prometheus-指标"><a class="header" href="#场景-4处理-prometheus-指标">场景 4：处理 Prometheus 指标</a></h3>
<pre><code class="language-wpl"># Prometheus 指标名称包含多种特殊字符
rule prometheus_metrics {
    (
        @'http_requests_total{method="GET"}': get_requests,
        @'http_requests_total{method="POST"}': post_requests,
        @'process_cpu_seconds_total': cpu_usage
    )
}
</code></pre>
<h3 id="场景-5windows-事件日志"><a class="header" href="#场景-5windows-事件日志">场景 5：Windows 事件日志</a></h3>
<pre><code class="language-wpl"># Windows 路径包含反斜杠
rule windows_events {
    json(
        @'Event.System.Provider': provider,
        @'Event.EventData.CommandLine': cmdline,
        @'Process\\Path': process_path
    )
}
</code></pre>
<h3 id="场景-6混合使用普通和特殊字段名"><a class="header" href="#场景-6混合使用普通和特殊字段名">场景 6：混合使用普通和特殊字段名</a></h3>
<pre><code class="language-wpl">rule mixed_fields {
    json(
        # 普通字段名
        @username: user,
        @ip_address: ip,
        @timestamp: time,

        # 特殊字段名
        @'@client-ip': client,
        @'user.email': email,
        @'event#type': event_type,
        @'log level': level
    )
}
</code></pre>
<h3 id="场景-7kv-解析带特殊字段"><a class="header" href="#场景-7kv-解析带特殊字段">场景 7：KV 解析带特殊字段</a></h3>
<pre><code class="language-wpl"># 键值对中包含特殊字符的键
rule kv_special_keys {
    kv(
        @'@timestamp': time,
        @'event-type': type,
        @'user/name': username,
        @'session#id': session
    )
}
</code></pre>
<h2 id="take-函数引号支持"><a class="header" href="#take-函数引号支持">take() 函数引号支持</a></h2>
<p><code>take()</code> 函数用于选择当前字段，同样支持单引号和双引号来处理包含特殊字符的字段名。</p>
<h3 id="基本语法-2"><a class="header" href="#基本语法-2">基本语法</a></h3>
<pre><code class="language-wpl"># 普通字段名
| take(field_name)

# 双引号字段名
| take("@special-field")

# 单引号字段名
| take('@special-field')
</code></pre>
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<h4 id="1-选择带特殊字符的字段"><a class="header" href="#1-选择带特殊字符的字段">1. 选择带特殊字符的字段</a></h4>
<pre><code class="language-wpl">rule select_special_fields {
    # 双引号
    | take("@timestamp")
    | take("field with spaces")
    | take("field,with,commas")

    # 单引号
    | take('@client-ip')
    | take('event.type')
    | take('log/level')
}
</code></pre>
<h4 id="2-转义字符支持"><a class="header" href="#2-转义字符支持">2. 转义字符支持</a></h4>
<pre><code class="language-wpl">rule escaped_fields {
    # 双引号内转义
    | take("field\"name")
    | take("path\\with\\backslash")

    # 单引号内转义
    | take('field\'s name')
    | take('path\\to\\file')
}
</code></pre>
<h4 id="3-实际应用"><a class="header" href="#3-实际应用">3. 实际应用</a></h4>
<pre><code class="language-wpl"># Elasticsearch 日志处理
rule elasticsearch {
    | take("@timestamp")
    | take("@version")
    | take("log.level")
}

# CSV 数据处理
rule csv_processing {
    | take('First Name')
    | take('Last Name')
    | take('Email Address')
}

# 混合使用
rule mixed_usage {
    | take(user_id)          # 普通字段
    | take("@timestamp")     # 双引号
    | take('event.type')     # 单引号
}
</code></pre>
<h3 id="支持的转义字符"><a class="header" href="#支持的转义字符">支持的转义字符</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>转义序列</th><th>含义</th><th>双引号</th><th>单引号</th></tr>
</thead>
<tbody>
<tr><td><code>\"</code></td><td>双引号</td><td>✅</td><td>❌ (字面 <code>\"</code>)</td></tr>
<tr><td><code>\'</code></td><td>单引号</td><td>❌ (字面 <code>\'</code>)</td><td>✅</td></tr>
<tr><td><code>\\</code></td><td>反斜杠</td><td>✅</td><td>❌ (字面 <code>\\</code>)</td></tr>
<tr><td><code>\n</code></td><td>换行符</td><td>✅</td><td>❌ (字面 <code>\n</code>)</td></tr>
<tr><td><code>\t</code></td><td>制表符</td><td>✅</td><td>❌ (字面 <code>\t</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>说明</strong>：</p>
<ul>
<li><strong>双引号</strong>：支持完整转义，类似 C/Java/JavaScript 字符串</li>
<li><strong>单引号</strong>：原始字符串（raw string），只支持 <code>\'</code> 转义单引号本身，其他反斜杠都是字面字符</li>
</ul>
<h3 id="最佳实践-1"><a class="header" href="#最佳实践-1">最佳实践</a></h3>
<pre><code class="language-wpl"># ✅ 推荐 - 优先使用不带引号
| take(field_name)

# ✅ 推荐 - 特殊字符使用引号
| take("@timestamp")
| take('@client-ip')

# ✅ 推荐 - 根据内容选择引号类型
| take("field with spaces")         # 双引号，适合简单字符串
| take('it\'s a field')              # 单引号，只需转义 \'
| take('C:\Windows\System32')       # 单引号，Windows 路径
| take("line\nbreak")                # 双引号，需要换行符转义
</code></pre>
<h2 id="字段类型指定"><a class="header" href="#字段类型指定">字段类型指定</a></h2>
<p>可以为字段指定数据类型：</p>
<pre><code class="language-wpl"># 不带引号的字段
ip@source_ip: src
digit@port: port_num
time@timestamp: time

# 带引号的字段
ip@'@client-ip': client
digit@'user.age': age
chars@'event message': msg
</code></pre>
<p>支持的类型包括：</p>
<ul>
<li><code>ip</code> - IP 地址</li>
<li><code>digit</code> - 整数</li>
<li><code>float</code> - 浮点数</li>
<li><code>time</code> - 时间戳</li>
<li><code>chars</code> - 字符串</li>
<li><code>json</code> - JSON 对象</li>
<li><code>kv</code> - 键值对</li>
<li>等等</li>
</ul>
<h2 id="字段别名"><a class="header" href="#字段别名">字段别名</a></h2>
<p>使用 <code>:</code> 为字段指定别名：</p>
<pre><code class="language-wpl"># 普通字段别名
@source_ip: src
@destination_ip: dst
@user_id: uid

# 特殊字段别名
@'@timestamp': time
@'event.type': event
@'log/level': level

# 带类型和别名
ip@'@client-ip': client_ip
digit@'user.age': age
chars@'user name': username
</code></pre>
<h2 id="使用限制"><a class="header" href="#使用限制">使用限制</a></h2>
<h3 id="1-不支持双引号"><a class="header" href="#1-不支持双引号">1. 不支持双引号</a></h3>
<p>只支持单引号，不支持双引号：</p>
<pre><code class="language-wpl"># ✅ 正确
@'@field-name'

# ❌ 错误
@"@field-name"
</code></pre>
<h3 id="2-转义字符限制"><a class="header" href="#2-转义字符限制">2. 转义字符限制</a></h3>
<p>转义字符只在单引号字符串内有效：</p>
<pre><code class="language-wpl"># ✅ 正确 - 单引号内转义
@'user\'s name'

# ❌ 错误 - 普通字段名不支持转义
@user\'s_name
</code></pre>
<h3 id="3-空字段名"><a class="header" href="#3-空字段名">3. 空字段名</a></h3>
<p>字段名不能为空：</p>
<pre><code class="language-wpl"># ❌ 错误
@''

# ✅ 正确
@'_'  # 使用下划线作为字段名
</code></pre>
<h3 id="4-嵌套引用"><a class="header" href="#4-嵌套引用">4. 嵌套引用</a></h3>
<p>单引号不支持嵌套：</p>
<pre><code class="language-wpl"># ❌ 错误
@'field\'nested\''

# ✅ 正确 - 使用转义
@'field\'nested'
</code></pre>
<h2 id="性能说明"><a class="header" href="#性能说明">性能说明</a></h2>
<h3 id="解析性能"><a class="header" href="#解析性能">解析性能</a></h3>
<ul>
<li>
<p><strong>普通字段名</strong>：零拷贝，性能最优</p>
<pre><code class="language-wpl">@field_name  # 直接引用，无需分配
</code></pre>
</li>
<li>
<p><strong>单引号字段名</strong>：需要解码转义字符</p>
<pre><code class="language-wpl">@'@field'    # 无转义字符，性能接近普通字段
@'field\'s'  # 有转义字符，需要额外处理
</code></pre>
</li>
</ul>
<h3 id="性能对比"><a class="header" href="#性能对比">性能对比</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>字段名类型</th><th>解析时间</th><th>内存分配</th><th>推荐场景</th></tr>
</thead>
<tbody>
<tr><td>普通字段名</td><td>~10ns</td><td>零拷贝</td><td>优先使用</td></tr>
<tr><td>单引号（无转义）</td><td>~15ns</td><td>一次分配</td><td>特殊字符</td></tr>
<tr><td>单引号（有转义）</td><td>~30ns</td><td>一次分配</td><td>必要时使用</td></tr>
</tbody>
</table>
</div>
<h3 id="优化建议"><a class="header" href="#优化建议">优化建议</a></h3>
<ol>
<li>
<p><strong>优先使用普通字段名</strong></p>
<pre><code class="language-wpl"># ✅ 推荐
@user_id
@timestamp

# ⚠️ 仅在必要时使用
@'@timestamp'
</code></pre>
</li>
<li>
<p><strong>避免不必要的转义</strong></p>
<pre><code class="language-wpl"># ✅ 推荐
@'simple-field'

# ⚠️ 避免
@'field\twith\tescape'  # 仅在确实需要制表符时使用
</code></pre>
</li>
<li>
<p><strong>批量操作时考虑性能</strong></p>
<pre><code class="language-wpl"># 大量字段解析时，优先使用普通字段名
json(
    @user_id,      # 快
    @username,     # 快
    @'@metadata'   # 稍慢
)
</code></pre>
</li>
</ol>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<h3 id="常见错误"><a class="header" href="#常见错误">常见错误</a></h3>
<h4 id="1-字段名包含特殊字符但未使用引号"><a class="header" href="#1-字段名包含特殊字符但未使用引号">1. 字段名包含特殊字符但未使用引号</a></h4>
<pre><code>错误: 解析失败，意外的字符 '@'
原因: 字段名包含 @ 但未使用单引号
解决: @'@field-name'
</code></pre>
<h4 id="2-单引号未闭合"><a class="header" href="#2-单引号未闭合">2. 单引号未闭合</a></h4>
<pre><code>错误: 字符串未闭合
原因: 缺少结束的单引号
解决: 确保引号成对出现 @'field-name'
</code></pre>
<h4 id="3-转义字符错误"><a class="header" href="#3-转义字符错误">3. 转义字符错误</a></h4>
<pre><code>错误: 无效的转义序列
原因: 使用了不支持的转义字符
解决: 只使用支持的转义序列 \', \\, \n, \t, \r, \xHH
</code></pre>
<h4 id="4-空字段名"><a class="header" href="#4-空字段名">4. 空字段名</a></h4>
<pre><code>错误: 字段名不能为空
原因: @'' 或 @ 后无内容
解决: 提供有效的字段名
</code></pre>
<h2 id="最佳实践-1-1"><a class="header" href="#最佳实践-1-1">最佳实践</a></h2>
<h3 id="1-命名规范"><a class="header" href="#1-命名规范">1. 命名规范</a></h3>
<pre><code class="language-wpl"># ✅ 推荐 - 使用下划线分隔
@user_id
@client_ip
@event_timestamp

# ⚠️ 避免 - 除非必要
@'user id'
@'client-ip'
</code></pre>
<h3 id="2-保持一致性"><a class="header" href="#2-保持一致性">2. 保持一致性</a></h3>
<pre><code class="language-wpl"># ✅ 推荐 - 统一风格
rule consistent_naming {
    json(
        @user_id,
        @user_name,
        @user_email
    )
}

# ⚠️ 避免 - 混合风格
rule inconsistent_naming {
    json(
        @user_id,
        @'user name',
        @userEmail
    )
}
</code></pre>
<h3 id="3-文档化特殊字段"><a class="header" href="#3-文档化特殊字段">3. 文档化特殊字段</a></h3>
<pre><code class="language-wpl"># ✅ 推荐 - 添加注释说明
rule documented {
    json(
        # Elasticsearch 的 @timestamp 字段
        @'@timestamp': time,

        # 日志级别（包含空格）
        @'log level': level
    )
}
</code></pre>
<h3 id="4-使用类型前缀"><a class="header" href="#4-使用类型前缀">4. 使用类型前缀</a></h3>
<pre><code class="language-wpl"># ✅ 推荐 - 明确指定类型
time@'@timestamp': time
ip@'@client-ip': client
chars@'event message': msg
</code></pre>
<h3 id="5-别名使用规范"><a class="header" href="#5-别名使用规范">5. 别名使用规范</a></h3>
<pre><code class="language-wpl"># ✅ 推荐 - 使用简短的别名
@'very.long.nested.field.name': short_name
@'@timestamp': time
@'event.action': action

# ⚠️ 避免 - 别名过长
@'@timestamp': timestamp_value_from_elasticsearch
</code></pre>
<h2 id="调试技巧"><a class="header" href="#调试技巧">调试技巧</a></h2>
<h3 id="1-逐步验证字段引用"><a class="header" href="#1-逐步验证字段引用">1. 逐步验证字段引用</a></h3>
<pre><code class="language-wpl"># 第一步：验证单个字段
rule test_single {
    json(@'@timestamp')
}

# 第二步：添加更多字段
rule test_multiple {
    json(
        @'@timestamp',
        @'event.type'
    )
}

# 第三步：添加类型和别名
rule test_complete {
    time@'@timestamp': time,
    chars@'event.type': event
}
</code></pre>
<h3 id="2-检查字段名拼写"><a class="header" href="#2-检查字段名拼写">2. 检查字段名拼写</a></h3>
<pre><code class="language-bash"># 使用 JSON 工具查看原始字段名
echo '{"@timestamp": "2024-01-01"}' | jq 'keys'

# 输出: ["@timestamp"]
# WPL 中使用: @'@timestamp'
</code></pre>
<h3 id="3-测试转义字符"><a class="header" href="#3-测试转义字符">3. 测试转义字符</a></h3>
<pre><code class="language-wpl"># 逐个测试转义字符
@'test\'quote'      # 单引号
@'test\\backslash'  # 反斜杠
@'test\nnewline'    # 换行符
</code></pre>
<h3 id="4-使用调试模式"><a class="header" href="#4-使用调试模式">4. 使用调试模式</a></h3>
<pre><code class="language-bash"># 使用 WP-Motor 调试模式查看解析结果
wp-motor --debug rule.wpl &lt; test.log
</code></pre>
<h2 id="常见问题-faq"><a class="header" href="#常见问题-faq">常见问题 (FAQ)</a></h2>
<h3 id="q1-何时必须使用单引号"><a class="header" href="#q1-何时必须使用单引号">Q1: 何时必须使用单引号？</a></h3>
<p>当字段名包含以下字符时必须使用单引号：</p>
<ul>
<li><code>@</code>、空格、逗号、等号、括号、尖括号、井号等特殊字符</li>
</ul>
<h3 id="q2-单引号和双引号有什么区别"><a class="header" href="#q2-单引号和双引号有什么区别">Q2: 单引号和双引号有什么区别？</a></h3>
<p>WPL 只支持单引号 <code>'</code> 用于字段名引用。双引号 <code>"</code> 用于其他语法元素（如作用域标记）。</p>
<h3 id="q3-如何在字段名中包含单引号"><a class="header" href="#q3-如何在字段名中包含单引号">Q3: 如何在字段名中包含单引号？</a></h3>
<p>使用反斜杠转义：<code>@'user\'s name'</code></p>
<h3 id="q4-性能影响有多大"><a class="header" href="#q4-性能影响有多大">Q4: 性能影响有多大？</a></h3>
<p>对于大多数应用场景，性能影响可忽略不计（纳秒级差异）。只在极高性能要求时才需要考虑。</p>
<h3 id="q5-可以使用变量作为字段名吗"><a class="header" href="#q5-可以使用变量作为字段名吗">Q5: 可以使用变量作为字段名吗？</a></h3>
<p>不可以，字段名必须是静态的字面量。</p>
<h3 id="q6-如何处理动态字段名"><a class="header" href="#q6-如何处理动态字段名">Q6: 如何处理动态字段名？</a></h3>
<p>使用通配符或字段组合：</p>
<pre><code class="language-wpl">@items[*]/name     # 匹配所有数组元素的 name 字段
@'prefix*'         # 匹配以 prefix 开头的字段（如果支持）
</code></pre>
<h3 id="q7-支持-unicode-字符吗"><a class="header" href="#q7-支持-unicode-字符吗">Q7: 支持 Unicode 字符吗？</a></h3>
<p>支持，字段名可以包含任意 Unicode 字符：</p>
<pre><code class="language-wpl">@'用户名称'
@'événement'
@'フィールド'
</code></pre>
<h2 id="更多资源"><a class="header" href="#更多资源">更多资源</a></h2>
<ul>
<li><strong>分隔符使用指南</strong>: <code>docs/usage/wpl/separator.md</code></li>
<li><strong>chars_replace 使用指南</strong>: <code>docs/usage/wpl/chars_replace.md</code></li>
<li><strong>WPL Field Function 开发指南</strong>: <code>docs/guide/wpl_field_func_development_guide.md</code></li>
<li><strong>源代码</strong>:
<ul>
<li><code>crates/wp-lang/src/parser/utils.rs</code> (take_ref_path_or_quoted)</li>
<li><code>crates/wp-lang/src/parser/wpl_field.rs</code> (wpl_id_field)</li>
</ul>
</li>
</ul>
<h2 id="版本历史-1"><a class="header" href="#版本历史-1">版本历史</a></h2>
<ul>
<li><strong>1.11.0</strong> (2026-01-29)
<ul>
<li>新增单引号字段名支持（<code>@'@special-field'</code>）</li>
<li>新增 <code>take()</code> 函数单引号和双引号支持</li>
<li>支持 <code>take("@field")</code> 和 <code>take('@field')</code> 语法</li>
<li>添加转义字符支持（<code>\"</code>, <code>\'</code>, <code>\\</code>, <code>\n</code>, <code>\t</code>）</li>
<li>添加完整的测试覆盖</li>
</ul>
</li>
</ul>
<hr>
<p><strong>提示</strong>: 优先使用普通字段名以获得最佳性能，仅在字段名包含特殊字符时使用引号。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-分隔符使用指南"><a class="header" href="#wpl-分隔符使用指南">WPL 分隔符使用指南</a></h1>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p>分隔符（Separator）是 WPL 中用于分割日志字段的关键语法元素。通过灵活使用分隔符，可以解析各种格式的结构化日志数据。</p>
<h2 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h2>
<h3 id="基本语法-3"><a class="header" href="#基本语法-3">基本语法</a></h3>
<pre><code class="language-wpl">| take(field_name) separator
</code></pre>
<p>分隔符写在字段定义之后，用于指示该字段在何处结束。</p>
<h3 id="简单示例-1"><a class="header" href="#简单示例-1">简单示例</a></h3>
<pre><code class="language-wpl"># 使用空格分隔
| take(ip) \s
| take(method) \s
| take(path)

# 使用逗号分隔
| take(name) ,
| take(age) ,
| take(city)
</code></pre>
<h2 id="内置分隔符"><a class="header" href="#内置分隔符">内置分隔符</a></h2>
<h3 id="1-空格分隔符-s"><a class="header" href="#1-空格分隔符-s">1. 空格分隔符 <code>\s</code></a></h3>
<p>匹配单个空格字符。</p>
<pre><code class="language-wpl"># 输入: "192.168.1.1 GET /api/users"
rule parse_log {
    | take(ip) \s
    | take(method) \s
    | take(path)
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>Apache/Nginx 访问日志</li>
<li>空格分隔的简单日志</li>
<li>标准格式日志文件</li>
</ul>
<h3 id="2-制表符分隔符-t"><a class="header" href="#2-制表符分隔符-t">2. 制表符分隔符 <code>\t</code></a></h3>
<p>匹配单个制表符（Tab）字符。</p>
<pre><code class="language-wpl"># 输入: "user001\t25\tBeijing"
rule parse_tsv {
    | take(user_id) \t
    | take(age) \t
    | take(city)
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>TSV（Tab-Separated Values）文件</li>
<li>数据库导出文件</li>
<li>制表符对齐的日志</li>
</ul>
<h3 id="3-通用空白分隔符-s"><a class="header" href="#3-通用空白分隔符-s">3. 通用空白分隔符 <code>\S</code></a></h3>
<p>匹配空格<strong>或</strong>制表符（二选一）。</p>
<pre><code class="language-wpl"># 输入: "field1 field2\tfield3"（混合空格和制表符）
rule parse_flexible {
    | take(col1) \S
    | take(col2) \S
    | take(col3)
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>格式不统一的日志（混合空格和 Tab）</li>
<li>手工编辑过的配置文件</li>
<li>宽松的数据解析</li>
</ul>
<p><strong>行为说明</strong>：</p>
<ul>
<li>遇到空格或制表符都会停止</li>
<li>灵活处理格式不一致的数据源</li>
</ul>
<h3 id="4-行尾分隔符-0"><a class="header" href="#4-行尾分隔符-0">4. 行尾分隔符 <code>\0</code></a></h3>
<p>读取到行尾（换行符或字符串结束）。</p>
<pre><code class="language-wpl"># 输入: "prefix_value some remaining text until end"
rule parse_to_end {
    | take(prefix) _
    | take(remaining) \0
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>解析最后一个字段</li>
<li>读取消息正文</li>
<li>获取剩余所有内容</li>
</ul>
<p><strong>别名</strong>：</p>
<ul>
<li><code>\0</code> 和 <code>0</code> 等价</li>
</ul>
<h3 id="5-自定义字符分隔符"><a class="header" href="#5-自定义字符分隔符">5. 自定义字符分隔符</a></h3>
<p>使用任意单个字符作为分隔符。</p>
<pre><code class="language-wpl"># 逗号分隔
| take(name) ,
| take(age) ,

# 竖线分隔
| take(id) |
| take(status) |

# 分号分隔
| take(key) ;
| take(value) ;
</code></pre>
<p><strong>支持的字符</strong>：</p>
<ul>
<li>逗号 <code>,</code></li>
<li>竖线 <code>|</code></li>
<li>分号 <code>;</code></li>
<li>冒号 <code>:</code></li>
<li>等号 <code>=</code></li>
<li>斜杠 <code>/</code></li>
<li>等任意单字符</li>
</ul>
<h3 id="6-自定义字符串分隔符"><a class="header" href="#6-自定义字符串分隔符">6. 自定义字符串分隔符</a></h3>
<p>使用多字符字符串作为分隔符。</p>
<pre><code class="language-wpl"># 使用 " | " 分隔
| take(field1) " | "
| take(field2) " | "

# 使用 " :: " 分隔
| take(module) " :: "
| take(function) " :: "
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>格式化输出的日志</li>
<li>特定格式协议</li>
<li>需要明确边界的数据</li>
</ul>
<h2 id="实际应用场景-1"><a class="header" href="#实际应用场景-1">实际应用场景</a></h2>
<h3 id="场景-1解析-nginx-访问日志"><a class="header" href="#场景-1解析-nginx-访问日志">场景 1：解析 Nginx 访问日志</a></h3>
<pre><code class="language-wpl"># 日志格式: 192.168.1.1 - - [29/Jan/2024:10:30:45 +0800] "GET /api/users HTTP/1.1" 200 1234
rule nginx_access_log {
    | take(client_ip) \s
    | take(identity) \s
    | take(user) \s
    | take(timestamp) \s
    | take(request) \s
    | take(status_code) \s
    | take(bytes_sent) \0
}
</code></pre>
<h3 id="场景-2解析-tsv-数据"><a class="header" href="#场景-2解析-tsv-数据">场景 2：解析 TSV 数据</a></h3>
<pre><code class="language-wpl"># 输入: "2024-01-29\t10:30:45\tERROR\tDatabase connection failed"
rule tsv_log {
    | take(date) \t
    | take(time) \t
    | take(level) \t
    | take(message) \0
}
</code></pre>
<h3 id="场景-3解析-csv-数据"><a class="header" href="#场景-3解析-csv-数据">场景 3：解析 CSV 数据</a></h3>
<pre><code class="language-wpl"># 输入: "John Smith,30,New York,Engineer"
rule csv_parser {
    | take(name) ,
    | take(age) ,
    | take(city) ,
    | take(job) \0
}
</code></pre>
<h3 id="场景-4解析结构化日志"><a class="header" href="#场景-4解析结构化日志">场景 4：解析结构化日志</a></h3>
<pre><code class="language-wpl"># 输入: "level=error | module=database | msg=Connection timeout"
rule structured_log {
    | take(level_prefix) =
    | take(level_value) " | "
    | take(module_prefix) =
    | take(module_value) " | "
    | take(msg_prefix) =
    | take(message) \0
}
</code></pre>
<h3 id="场景-5处理混合空白的日志"><a class="header" href="#场景-5处理混合空白的日志">场景 5：处理混合空白的日志</a></h3>
<pre><code class="language-wpl"># 输入: "192.168.1.1 \tGET\t /api/data"（混合空格和制表符）
rule flexible_whitespace {
    | take(ip) \S
    | take(method) \S
    | take(path) \0
}
</code></pre>
<h3 id="场景-6解析-syslog-格式"><a class="header" href="#场景-6解析-syslog-格式">场景 6：解析 Syslog 格式</a></h3>
<pre><code class="language-wpl"># 输入: "Jan 29 10:30:45 hostname app[1234]: Error message here"
rule syslog {
    | take(month) \s
    | take(day) \s
    | take(time) \s
    | take(hostname) \s
    | take(app_tag) ": "
    | take(message) \0
}
</code></pre>
<h3 id="场景-7解析键值对日志"><a class="header" href="#场景-7解析键值对日志">场景 7：解析键值对日志</a></h3>
<pre><code class="language-wpl"># 输入: "user=admin;action=login;ip=192.168.1.1;status=success"
rule kv_log {
    | take(user_key) =
    | take(user_value) ;
    | take(action_key) =
    | take(action_value) ;
    | take(ip_key) =
    | take(ip_value) ;
    | take(status_key) =
    | take(status_value) \0
}
</code></pre>
<h2 id="分隔符优先级-2"><a class="header" href="#分隔符优先级-2">分隔符优先级</a></h2>
<p>WPL 支持三个级别的分隔符设置：</p>
<h3 id="1-字段级分隔符优先级-3最高"><a class="header" href="#1-字段级分隔符优先级-3最高">1. 字段级分隔符（优先级 3，最高）</a></h3>
<pre><code class="language-wpl">| take(field1) ,  # 该字段使用逗号
| take(field2) \s # 该字段使用空格
</code></pre>
<h3 id="2-组级分隔符优先级-2"><a class="header" href="#2-组级分隔符优先级-2">2. 组级分隔符（优先级 2）</a></h3>
<pre><code class="language-wpl">group {
    sep = \t  # 组内所有字段默认使用制表符
    | take(field1)
    | take(field2)
}
</code></pre>
<h3 id="3-继承分隔符优先级-1最低"><a class="header" href="#3-继承分隔符优先级-1最低">3. 继承分隔符（优先级 1，最低）</a></h3>
<p>从上游规则继承的默认分隔符。</p>
<h3 id="优先级规则-1"><a class="header" href="#优先级规则-1">优先级规则</a></h3>
<p>字段级 &gt; 组级 &gt; 继承级</p>
<pre><code class="language-wpl">group {
    sep = \t         # 组级：制表符
    | take(f1)       # 使用 \t
    | take(f2) ,     # 使用 ,（字段级覆盖组级）
    | take(f3)       # 使用 \t
}
</code></pre>
<h2 id="分隔符行为"><a class="header" href="#分隔符行为">分隔符行为</a></h2>
<h3 id="全局替换-vs-单次匹配"><a class="header" href="#全局替换-vs-单次匹配">全局替换 vs 单次匹配</a></h3>
<p>分隔符只在当前字段结束位置匹配一次：</p>
<pre><code class="language-wpl"># 输入: "hello,world,test"
| take(first) ,   # 读取 "hello"，消费第一个逗号
| take(second) ,  # 读取 "world"，消费第二个逗号
| take(third) \0  # 读取 "test"
</code></pre>
<h3 id="分隔符消费行为"><a class="header" href="#分隔符消费行为">分隔符消费行为</a></h3>
<p>默认情况下，分隔符会被<strong>消费</strong>（从输入中移除）：</p>
<pre><code class="language-wpl"># 输入: "a,b,c"
| take(x) ,  # 读取 "a"，消费 ","，剩余 "b,c"
| take(y) ,  # 读取 "b"，消费 ","，剩余 "c"
</code></pre>
<h3 id="分隔符不存在的情况"><a class="header" href="#分隔符不存在的情况">分隔符不存在的情况</a></h3>
<p>如果到达字符串末尾仍未找到分隔符，读取到末尾：</p>
<pre><code class="language-wpl"># 输入: "field1 field2"
| take(f1) ,  # 未找到逗号，读取全部 "field1 field2"
</code></pre>
<h2 id="高级用法"><a class="header" href="#高级用法">高级用法</a></h2>
<h3 id="组合使用多种分隔符"><a class="header" href="#组合使用多种分隔符">组合使用多种分隔符</a></h3>
<pre><code class="language-wpl"># 输入: "192.168.1.1:8080/api/users?id=123"
rule url_parse {
    | take(ip) :
    | take(port) /
    | take(api_path) /
    | take(resource) ?
    | take(query_string) \0
}
</code></pre>
<h3 id="处理可选字段"><a class="header" href="#处理可选字段">处理可选字段</a></h3>
<pre><code class="language-wpl"># 输入可能是: "user,30,city" 或 "user,,city"（age 为空）
rule optional_fields {
    | take(name) ,
    | take(age) ,      # 可能为空字符串
    | take(city) \0
}
</code></pre>
<h3 id="跳过不需要的字段"><a class="header" href="#跳过不需要的字段">跳过不需要的字段</a></h3>
<pre><code class="language-wpl"># 只提取第 1 和第 3 个字段
rule skip_fields {
    | take(field1) ,
    | take(_skip) ,    # 临时变量，不保存
    | take(field3) \0
}
</code></pre>
<h2 id="使用限制-1"><a class="header" href="#使用限制-1">使用限制</a></h2>
<h3 id="1-分隔符不支持正则表达式"><a class="header" href="#1-分隔符不支持正则表达式">1. 分隔符不支持正则表达式</a></h3>
<pre><code class="language-wpl"># ❌ 不支持正则
| take(field) [0-9]+

# ✅ 使用固定字符串
| take(field) \s
</code></pre>
<h3 id="2-分隔符区分大小写"><a class="header" href="#2-分隔符区分大小写">2. 分隔符区分大小写</a></h3>
<pre><code class="language-wpl"># "ABC" 和 "abc" 是不同的分隔符
| take(field1) ABC
| take(field2) abc
</code></pre>
<h3 id="3-空字符串不能作为分隔符"><a class="header" href="#3-空字符串不能作为分隔符">3. 空字符串不能作为分隔符</a></h3>
<pre><code class="language-wpl"># ❌ 不支持
| take(field) ""

# ✅ 使用 \0 读取到末尾
| take(field) \0
</code></pre>
<h3 id="4-转义字符限制"><a class="header" href="#4-转义字符限制">4. 转义字符限制</a></h3>
<p>当前支持的转义字符：</p>
<ul>
<li><code>\s</code> - 空格</li>
<li><code>\t</code> - 制表符</li>
<li><code>\S</code> - 空格或制表符</li>
<li><code>\0</code> - 行尾</li>
</ul>
<p>其他转义字符（如 <code>\n</code>、<code>\r</code>）需要使用实际字符。</p>
<h2 id="性能说明-1"><a class="header" href="#性能说明-1">性能说明</a></h2>
<h3 id="单字符分隔符"><a class="header" href="#单字符分隔符">单字符分隔符</a></h3>
<p>性能最优，推荐优先使用：</p>
<pre><code class="language-wpl">| take(f1) ,
| take(f2) \s
| take(f3) \t
</code></pre>
<ul>
<li>时间复杂度：O(n)</li>
<li>扫描速度：约 500 MB/s</li>
</ul>
<h3 id="多字符分隔符"><a class="header" href="#多字符分隔符">多字符分隔符</a></h3>
<p>性能略低，但仍然高效：</p>
<pre><code class="language-wpl">| take(f1) " | "
| take(f2) " :: "
</code></pre>
<ul>
<li>时间复杂度：O(n × m)，m 为分隔符长度</li>
<li>扫描速度：约 300-400 MB/s</li>
</ul>
<h3 id="通用空白分隔符-s"><a class="header" href="#通用空白分隔符-s">通用空白分隔符 <code>\S</code></a></h3>
<p>需要逐字符检查，性能介于两者之间：</p>
<pre><code class="language-wpl">| take(f1) \S
</code></pre>
<ul>
<li>时间复杂度：O(n)</li>
<li>扫描速度：约 400 MB/s</li>
</ul>
<h2 id="错误处理-1"><a class="header" href="#错误处理-1">错误处理</a></h2>
<h3 id="常见错误-1"><a class="header" href="#常见错误-1">常见错误</a></h3>
<h4 id="1-分隔符未找到"><a class="header" href="#1-分隔符未找到">1. 分隔符未找到</a></h4>
<pre><code>错误: 未找到分隔符 ','
原因: 输入字符串中不包含指定的分隔符
解决: 检查输入格式或使用 \0 读取到末尾
</code></pre>
<h4 id="2-分隔符语法错误"><a class="header" href="#2-分隔符语法错误">2. 分隔符语法错误</a></h4>
<pre><code>错误: invalid separator
原因: 使用了不支持的分隔符语法
解决: 参考本文档使用正确的分隔符格式
</code></pre>
<h4 id="3-字段顺序错误"><a class="header" href="#3-字段顺序错误">3. 字段顺序错误</a></h4>
<pre><code>错误: 字段解析失败
原因: 字段定义顺序与实际数据不匹配
解决: 调整字段顺序以匹配输入格式
</code></pre>
<h2 id="最佳实践-2"><a class="header" href="#最佳实践-2">最佳实践</a></h2>
<h3 id="1-优先使用内置分隔符"><a class="header" href="#1-优先使用内置分隔符">1. 优先使用内置分隔符</a></h3>
<pre><code class="language-wpl"># ✅ 推荐
| take(f1) \s
| take(f2) \t

# ⚠️ 避免（除非必要）
| take(f1) " "
| take(f2) "\t"
</code></pre>
<h3 id="2-明确指定最后字段的分隔符"><a class="header" href="#2-明确指定最后字段的分隔符">2. 明确指定最后字段的分隔符</a></h3>
<pre><code class="language-wpl"># ✅ 推荐（明确到行尾）
| take(message) \0

# ⚠️ 不清晰
| take(message)  # 依赖默认行为
</code></pre>
<h3 id="3-使用-s-处理不规范数据"><a class="header" href="#3-使用-s-处理不规范数据">3. 使用 <code>\S</code> 处理不规范数据</a></h3>
<pre><code class="language-wpl"># ✅ 推荐（兼容性好）
| take(field1) \S
| take(field2) \S

# ⚠️ 可能失败（如果混合了空格和制表符）
| take(field1) \s
| take(field2) \s
</code></pre>
<h3 id="4-复杂格式使用多字符分隔符"><a class="header" href="#4-复杂格式使用多字符分隔符">4. 复杂格式使用多字符分隔符</a></h3>
<pre><code class="language-wpl"># ✅ 清晰准确
| take(level) " | "
| take(message) " | "

# ⚠️ 可能误匹配
| take(level) |
| take(message) |
</code></pre>
<h3 id="5-组合使用字段级和组级分隔符"><a class="header" href="#5-组合使用字段级和组级分隔符">5. 组合使用字段级和组级分隔符</a></h3>
<pre><code class="language-wpl"># ✅ 推荐（减少重复）
group {
    sep = ,
    | take(f1)
    | take(f2)
    | take(f3) \0  # 最后字段使用不同分隔符
}
</code></pre>
<h2 id="调试技巧-1"><a class="header" href="#调试技巧-1">调试技巧</a></h2>
<h3 id="1-逐字段验证"><a class="header" href="#1-逐字段验证">1. 逐字段验证</a></h3>
<pre><code class="language-wpl"># 先解析第一个字段
| take(field1) ,

# 确认成功后添加第二个
| take(field1) ,
| take(field2) ,

# 依次添加...
</code></pre>
<h3 id="2-使用临时字段查看中间结果"><a class="header" href="#2-使用临时字段查看中间结果">2. 使用临时字段查看中间结果</a></h3>
<pre><code class="language-wpl">| take(field1) ,
| take(_debug) ,    # 临时字段，查看剩余内容
| take(field2) \0
</code></pre>
<h3 id="3-打印分隔符位置"><a class="header" href="#3-打印分隔符位置">3. 打印分隔符位置</a></h3>
<p>在测试环境中，使用调试模式查看分隔符匹配情况：</p>
<pre><code class="language-bash">wp-motor --debug rule.wpl &lt; test.log
</code></pre>
<h3 id="4-验证分隔符字符"><a class="header" href="#4-验证分隔符字符">4. 验证分隔符字符</a></h3>
<p>对于不可见字符（如制表符），使用十六进制查看器确认：</p>
<pre><code class="language-bash"># 查看文件中的制表符
cat -A test.log
# 或
hexdump -C test.log | head
</code></pre>
<h2 id="常见问题-faq-1"><a class="header" href="#常见问题-faq-1">常见问题 (FAQ)</a></h2>
<h3 id="q1-s-和-s-有什么区别"><a class="header" href="#q1-s-和-s-有什么区别">Q1: <code>\s</code> 和 <code>\S</code> 有什么区别？</a></h3>
<ul>
<li><code>\s</code>：只匹配空格 (space)</li>
<li><code>\S</code>：匹配空格或制表符 (space OR tab)</li>
</ul>
<pre><code class="language-wpl"># 输入: "a b"
| take(x) \s  # ✅ 匹配成功

# 输入: "a\tb"
| take(x) \s  # ❌ 匹配失败（这是制表符，不是空格）
| take(x) \S  # ✅ 匹配成功
</code></pre>
<h3 id="q2-如何处理连续的分隔符"><a class="header" href="#q2-如何处理连续的分隔符">Q2: 如何处理连续的分隔符？</a></h3>
<p>WPL 会将连续分隔符视为多个空字段：</p>
<pre><code class="language-wpl"># 输入: "a,,c"
| take(f1) ,  # 读取 "a"
| take(f2) ,  # 读取 ""（空字符串）
| take(f3) \0 # 读取 "c"
</code></pre>
<h3 id="q3-分隔符会影响性能吗"><a class="header" href="#q3-分隔符会影响性能吗">Q3: 分隔符会影响性能吗？</a></h3>
<p>单字符分隔符性能最优，多字符分隔符略慢，但对于大多数场景影响可忽略。</p>
<h3 id="q4-如何解析嵌套结构"><a class="header" href="#q4-如何解析嵌套结构">Q4: 如何解析嵌套结构？</a></h3>
<p>使用多级分隔符：</p>
<pre><code class="language-wpl"># 输入: "k1=v1;k2=v2|k3=v3;k4=v4"
rule nested {
    | take(group1) |
    | take(group2) \0
}
# 然后在每个 group 内再用 ; 和 = 解析
</code></pre>
<h3 id="q5-分隔符可以是中文吗"><a class="header" href="#q5-分隔符可以是中文吗">Q5: 分隔符可以是中文吗？</a></h3>
<p>可以，支持 Unicode 字符：</p>
<pre><code class="language-wpl"># 使用中文逗号分隔
| take(field1) ，
| take(field2) ，
</code></pre>
<h3 id="q6-0-和省略分隔符有区别吗"><a class="header" href="#q6-0-和省略分隔符有区别吗">Q6: <code>\0</code> 和省略分隔符有区别吗？</a></h3>
<p>建议显式使用 <code>\0</code>，语义更清晰：</p>
<pre><code class="language-wpl"># ✅ 推荐（明确）
| take(message) \0

# ⚠️ 可以但不明确
| take(message)
</code></pre>
<h3 id="q7-如何处理引号内的分隔符"><a class="header" href="#q7-如何处理引号内的分隔符">Q7: 如何处理引号内的分隔符？</a></h3>
<p>对于包含引号的复杂格式，建议使用专门的解析器（如 JSON、KV 解析器）：</p>
<pre><code class="language-wpl"># 复杂 CSV（带引号）
# 输入: "field1","field with , comma","field3"
# 建议使用 CSV 解析器而非手动分隔符
</code></pre>
<h2 id="更多资源-1"><a class="header" href="#更多资源-1">更多资源</a></h2>
<ul>
<li><strong>WPL 语法参考</strong>: <code>docs/guide/wpl_syntax.md</code></li>
<li><strong>解析器开发指南</strong>: <code>docs/guide/wpl_field_func_development_guide.md</code></li>
<li><strong>chars_replace 使用指南</strong>: <code>docs/usage/wpl/chars_replace.md</code></li>
<li><strong>源代码</strong>: <code>crates/wp-lang/src/ast/syntax/wpl_sep.rs</code></li>
</ul>
<h2 id="版本历史-2"><a class="header" href="#版本历史-2">版本历史</a></h2>
<ul>
<li>
<p><strong>1.11.0</strong> (2026-01-29)</p>
<ul>
<li>新增 <code>\t</code> 制表符分隔符支持</li>
<li>新增 <code>\S</code> 通用空白分隔符（空格或制表符）</li>
<li>优化 Whitespace 分隔符性能</li>
<li>添加完整的测试覆盖</li>
</ul>
</li>
<li>
<p><strong>1.10.x</strong> 及更早版本</p>
<ul>
<li>支持 <code>\s</code>（空格）和 <code>\0</code>（行尾）</li>
<li>支持自定义字符和字符串分隔符</li>
</ul>
</li>
</ul>
<hr>
<p><strong>提示</strong>: 分隔符是 WPL 解析的核心，选择合适的分隔符可以大大简化日志解析规则。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chars_replace-函数使用指南"><a class="header" href="#chars_replace-函数使用指南">chars_replace 函数使用指南</a></h1>
<h2 id="概述-2"><a class="header" href="#概述-2">概述</a></h2>
<p><code>chars_replace</code> 是 WPL (WP Language) 中的字符串替换函数，用于在日志字段中查找并替换指定的子字符串。</p>
<h2 id="快速开始-2"><a class="header" href="#快速开始-2">快速开始</a></h2>
<h3 id="基本语法-4"><a class="header" href="#基本语法-4">基本语法</a></h3>
<pre><code class="language-wpl">chars_replace(target, replacement)
</code></pre>
<ul>
<li><strong>target</strong>: 要查找并替换的字符串</li>
<li><strong>replacement</strong>: 替换后的新字符串</li>
</ul>
<h3 id="简单示例-2"><a class="header" href="#简单示例-2">简单示例</a></h3>
<pre><code class="language-wpl"># 将 "error" 替换为 "warning"
chars_replace(error, warning)

# 将 "ERROR" 替换为 "WARN"
chars_replace(ERROR, WARN)
</code></pre>
<h2 id="参数格式"><a class="header" href="#参数格式">参数格式</a></h2>
<h3 id="1-不带引号简单标识符"><a class="header" href="#1-不带引号简单标识符">1. 不带引号（简单标识符）</a></h3>
<p>适用于简单的字段名或关键词：</p>
<pre><code class="language-wpl">chars_replace(old_value, new_value)
chars_replace(test-old, test-new)
chars_replace(错误, 警告)
</code></pre>
<p><strong>支持的字符</strong>：</p>
<ul>
<li>字母（a-z, A-Z）</li>
<li>数字（0-9）</li>
<li>下划线（_）</li>
<li>点（.）</li>
<li>斜杠（/）</li>
<li>连字符（-）</li>
<li>Unicode 字符（中文、日文等）</li>
</ul>
<h3 id="2-带引号特殊字符"><a class="header" href="#2-带引号特殊字符">2. 带引号（特殊字符）</a></h3>
<p>适用于包含特殊字符的字符串：</p>
<pre><code class="language-wpl">chars_replace("test,old", "test,new")         # 包含逗号
chars_replace("hello world", "goodbye world") # 包含空格
chars_replace("status=error", "status=ok")    # 包含等号
chars_replace("[ERROR]", "[WARN]")            # 包含方括号
</code></pre>
<p><strong>必须使用引号的场景</strong>：</p>
<ul>
<li>包含逗号（,）</li>
<li>包含空格</li>
<li>包含等号（=）</li>
<li>包含方括号（[]）</li>
<li>包含其他特殊符号</li>
</ul>
<h3 id="3-混合使用"><a class="header" href="#3-混合使用">3. 混合使用</a></h3>
<p>可以混合使用带引号和不带引号的参数：</p>
<pre><code class="language-wpl">chars_replace("test,old", new_value)
chars_replace(old_value, "new,value")
</code></pre>
<h3 id="4-空字符串删除文本"><a class="header" href="#4-空字符串删除文本">4. 空字符串（删除文本）</a></h3>
<p>使用空引号删除目标字符串：</p>
<pre><code class="language-wpl"># 删除 "DEBUG: " 前缀
chars_replace("DEBUG: ", "")

# 删除逗号
chars_replace(",", "")
</code></pre>
<h2 id="实际应用场景-2"><a class="header" href="#实际应用场景-2">实际应用场景</a></h2>
<h3 id="场景-1标准化日志级别"><a class="header" href="#场景-1标准化日志级别">场景 1：标准化日志级别</a></h3>
<pre><code class="language-wpl"># 统一大小写
chars_replace(error, ERROR)
chars_replace(warning, WARNING)

# 标准化格式
chars_replace("[ERROR]", "ERROR:")
chars_replace("[WARN]", "WARNING:")
</code></pre>
<h3 id="场景-2清理日志内容"><a class="header" href="#场景-2清理日志内容">场景 2：清理日志内容</a></h3>
<pre><code class="language-wpl"># 删除调试前缀
chars_replace("DEBUG: ", "")

# 删除多余的空格
chars_replace("  ", " ")

# 删除换行符
chars_replace("\n", " ")
</code></pre>
<h3 id="场景-3url-参数替换"><a class="header" href="#场景-3url-参数替换">场景 3：URL 参数替换</a></h3>
<pre><code class="language-wpl">chars_replace("status=error", "status=ok")
chars_replace("code=500", "code=200")
</code></pre>
<h3 id="场景-4csv-字段处理"><a class="header" href="#场景-4csv-字段处理">场景 4：CSV 字段处理</a></h3>
<pre><code class="language-wpl"># 替换带逗号的名字
chars_replace("Smith, John", "John Smith")
chars_replace("Doe, Jane", "Jane Doe")
</code></pre>
<h3 id="场景-5路径标准化"><a class="header" href="#场景-5路径标准化">场景 5：路径标准化</a></h3>
<pre><code class="language-wpl"># Windows 路径转 Unix 路径
chars_replace("\\", "/")

# 简化路径
chars_replace("/usr/local/", "/opt/")
</code></pre>
<h3 id="场景-6多语言支持"><a class="header" href="#场景-6多语言支持">场景 6：多语言支持</a></h3>
<pre><code class="language-wpl"># 中文替换
chars_replace(错误, 警告)
chars_replace("错误：", "警告：")

# 日文替换
chars_replace(エラー, 警告)
</code></pre>
<h3 id="场景-7敏感信息脱敏"><a class="header" href="#场景-7敏感信息脱敏">场景 7：敏感信息脱敏</a></h3>
<pre><code class="language-wpl"># 替换密码
chars_replace("password=12345", "password=***")

# 替换令牌
chars_replace("token=abc123xyz", "token=***")
</code></pre>
<h2 id="使用限制-2"><a class="header" href="#使用限制-2">使用限制</a></h2>
<h3 id="不支持的特性"><a class="header" href="#不支持的特性">不支持的特性</a></h3>
<ol>
<li>
<p><strong>转义字符</strong>：</p>
<pre><code class="language-wpl"># ❌ 不支持（会解析错误）
chars_replace("say \"hello\"", "say 'hi'")
</code></pre>
</li>
<li>
<p><strong>正则表达式</strong>：</p>
<pre><code class="language-wpl"># ❌ 不支持正则
chars_replace("[0-9]+", "NUMBER")  # 会按字面匹配
</code></pre>
</li>
<li>
<p><strong>通配符</strong>：</p>
<pre><code class="language-wpl"># ❌ 不支持通配符
chars_replace("error*", "warning")  # 会按字面匹配
</code></pre>
</li>
</ol>
<h3 id="类型限制"><a class="header" href="#类型限制">类型限制</a></h3>
<p><code>chars_replace</code> 只能处理<strong>字符串类型</strong>的字段：</p>
<pre><code class="language-wpl"># ✅ 正确 - 字段是字符串
message: "error occurred" -&gt; chars_replace(error, warning)

# ❌ 错误 - 字段是数字
status_code: 500 -&gt; chars_replace(500, 200)  # 会失败

# ❌ 错误 - 字段是 IP 地址
ip_address: 192.168.1.1 -&gt; chars_replace(192, 10)  # 会失败
</code></pre>
<h3 id="替换行为"><a class="header" href="#替换行为">替换行为</a></h3>
<ul>
<li>
<p><strong>全局替换</strong>：替换字段中<strong>所有</strong>匹配的子字符串</p>
<pre><code class="language-wpl"># 输入: "hello hello hello"
chars_replace(hello, hi)
# 输出: "hi hi hi"
</code></pre>
</li>
<li>
<p><strong>大小写敏感</strong>：区分大小写</p>
<pre><code class="language-wpl"># 输入: "Error error ERROR"
chars_replace(error, warning)
# 输出: "Error warning ERROR"  # 只替换小写的 error
</code></pre>
</li>
</ul>
<h2 id="完整示例"><a class="header" href="#完整示例">完整示例</a></h2>
<h3 id="示例-1日志级别标准化流水线"><a class="header" href="#示例-1日志级别标准化流水线">示例 1：日志级别标准化流水线</a></h3>
<pre><code class="language-wpl">rule log_normalization {
    # 标准化不同格式的 ERROR
    | chars_replace("[ERROR]", "ERROR:")
    | chars_replace("ERR:", "ERROR:")
    | chars_replace("Err:", "ERROR:")

    # 标准化 WARNING
    | chars_replace("[WARN]", "WARNING:")
    | chars_replace("Warn:", "WARNING:")

    # 删除调试信息
    | chars_replace("DEBUG: ", "")
}
</code></pre>
<h3 id="示例-2csv-数据清理"><a class="header" href="#示例-2csv-数据清理">示例 2：CSV 数据清理</a></h3>
<pre><code class="language-wpl">rule csv_cleanup {
    # 标准化姓名格式（从 "Last, First" 到 "First Last"）
    | chars_replace("Smith, John", "John Smith")
    | chars_replace("Doe, Jane", "Jane Doe")

    # 删除多余的引号
    | chars_replace("\"", "")

    # 标准化分隔符
    | chars_replace(";", ",")
}
</code></pre>
<h3 id="示例-3多步骤替换"><a class="header" href="#示例-3多步骤替换">示例 3：多步骤替换</a></h3>
<pre><code class="language-wpl">rule multi_step_replace {
    # 第一步：替换日志级别
    | chars_replace(error, ERROR)

    # 第二步：添加时间戳前缀（通过替换空字符串）
    | chars_replace("", "[2024-01-29] ")

    # 第三步：替换服务名
    | chars_replace(old-service, new-service)
}
</code></pre>
<h2 id="性能说明-2"><a class="header" href="#性能说明-2">性能说明</a></h2>
<ul>
<li><strong>时间复杂度</strong>：O(n) - n 为字段长度</li>
<li><strong>空间复杂度</strong>：O(n) - 需要创建新字符串</li>
<li><strong>性能建议</strong>：
<ul>
<li>短字符串（&lt; 1KB）：性能优秀，延迟 &lt; 1μs</li>
<li>长字符串（1-10KB）：仍然快速，延迟 &lt; 10μs</li>
<li>超长字符串（&gt; 10KB）：考虑性能影响</li>
</ul>
</li>
</ul>
<h2 id="错误处理-2"><a class="header" href="#错误处理-2">错误处理</a></h2>
<h3 id="常见错误-2"><a class="header" href="#常见错误-2">常见错误</a></h3>
<ol>
<li>
<p><strong>字段不存在</strong></p>
<pre><code>错误: chars_replace | no active field
原因: 当前没有活动字段
解决: 使用 take() 或其他选择器先选择字段
</code></pre>
</li>
<li>
<p><strong>字段类型不匹配</strong></p>
<pre><code>错误: chars_replace
原因: 字段不是字符串类型
解决: 确保字段是 Chars 类型
</code></pre>
</li>
<li>
<p><strong>语法错误</strong></p>
<pre><code>错误: invalid symbol, expected need ','
原因: 包含逗号的参数未使用引号
解决: 使用引号包裹参数
</code></pre>
</li>
</ol>
<h2 id="与其他函数配合使用"><a class="header" href="#与其他函数配合使用">与其他函数配合使用</a></h2>
<h3 id="与字段选择器配合"><a class="header" href="#与字段选择器配合">与字段选择器配合</a></h3>
<pre><code class="language-wpl"># 先选择字段，再替换
| take(message)
| chars_replace(error, warning)
</code></pre>
<h3 id="与条件检查配合"><a class="header" href="#与条件检查配合">与条件检查配合</a></h3>
<pre><code class="language-wpl"># 只在特定条件下替换
| chars_has(error)
| chars_replace(error, warning)
</code></pre>
<h3 id="与转换函数配合"><a class="header" href="#与转换函数配合">与转换函数配合</a></h3>
<pre><code class="language-wpl"># 先解码 Base64，再替换
| base64_decode()
| chars_replace(old_value, new_value)
</code></pre>
<h2 id="最佳实践-3"><a class="header" href="#最佳实践-3">最佳实践</a></h2>
<h3 id="1-优先使用不带引号的格式"><a class="header" href="#1-优先使用不带引号的格式">1. 优先使用不带引号的格式</a></h3>
<pre><code class="language-wpl"># ✅ 推荐（简洁）
chars_replace(error, warning)

# ⚠️ 可以但不必要
chars_replace("error", "warning")
</code></pre>
<h3 id="2-复杂字符串使用引号"><a class="header" href="#2-复杂字符串使用引号">2. 复杂字符串使用引号</a></h3>
<pre><code class="language-wpl"># ✅ 正确
chars_replace("status=error", "status=ok")

# ❌ 错误（语法错误）
chars_replace(status=error, status=ok)
</code></pre>
<h3 id="3-空字符串删除文本"><a class="header" href="#3-空字符串删除文本">3. 空字符串删除文本</a></h3>
<pre><code class="language-wpl"># ✅ 推荐（明确意图）
chars_replace("DEBUG: ", "")

# ⚠️ 不清晰
chars_replace("DEBUG: ", nothing)  # 不存在 nothing 关键字
</code></pre>
<h3 id="4-按顺序执行多次替换"><a class="header" href="#4-按顺序执行多次替换">4. 按顺序执行多次替换</a></h3>
<pre><code class="language-wpl"># ✅ 正确（逐步替换）
| chars_replace(error, ERROR)
| chars_replace(ERROR, WARNING)
# 结果: error -&gt; ERROR -&gt; WARNING

# ⚠️ 注意顺序
| chars_replace(ERROR, WARNING)
| chars_replace(error, ERROR)
# 结果: error -&gt; ERROR（第二步不会再变成 WARNING）
</code></pre>
<h3 id="5-测试边界情况"><a class="header" href="#5-测试边界情况">5. 测试边界情况</a></h3>
<pre><code class="language-wpl"># 测试空字符串
chars_replace("", "prefix")  # 在每个字符间插入

# 测试单字符
chars_replace(",", ";")      # 简单替换

# 测试长字符串
chars_replace("very long string to find", "replacement")
</code></pre>
<h2 id="调试技巧-2"><a class="header" href="#调试技巧-2">调试技巧</a></h2>
<h3 id="1-逐步测试"><a class="header" href="#1-逐步测试">1. 逐步测试</a></h3>
<pre><code class="language-wpl"># 第一步：只做替换
| chars_replace(error, warning)

# 第二步：添加更多替换
| chars_replace(error, warning)
| chars_replace(warning, info)
</code></pre>
<h3 id="2-检查字段类型"><a class="header" href="#2-检查字段类型">2. 检查字段类型</a></h3>
<pre><code class="language-wpl"># 使用 has() 确认字段存在
| has()

# 使用 chars_has() 确认是字符串类型
| chars_has(some_value)
</code></pre>
<h3 id="3-查看替换结果"><a class="header" href="#3-查看替换结果">3. 查看替换结果</a></h3>
<p>在测试环境中打印替换前后的值：</p>
<pre><code class="language-bash"># 使用 WP-Motor 的调试模式
wp-motor --debug rule.wpl &lt; test.log
</code></pre>
<h2 id="常见问题-faq-2"><a class="header" href="#常见问题-faq-2">常见问题 (FAQ)</a></h2>
<h3 id="q1-如何替换换行符"><a class="header" href="#q1-如何替换换行符">Q1: 如何替换换行符？</a></h3>
<pre><code class="language-wpl"># 方法 1：使用实际的换行符（如果解析器支持）
chars_replace("\n", " ")

# 方法 2：根据实际编码处理
chars_replace("
", " ")  # 实际换行
</code></pre>
<h3 id="q2-如何同时替换多个不同的字符串"><a class="header" href="#q2-如何同时替换多个不同的字符串">Q2: 如何同时替换多个不同的字符串？</a></h3>
<pre><code class="language-wpl"># 使用多个 chars_replace 调用
| chars_replace(error, ERROR)
| chars_replace(warning, WARNING)
| chars_replace(info, INFO)
</code></pre>
<h3 id="q3-如何实现大小写不敏感的替换"><a class="header" href="#q3-如何实现大小写不敏感的替换">Q3: 如何实现大小写不敏感的替换？</a></h3>
<p>chars_replace 是大小写敏感的，需要多次调用：</p>
<pre><code class="language-wpl">| chars_replace(error, ERROR)
| chars_replace(Error, ERROR)
| chars_replace(ERROR, ERROR)
</code></pre>
<h3 id="q4-替换会修改原始字段吗"><a class="header" href="#q4-替换会修改原始字段吗">Q4: 替换会修改原始字段吗？</a></h3>
<p>是的，chars_replace 会直接修改活动字段的值。</p>
<h3 id="q5-性能够用吗"><a class="header" href="#q5-性能够用吗">Q5: 性能够用吗？</a></h3>
<p>对于大多数日志处理场景，性能完全足够：</p>
<ul>
<li>单条日志 &lt; 10KB：几乎无感知</li>
<li>高吞吐量场景：可处理 100K+ 日志/秒</li>
</ul>
<h2 id="更多资源-2"><a class="header" href="#更多资源-2">更多资源</a></h2>
<ul>
<li><strong>开发指南</strong>: <code>docs/guide/wpl_field_func_development_guide.md</code></li>
<li><strong>解析器实现</strong>: <code>docs/guide/chars_replace_parser_tests.md</code></li>
<li><strong>性能分析</strong>: <code>docs/guide/take_quoted_string_performance.md</code></li>
<li><strong>源代码</strong>: <code>crates/wp-lang/src/ast/processor/function.rs</code></li>
</ul>
<h2 id="版本历史-3"><a class="header" href="#版本历史-3">版本历史</a></h2>
<ul>
<li><strong>1.11.0</strong> (2026-01-29)
<ul>
<li>初始实现</li>
<li>支持基本字符串替换</li>
<li>支持带引号字符串（包含逗号、空格等）</li>
<li>添加完整的测试覆盖</li>
</ul>
</li>
</ul>
<hr>
<p><strong>提示</strong>: 如果您在使用过程中遇到问题，请参考错误处理章节或查看开发指南。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="regex_match-函数使用指南"><a class="header" href="#regex_match-函数使用指南">regex_match 函数使用指南</a></h1>
<h2 id="概述-3"><a class="header" href="#概述-3">概述</a></h2>
<p><code>regex_match</code> 是 WPL (WP Language) 中的正则表达式匹配函数，用于检查日志字段的字符串内容是否匹配指定的正则表达式模式。使用 Rust 的 regex 引擎，支持完整的正则表达式语法。</p>
<h2 id="快速开始-3"><a class="header" href="#快速开始-3">快速开始</a></h2>
<h3 id="基本语法-5"><a class="header" href="#基本语法-5">基本语法</a></h3>
<pre><code class="language-wpl">regex_match('pattern')
</code></pre>
<ul>
<li><strong>pattern</strong>: 正则表达式模式（推荐使用<strong>单引号</strong>）</li>
<li>匹配成功返回 Ok，失败返回 Err</li>
</ul>
<h3 id="简单示例-3"><a class="header" href="#简单示例-3">简单示例</a></h3>
<pre><code class="language-wpl"># 匹配纯数字
regex_match('^\d+$')

# 匹配邮箱格式
regex_match('^\w+@\w+\.\w+$')

# 匹配 IP 地址
regex_match('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$')

# 匹配 HTTP 方法
regex_match('^(GET|POST|PUT|DELETE)$')
</code></pre>
<h2 id="重要提示引号使用"><a class="header" href="#重要提示引号使用">重要提示：引号使用</a></h2>
<h3 id="推荐使用单引号原始字符串"><a class="header" href="#推荐使用单引号原始字符串">推荐：使用单引号（原始字符串）</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：单引号不处理转义，适合正则表达式
regex_match('^\d+$')           # \d 保持原样
regex_match('^\w+@\w+\.\w+$')  # \w, \. 保持原样
regex_match('^[A-Z]+\d+$')     # 完美工作
</code></pre>
<h3 id="避免双引号会导致转义问题"><a class="header" href="#避免双引号会导致转义问题">避免：双引号会导致转义问题</a></h3>
<pre><code class="language-wpl"># ❌ 错误：双引号会尝试转义 \d
regex_match("^\d+$")  # 解析失败！\d 不是有效的转义序列

# ❌ 错误：\w 也会失败
regex_match("^\w+$")  # 解析失败！
</code></pre>
<p><strong>原因</strong>：WPL 的双引号字符串解析器只支持 <code>\"</code>, <code>\\</code>, <code>\n</code>, <code>\t</code> 这几种转义字符，而正则表达式中的 <code>\d</code>, <code>\w</code>, <code>\s</code> 等会导致解析错误。</p>
<h2 id="正则表达式语法"><a class="header" href="#正则表达式语法">正则表达式语法</a></h2>
<p><code>regex_match</code> 使用 Rust regex 引擎，支持以下特性：</p>
<h3 id="1-基本匹配"><a class="header" href="#1-基本匹配">1. 基本匹配</a></h3>
<pre><code class="language-wpl"># 字面字符
regex_match('hello')          # 匹配 "hello"
regex_match('error')          # 匹配 "error"
</code></pre>
<h3 id="2-字符类"><a class="header" href="#2-字符类">2. 字符类</a></h3>
<pre><code class="language-wpl"># 数字
regex_match('\d')             # 匹配任意数字 [0-9]
regex_match('\d+')            # 匹配一个或多个数字
regex_match('\d{3}')          # 匹配恰好3个数字

# 字母和数字
regex_match('\w')             # 匹配 [a-zA-Z0-9_]
regex_match('\w+')            # 匹配一个或多个单词字符

# 空白字符
regex_match('\s')             # 匹配空格、制表符、换行符
regex_match('\s+')            # 匹配一个或多个空白字符

# 自定义字符类
regex_match('[a-z]')          # 匹配小写字母
regex_match('[A-Z]')          # 匹配大写字母
regex_match('[0-9]')          # 匹配数字
regex_match('[a-zA-Z0-9]')    # 匹配字母或数字
</code></pre>
<h3 id="3-量词"><a class="header" href="#3-量词">3. 量词</a></h3>
<pre><code class="language-wpl"># * - 0次或多次
regex_match('a*')             # 匹配 "", "a", "aa", "aaa"...

# + - 1次或多次
regex_match('a+')             # 匹配 "a", "aa", "aaa"... (不匹配空串)

# ? - 0次或1次
regex_match('colou?r')        # 匹配 "color" 或 "colour"

# {n} - 恰好n次
regex_match('\d{4}')          # 匹配4位数字

# {n,m} - n到m次
regex_match('\d{2,4}')        # 匹配2到4位数字

# {n,} - 至少n次
regex_match('\d{3,}')         # 匹配3位或更多数字
</code></pre>
<h3 id="4-锚点"><a class="header" href="#4-锚点">4. 锚点</a></h3>
<pre><code class="language-wpl"># ^ - 字符串开始
regex_match('^\d+')           # 必须以数字开头

# $ - 字符串结束
regex_match('\d+$')           # 必须以数字结尾

# ^...$ - 完全匹配
regex_match('^\d+$')          # 整个字符串必须是数字
</code></pre>
<h3 id="5-分组和选择"><a class="header" href="#5-分组和选择">5. 分组和选择</a></h3>
<pre><code class="language-wpl"># (...) - 分组
regex_match('(ab)+')          # 匹配 "ab", "abab", "ababab"...

# | - 选择（或）
regex_match('cat|dog')        # 匹配 "cat" 或 "dog"
regex_match('^(GET|POST)$')   # 匹配 "GET" 或 "POST"

# (?:...) - 非捕获分组
regex_match('(?:ab)+')        # 与 (ab)+ 功能相同，但不捕获
</code></pre>
<h3 id="6-特殊字符转义"><a class="header" href="#6-特殊字符转义">6. 特殊字符转义</a></h3>
<pre><code class="language-wpl"># 转义元字符
regex_match('\.')             # 匹配点号 .
regex_match('\[')             # 匹配左方括号 [
regex_match('\(')             # 匹配左括号 (
regex_match('\$')             # 匹配美元符号 $
regex_match('\*')             # 匹配星号 *
</code></pre>
<h3 id="7-标志"><a class="header" href="#7-标志">7. 标志</a></h3>
<pre><code class="language-wpl"># (?i) - 大小写不敏感
regex_match('(?i)error')      # 匹配 "error", "ERROR", "Error"

# (?m) - 多行模式
regex_match('(?m)^line')      # ^ 匹配每行开始

# (?s) - 单行模式（. 匹配换行符）
regex_match('(?s).*')         # . 可以匹配换行符
</code></pre>
<h2 id="实际应用场景-3"><a class="header" href="#实际应用场景-3">实际应用场景</a></h2>
<h3 id="场景-1日志级别匹配"><a class="header" href="#场景-1日志级别匹配">场景 1：日志级别匹配</a></h3>
<pre><code class="language-wpl">rule log_level_filter {
    # 选择日志消息字段
    | take(message)

    # 匹配包含 ERROR 或 FATAL 的消息（大小写不敏感）
    | regex_match('(?i)(error|fatal)')
}

# 示例数据：
# message: "Error occurred"     → ✅ 匹配
# message: "FATAL exception"    → ✅ 匹配
# message: "Warning message"    → ❌ 不匹配
</code></pre>
<h3 id="场景-2邮箱地址验证"><a class="header" href="#场景-2邮箱地址验证">场景 2：邮箱地址验证</a></h3>
<pre><code class="language-wpl">rule email_validation {
    # 选择邮箱字段
    | take(email)

    # 验证邮箱格式
    | regex_match('^\w+(\.\w+)*@\w+(\.\w+)+$')
}

# 示例数据：
# email: "user@example.com"           → ✅ 匹配
# email: "john.doe@company.co.uk"     → ✅ 匹配
# email: "invalid-email"              → ❌ 不匹配
# email: "@example.com"               → ❌ 不匹配
</code></pre>
<h3 id="场景-3ip-地址匹配"><a class="header" href="#场景-3ip-地址匹配">场景 3：IP 地址匹配</a></h3>
<pre><code class="language-wpl">rule ip_address_filter {
    # 选择 IP 地址字段
    | take(client_ip)

    # 匹配内网 IP（192.168.x.x）
    | regex_match('^192\.168\.\d{1,3}\.\d{1,3}$')
}

# 示例数据：
# client_ip: "192.168.1.1"    → ✅ 匹配
# client_ip: "192.168.0.100"  → ✅ 匹配
# client_ip: "10.0.0.1"       → ❌ 不匹配
# client_ip: "8.8.8.8"        → ❌ 不匹配
</code></pre>
<h3 id="场景-4url-路径过滤"><a class="header" href="#场景-4url-路径过滤">场景 4：URL 路径过滤</a></h3>
<pre><code class="language-wpl">rule api_endpoint_filter {
    # 选择请求路径
    | take(path)

    # 匹配 API 端点（/api/v1/...）
    | regex_match('^/api/v\d+/')
}

# 示例数据：
# path: "/api/v1/users"         → ✅ 匹配
# path: "/api/v2/products"      → ✅ 匹配
# path: "/static/image.png"     → ❌ 不匹配
</code></pre>
<h3 id="场景-5时间戳格式验证"><a class="header" href="#场景-5时间戳格式验证">场景 5：时间戳格式验证</a></h3>
<pre><code class="language-wpl">rule timestamp_validation {
    # 选择时间戳字段
    | take(timestamp)

    # 匹配 ISO 8601 格式（YYYY-MM-DD HH:MM:SS）
    | regex_match('^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$')
}

# 示例数据：
# timestamp: "2024-01-29 15:30:45"  → ✅ 匹配
# timestamp: "2024-1-9 5:3:5"       → ❌ 不匹配（缺少前导零）
# timestamp: "29/01/2024 15:30"     → ❌ 不匹配（格式不同）
</code></pre>
<h3 id="场景-6http-方法验证"><a class="header" href="#场景-6http-方法验证">场景 6：HTTP 方法验证</a></h3>
<pre><code class="language-wpl">rule http_method_check {
    # 选择 HTTP 方法字段
    | take(method)

    # 只接受安全的 HTTP 方法
    | regex_match('^(GET|HEAD|OPTIONS)$')
}

# 示例数据：
# method: "GET"     → ✅ 匹配
# method: "HEAD"    → ✅ 匹配
# method: "POST"    → ❌ 不匹配
# method: "DELETE"  → ❌ 不匹配
</code></pre>
<h3 id="场景-7版本号匹配"><a class="header" href="#场景-7版本号匹配">场景 7：版本号匹配</a></h3>
<pre><code class="language-wpl">rule version_check {
    # 选择版本字段
    | take(version)

    # 匹配语义化版本号（如 1.2.3）
    | regex_match('^\d+\.\d+\.\d+$')
}

# 示例数据：
# version: "1.0.0"     → ✅ 匹配
# version: "2.10.5"    → ✅ 匹配
# version: "1.0"       → ❌ 不匹配（缺少补丁版本）
# version: "v1.2.3"    → ❌ 不匹配（有前缀）
</code></pre>
<h3 id="场景-8sql-注入检测"><a class="header" href="#场景-8sql-注入检测">场景 8：SQL 注入检测</a></h3>
<pre><code class="language-wpl">rule sql_injection_detection {
    # 选择用户输入字段
    | take(user_input)

    # 检测常见的 SQL 注入模式
    | regex_match('(?i)(union|select|insert|update|delete|drop|;|--|\|)')
}

# 示例数据：
# user_input: "SELECT * FROM users"  → ✅ 匹配（检测到）
# user_input: "'; DROP TABLE --"     → ✅ 匹配（检测到）
# user_input: "normal search query"  → ❌ 不匹配（安全）
</code></pre>
<h3 id="场景-9文件扩展名过滤"><a class="header" href="#场景-9文件扩展名过滤">场景 9：文件扩展名过滤</a></h3>
<pre><code class="language-wpl">rule image_file_filter {
    # 选择文件名字段
    | take(filename)

    # 只匹配图片文件
    | regex_match('\.(?i)(jpg|jpeg|png|gif|bmp|svg)$')
}

# 示例数据：
# filename: "photo.jpg"      → ✅ 匹配
# filename: "image.PNG"      → ✅ 匹配（大小写不敏感）
# filename: "document.pdf"   → ❌ 不匹配
</code></pre>
<h3 id="场景-10mac-地址验证"><a class="header" href="#场景-10mac-地址验证">场景 10：MAC 地址验证</a></h3>
<pre><code class="language-wpl">rule mac_address_validation {
    # 选择 MAC 地址字段
    | take(mac)

    # 匹配 MAC 地址格式（XX:XX:XX:XX:XX:XX）
    | regex_match('^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$')
}

# 示例数据：
# mac: "00:1B:44:11:3A:B7"  → ✅ 匹配
# mac: "AA:BB:CC:DD:EE:FF"  → ✅ 匹配
# mac: "invalid-mac"        → ❌ 不匹配
</code></pre>
<h2 id="使用限制-3"><a class="header" href="#使用限制-3">使用限制</a></h2>
<h3 id="类型限制-1"><a class="header" href="#类型限制-1">类型限制</a></h3>
<p><code>regex_match</code> 只能处理<strong>字符串类型</strong>的字段：</p>
<pre><code class="language-wpl"># ✅ 正确 - 字段是字符串
message: "error occurred" -&gt; regex_match('error')

# ❌ 错误 - 字段是数字
status_code: 404 -&gt; regex_match('\d+')  # 会失败

# ❌ 错误 - 字段是 IP 地址（非字符串类型）
ip: 192.168.1.1 -&gt; regex_match('\d+')  # 会失败
</code></pre>
<h3 id="性能考虑"><a class="header" href="#性能考虑">性能考虑</a></h3>
<ol>
<li>
<p><strong>正则表达式编译开销</strong>：</p>
<ul>
<li>每次调用都会重新编译正则表达式</li>
<li>复杂的正则表达式编译可能需要几微秒</li>
</ul>
</li>
<li>
<p><strong>匹配性能</strong>：</p>
<ul>
<li>简单模式：微秒级</li>
<li>复杂模式（大量回溯）：可能较慢</li>
<li>建议：避免过度复杂的正则表达式</li>
</ul>
</li>
<li>
<p><strong>优化建议</strong>：</p>
<pre><code class="language-wpl"># ✅ 推荐：简单直接的模式
regex_match('^\d{4}$')

# ⚠️ 慎用：复杂的回溯模式
regex_match('^(a+)+b$')  # 可能导致性能问题
</code></pre>
</li>
</ol>
<h3 id="不支持的特性-1"><a class="header" href="#不支持的特性-1">不支持的特性</a></h3>
<ol>
<li>
<p><strong>不支持命名捕获组</strong>：</p>
<pre><code class="language-wpl"># ❌ 不支持（无法提取捕获的内容）
regex_match('(?P&lt;year&gt;\d{4})')
</code></pre>
</li>
<li>
<p><strong>不支持替换</strong>：</p>
<pre><code class="language-wpl"># ❌ regex_match 只做匹配，不做替换
# 需要替换请使用 chars_replace
</code></pre>
</li>
<li>
<p><strong>不支持多个模式</strong>：</p>
<pre><code class="language-wpl"># ❌ 不能传递多个模式
regex_match('pattern1', 'pattern2')

# ✅ 使用选择符 |
regex_match('pattern1|pattern2')
</code></pre>
</li>
</ol>
<h2 id="完整示例-1"><a class="header" href="#完整示例-1">完整示例</a></h2>
<h3 id="示例-1日志分类流水线"><a class="header" href="#示例-1日志分类流水线">示例 1：日志分类流水线</a></h3>
<pre><code class="language-wpl">rule log_classification {
    # 选择日志消息
    | take(message)

    # 分类为错误日志
    (
        | regex_match('(?i)(error|exception|failed|fatal)')
        | tag(level, ERROR)
    )
    |
    # 或分类为警告日志
    (
        | regex_match('(?i)(warn|warning|deprecated)')
        | tag(level, WARNING)
    )
    |
    # 或分类为普通日志
    (
        | tag(level, INFO)
    )
}
</code></pre>
<h3 id="示例-2安全审计过滤"><a class="header" href="#示例-2安全审计过滤">示例 2：安全审计过滤</a></h3>
<pre><code class="language-wpl">rule security_audit {
    # 检查用户输入中的危险模式
    | take(user_input)

    # 检测脚本注入
    | regex_match('(?i)(&lt;script|javascript:|onerror=)')

    # 或检测 SQL 注入
    | regex_match('(?i)(union|select.*from|insert.*into)')

    # 或检测路径遍历
    | regex_match('(\.\./|\.\.\\)')

    # 匹配到任何一个就记录为安全事件
    | tag(security_event, true)
}
</code></pre>
<h3 id="示例-3结构化日志解析"><a class="header" href="#示例-3结构化日志解析">示例 3：结构化日志解析</a></h3>
<pre><code class="language-wpl">rule structured_log_parsing {
    # 验证 JSON 日志格式
    | take(raw_message)
    | regex_match('^\{.*\}$')

    # 验证包含必需字段
    | regex_match('"timestamp":\s*"\d{4}-\d{2}-\d{2}')
    | regex_match('"level":\s*"(INFO|WARN|ERROR)"')
    | regex_match('"message":\s*"[^"]+"')

    # 所有验证通过后继续处理
}
</code></pre>
<h2 id="性能说明-3"><a class="header" href="#性能说明-3">性能说明</a></h2>
<ul>
<li><strong>正则编译</strong>：每次调用都会编译，建议使用简单模式</li>
<li><strong>匹配速度</strong>：
<ul>
<li>简单模式（如 <code>^\d+$</code>）：&lt; 1μs</li>
<li>中等复杂度（如邮箱验证）：1-10μs</li>
<li>复杂模式（大量回溯）：可能 &gt; 100μs</li>
</ul>
</li>
<li><strong>内存开销</strong>：每个正则表达式约 1-10KB</li>
</ul>
<h2 id="错误处理-3"><a class="header" href="#错误处理-3">错误处理</a></h2>
<h3 id="常见错误-3"><a class="header" href="#常见错误-3">常见错误</a></h3>
<ol>
<li>
<p><strong>无效的正则表达式</strong></p>
<pre><code>错误: regex_match | invalid regex pattern
原因: 正则表达式语法错误
解决: 检查正则表达式语法
</code></pre>
</li>
<li>
<p><strong>字段不存在</strong></p>
<pre><code>错误: regex_match | no active field
原因: 当前没有活动字段
解决: 使用 take() 先选择字段
</code></pre>
</li>
<li>
<p><strong>字段类型不匹配</strong></p>
<pre><code>错误: regex_match | field is not a string
原因: 字段不是字符串类型
解决: 确保字段是 Chars 类型
</code></pre>
</li>
<li>
<p><strong>模式不匹配</strong></p>
<pre><code>错误: regex_match | not matched
原因: 字段内容不匹配正则表达式
解决: 这是正常的过滤逻辑
</code></pre>
</li>
</ol>
<h2 id="与其他函数配合使用-1"><a class="header" href="#与其他函数配合使用-1">与其他函数配合使用</a></h2>
<h3 id="与字段选择器配合-1"><a class="header" href="#与字段选择器配合-1">与字段选择器配合</a></h3>
<pre><code class="language-wpl"># 先选择字段，再匹配
| take(message)
| regex_match('error')
</code></pre>
<h3 id="与条件检查配合-1"><a class="header" href="#与条件检查配合-1">与条件检查配合</a></h3>
<pre><code class="language-wpl"># 组合多个条件
| take(status)
| regex_match('^[45]\d{2}$')  # 4xx 或 5xx
</code></pre>
<h3 id="与-chars_replace-配合"><a class="header" href="#与-chars_replace-配合">与 chars_replace 配合</a></h3>
<pre><code class="language-wpl"># 先匹配，再替换
| regex_match('error')
| chars_replace(error, ERROR)
</code></pre>
<h3 id="与分支逻辑配合"><a class="header" href="#与分支逻辑配合">与分支逻辑配合</a></h3>
<pre><code class="language-wpl"># 不同模式走不同分支
(
    | regex_match('^2\d{2}$')  # 2xx
    | tag(status_class, success)
)
|
(
    | regex_match('^4\d{2}$')  # 4xx
    | tag(status_class, client_error)
)
</code></pre>
<h2 id="最佳实践-4"><a class="header" href="#最佳实践-4">最佳实践</a></h2>
<h3 id="1-优先使用单引号"><a class="header" href="#1-优先使用单引号">1. 优先使用单引号</a></h3>
<pre><code class="language-wpl"># ✅ 推荐
regex_match('^\d+$')

# ❌ 避免（会导致解析错误）
regex_match("^\d+$")
</code></pre>
<h3 id="2-使用锚点明确匹配范围"><a class="header" href="#2-使用锚点明确匹配范围">2. 使用锚点明确匹配范围</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：完全匹配
regex_match('^\d{4}$')  # 恰好4位数字

# ⚠️ 可能不符合预期：部分匹配
regex_match('\d{4}')    # 包含4位数字即可
</code></pre>
<h3 id="3-简化正则表达式"><a class="header" href="#3-简化正则表达式">3. 简化正则表达式</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：简单清晰
regex_match('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$')

# ⚠️ 过度复杂
regex_match('^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$')
</code></pre>
<h3 id="4-使用注释文档化复杂模式"><a class="header" href="#4-使用注释文档化复杂模式">4. 使用注释文档化复杂模式</a></h3>
<pre><code class="language-wpl"># 匹配邮箱：用户名@域名.后缀
regex_match('^\w+@\w+\.\w+$')
</code></pre>
<h3 id="5-测试边界情况-1"><a class="header" href="#5-测试边界情况-1">5. 测试边界情况</a></h3>
<pre><code class="language-wpl"># 测试模式的边界
regex_match('^\d{2,4}$')
# 测试：1 ❌, 12 ✅, 123 ✅, 1234 ✅, 12345 ❌
</code></pre>
<h2 id="正则表达式测试"><a class="header" href="#正则表达式测试">正则表达式测试</a></h2>
<h3 id="在线测试工具"><a class="header" href="#在线测试工具">在线测试工具</a></h3>
<ol>
<li>
<p><strong>regex101.com</strong></p>
<ul>
<li>选择 Rust flavor</li>
<li>测试你的正则表达式</li>
<li>查看匹配详情和性能</li>
</ul>
</li>
<li>
<p><strong>regexr.com</strong></p>
<ul>
<li>可视化匹配过程</li>
<li>提供备忘清单</li>
</ul>
</li>
</ol>
<h3 id="命令行测试"><a class="header" href="#命令行测试">命令行测试</a></h3>
<pre><code class="language-bash"># 使用 WP-Motor 测试
echo "test_value: 12345" | wp-motor test.wpl

# 查看匹配结果
wp-motor --debug test.wpl &lt; test_data.log
</code></pre>
<h2 id="常见问题-faq-3"><a class="header" href="#常见问题-faq-3">常见问题 (FAQ)</a></h2>
<h3 id="q1-为什么必须使用单引号"><a class="header" href="#q1-为什么必须使用单引号">Q1: 为什么必须使用单引号？</a></h3>
<p>因为 WPL 的双引号字符串解析器只支持有限的转义序列（<code>\"</code>, <code>\\</code>, <code>\n</code>, <code>\t</code>），而正则表达式需要 <code>\d</code>, <code>\w</code>, <code>\s</code> 等，这些会导致解析失败。</p>
<h3 id="q2-如何匹配点号"><a class="header" href="#q2-如何匹配点号">Q2: 如何匹配点号（.）？</a></h3>
<pre><code class="language-wpl"># 使用反斜杠转义
regex_match('\.')  # 匹配字面的点号
</code></pre>
<h3 id="q3-如何实现大小写不敏感匹配"><a class="header" href="#q3-如何实现大小写不敏感匹配">Q3: 如何实现大小写不敏感匹配？</a></h3>
<pre><code class="language-wpl"># 使用 (?i) 标志
regex_match('(?i)error')  # 匹配 error, ERROR, Error
</code></pre>
<h3 id="q4-正则表达式是完全匹配还是部分匹配"><a class="header" href="#q4-正则表达式是完全匹配还是部分匹配">Q4: 正则表达式是完全匹配还是部分匹配？</a></h3>
<p>默认是<strong>部分匹配</strong>。使用 <code>^</code> 和 <code>$</code> 实现完全匹配：</p>
<pre><code class="language-wpl"># 部分匹配
regex_match('\d+')     # "abc123def" → ✅ 匹配

# 完全匹配
regex_match('^\d+$')   # "abc123def" → ❌ 不匹配
</code></pre>
<h3 id="q5-如何匹配多行文本"><a class="header" href="#q5-如何匹配多行文本">Q5: 如何匹配多行文本？</a></h3>
<pre><code class="language-wpl"># 使用 (?m) 多行模式
regex_match('(?m)^ERROR')  # 匹配任意行开头的 ERROR

# 使用 (?s) 单行模式让 . 匹配换行符
regex_match('(?s)start.*end')  # 跨行匹配
</code></pre>
<h3 id="q6-性能如何"><a class="header" href="#q6-性能如何">Q6: 性能如何？</a></h3>
<ul>
<li>简单模式：非常快（微秒级）</li>
<li>复杂模式：可能较慢</li>
<li>建议：避免过度复杂的回溯模式</li>
</ul>
<h3 id="q7-能否提取匹配的内容"><a class="header" href="#q7-能否提取匹配的内容">Q7: 能否提取匹配的内容？</a></h3>
<p>不支持。<code>regex_match</code> 只做匹配判断，不提取内容。</p>
<h2 id="正则表达式速查表"><a class="header" href="#正则表达式速查表">正则表达式速查表</a></h2>
<h3 id="常用模式-1"><a class="header" href="#常用模式-1">常用模式</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>模式</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><code>\d</code></td><td>数字</td><td><code>\d+</code> 匹配 “123”</td></tr>
<tr><td><code>\w</code></td><td>单词字符</td><td><code>\w+</code> 匹配 “hello”</td></tr>
<tr><td><code>\s</code></td><td>空白字符</td><td><code>\s+</code> 匹配 “   “</td></tr>
<tr><td><code>.</code></td><td>任意字符</td><td><code>.*</code> 匹配任何内容</td></tr>
<tr><td><code>^</code></td><td>行首</td><td><code>^start</code> 必须开头匹配</td></tr>
<tr><td><code>$</code></td><td>行尾</td><td><code>end$</code> 必须结尾匹配</td></tr>
<tr><td><code>*</code></td><td>0或多次</td><td><code>a*</code> 匹配 “”, “a”, “aa”</td></tr>
<tr><td><code>+</code></td><td>1或多次</td><td><code>a+</code> 匹配 “a”, “aa”</td></tr>
<tr><td><code>?</code></td><td>0或1次</td><td><code>a?</code> 匹配 “”, “a”</td></tr>
<tr><td><code>{n}</code></td><td>恰好n次</td><td><code>\d{4}</code> 匹配 “2024”</td></tr>
<tr><td><code>{n,m}</code></td><td>n到m次</td><td><code>\d{2,4}</code> 匹配 “12”, “123”</td></tr>
<tr><td><code>[abc]</code></td><td>字符集</td><td><code>[aeiou]</code> 匹配元音</td></tr>
<tr><td><code>[^abc]</code></td><td>非字符集</td><td><code>[^0-9]</code> 匹配非数字</td></tr>
<tr><td><code>|</code></td><td>选择</td><td><code>cat|dog</code> 匹配 “cat” 或 “dog”</td></tr>
<tr><td><code>()</code></td><td>分组</td><td><code>(ab)+</code> 匹配 “ab”, “abab”</td></tr>
</tbody>
</table>
</div>
<h2 id="更多资源-3"><a class="header" href="#更多资源-3">更多资源</a></h2>
<ul>
<li><strong>Rust Regex 文档</strong>: https://docs.rs/regex/</li>
<li><strong>开发指南</strong>: <code>docs/guide/wpl_field_func_development_guide.md</code></li>
<li><strong>源代码</strong>: <code>crates/wp-lang/src/ast/processor/function.rs</code></li>
<li><strong>测试用例</strong>: <code>crates/wp-lang/src/eval/builtins/pipe_fun.rs</code></li>
</ul>
<h2 id="版本历史-4"><a class="header" href="#版本历史-4">版本历史</a></h2>
<ul>
<li><strong>1.13.1</strong> (2026-02-02)
<ul>
<li>初始实现</li>
<li>支持完整的 Rust regex 语法</li>
<li>支持所有标准正则表达式特性</li>
<li>添加完整的测试覆盖</li>
</ul>
</li>
</ul>
<hr>
<p><strong>提示</strong>: <code>regex_match</code> 功能强大但也可能影响性能。对于简单的字符串匹配，优先考虑使用 <code>chars_has</code> 或 <code>chars_in</code>；对于数值范围检查，使用 <code>digit_range</code> 或 <code>digit_in</code>。正则表达式适合复杂的模式匹配场景。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="digit_range-函数使用指南"><a class="header" href="#digit_range-函数使用指南">digit_range 函数使用指南</a></h1>
<h2 id="概述-4"><a class="header" href="#概述-4">概述</a></h2>
<p><code>digit_range</code> 是 WPL (WP Language) 中的数值范围检查函数，用于判断日志字段的数值是否在指定的单个范围内。这是一个简单高效的闭区间检查函数。</p>
<h2 id="快速开始-4"><a class="header" href="#快速开始-4">快速开始</a></h2>
<h3 id="基本语法-6"><a class="header" href="#基本语法-6">基本语法</a></h3>
<pre><code class="language-wpl">digit_range(begin, end)
</code></pre>
<ul>
<li><strong>begin</strong>: 范围下界（标量值）</li>
<li><strong>end</strong>: 范围上界（标量值）</li>
<li>检查方式：<code>begin &lt;= value &lt;= end</code>（闭区间）</li>
</ul>
<h3 id="简单示例-4"><a class="header" href="#简单示例-4">简单示例</a></h3>
<pre><code class="language-wpl"># 检查数值是否在 [0, 100] 范围内
digit_range(0, 100)

# 检查 HTTP 成功状态码（200-299）
digit_range(200, 299)

# 检查端口号是否在标准范围内（0-65535）
digit_range(0, 65535)
</code></pre>
<h2 id="参数格式-1"><a class="header" href="#参数格式-1">参数格式</a></h2>
<h3 id="1-单个范围"><a class="header" href="#1-单个范围">1. 单个范围</a></h3>
<p>检查单个连续范围：</p>
<pre><code class="language-wpl"># 检查端口号是否在标准范围内（0-65535）
digit_range(0, 65535)

# 检查 HTTP 成功状态码（200-299）
digit_range(200, 299)

# 检查年龄是否成年（18-150）
digit_range(18, 150)
</code></pre>
<h3 id="2-范围限制说明"><a class="header" href="#2-范围限制说明">2. 范围限制说明</a></h3>
<p><strong>注意</strong>: 从 1.13.1 版本开始，<code>digit_range</code> 仅支持单个范围检查。如需检查多个不连续的范围，请使用多个规则或分支逻辑（见下文“与分支逻辑配合“部分）。</p>
<pre><code class="language-wpl"># ✅ 单个范围检查
digit_range(200, 299)  # 2xx 状态码

# ❌ 不再支持多范围数组语法
# digit_range([200, 300], [299, 399])  # 旧版本语法，已废弃
</code></pre>
<h3 id="3-边界值处理"><a class="header" href="#3-边界值处理">3. 边界值处理</a></h3>
<p>范围检查是<strong>闭区间</strong>，包含边界值：</p>
<pre><code class="language-wpl"># [100, 200] - 包含 100 和 200
digit_range(100, 200)

# 检查值 100: ✅ 通过（等于下界）
# 检查值 200: ✅ 通过（等于上界）
# 检查值 150: ✅ 通过（在范围内）
# 检查值 99:  ❌ 失败（小于下界）
# 检查值 201: ❌ 失败（大于上界）
</code></pre>
<h3 id="4-负数范围"><a class="header" href="#4-负数范围">4. 负数范围</a></h3>
<p>支持负数范围：</p>
<pre><code class="language-wpl"># 温度范围检查（-20°C 到 40°C）
digit_range(-20, 40)

# 海拔范围（死海 -400m 到 珠峰 8848m）
digit_range(-400, 8848)
</code></pre>
<h2 id="实际应用场景-4"><a class="header" href="#实际应用场景-4">实际应用场景</a></h2>
<h3 id="场景-1http-状态码分类"><a class="header" href="#场景-1http-状态码分类">场景 1：HTTP 状态码分类</a></h3>
<pre><code class="language-wpl">rule http_success_check {
    # 选择状态码字段
    | take(status_code)

    # 检查是否为成功状态码（2xx）
    | digit_range(200, 299)
}

# 示例数据：
# status_code: 200  → ✅ 通过（在 [200,299] 范围内）
# status_code: 204  → ✅ 通过（在 [200,299] 范围内）
# status_code: 301  → ❌ 失败（不在范围内）
# status_code: 404  → ❌ 失败（不在范围内）

# 如需检查多个状态码范围（如 2xx 或 3xx），使用分支逻辑：
rule http_ok_or_redirect {
    | take(status_code)
    | (digit_range(200, 299) | digit_range(300, 399))
}
</code></pre>
<h3 id="场景-2性能指标监控"><a class="header" href="#场景-2性能指标监控">场景 2：性能指标监控</a></h3>
<pre><code class="language-wpl">rule response_time_check {
    # 选择响应时间字段（毫秒）
    | take(response_time)

    # 检查响应时间是否在正常范围（0-500ms）
    | digit_range(0, 500)
}

# 示例数据：
# response_time: 50   → ✅ 通过（快速响应）
# response_time: 200  → ✅ 通过（正常响应）
# response_time: 1000 → ❌ 失败（超时）
</code></pre>
<h3 id="场景-3端口号验证"><a class="header" href="#场景-3端口号验证">场景 3：端口号验证</a></h3>
<pre><code class="language-wpl">rule system_port_check {
    # 选择端口字段
    | take(port)

    # 检查是否为系统保留端口（1-1023）
    | digit_range(1, 1023)
}

# 示例数据：
# port: 80    → ✅ 通过（HTTP 默认端口）
# port: 443   → ✅ 通过（HTTPS 默认端口）
# port: 8080  → ❌ 失败（用户端口）
</code></pre>
<h3 id="场景-4时间段过滤"><a class="header" href="#场景-4时间段过滤">场景 4：时间段过滤</a></h3>
<pre><code class="language-wpl">rule morning_hours_check {
    # 选择小时字段
    | take(hour)

    # 检查是否在上午工作时间（9-12）
    | digit_range(9, 12)
}

# 示例数据：
# hour: 10  → ✅ 通过（上午工作时间）
# hour: 11  → ✅ 通过（上午工作时间）
# hour: 15  → ❌ 失败（下午时间）

# 检查多个时间段，使用分支逻辑：
rule business_hours_check {
    | take(hour)
    | (digit_range(9, 12) | digit_range(14, 18))
}
</code></pre>
<h3 id="场景-5年龄分段"><a class="header" href="#场景-5年龄分段">场景 5：年龄分段</a></h3>
<pre><code class="language-wpl">rule adult_age_check {
    # 选择年龄字段
    | take(age)

    # 成年人年龄段（18-65）
    | digit_range(18, 65)
}

# 示例数据：
# age: 30  → ✅ 通过（成年人）
# age: 50  → ✅ 通过（成年人）
# age: 15  → ❌ 失败（未成年）
# age: 70  → ❌ 失败（老年人）
</code></pre>
<h3 id="场景-6优先级过滤"><a class="header" href="#场景-6优先级过滤">场景 6：优先级过滤</a></h3>
<pre><code class="language-wpl">rule high_priority_filter {
    # 选择优先级字段
    | take(priority)

    # 只处理高优先级（1-3）
    | digit_range(1, 3)
}

# 示例数据：
# priority: 1  → ✅ 通过（高优先级）
# priority: 3  → ✅ 通过（高优先级）
# priority: 5  → ❌ 失败（中优先级）
</code></pre>
<h3 id="场景-7数据质量检查"><a class="header" href="#场景-7数据质量检查">场景 7：数据质量检查</a></h3>
<pre><code class="language-wpl">rule data_quality_check {
    # 检查温度传感器数据
    | take(temperature)

    # 正常温度范围（-40°C 到 80°C）
    | digit_range(-40, 80)
}

# 示例数据：
# temperature: 25   → ✅ 通过（正常室温）
# temperature: -10  → ✅ 通过（冬季温度）
# temperature: 100  → ❌ 失败（异常数据）
# temperature: -100 → ❌ 失败（传感器故障）
</code></pre>
<h2 id="使用限制-4"><a class="header" href="#使用限制-4">使用限制</a></h2>
<h3 id="类型限制-2"><a class="header" href="#类型限制-2">类型限制</a></h3>
<p><code>digit_range</code> 只能处理<strong>数值类型</strong>的字段：</p>
<pre><code class="language-wpl"># ✅ 正确 - 字段是数字
status_code: 200 -&gt; digit_range(200, 299)

# ❌ 错误 - 字段是字符串
level: "200" -&gt; digit_range(200, 299)  # 会失败

# ❌ 错误 - 字段是 IP 地址
ip: 192.168.1.1 -&gt; digit_range(192, 200)  # 会失败
</code></pre>
<h3 id="参数要求"><a class="header" href="#参数要求">参数要求</a></h3>
<ol>
<li>
<p><strong>参数必须是标量值</strong>：</p>
<pre><code class="language-wpl"># ✅ 正确 - 使用标量值
digit_range(1, 10)

# ❌ 错误 - 不支持数组参数（旧版本语法）
digit_range([1], [10])  # 已废弃
</code></pre>
</li>
<li>
<p><strong>范围下界应小于等于上界</strong>：</p>
<pre><code class="language-wpl"># ✅ 正确
digit_range(1, 10)      # 1 &lt;= x &lt;= 10
digit_range(10, 10)     # x == 10（单点）

# ⚠️ 逻辑错误（不会匹配任何值）
digit_range(10, 1)      # 10 &lt;= x &lt;= 1（永远为假）
</code></pre>
</li>
</ol>
<h3 id="不支持的特性-2"><a class="header" href="#不支持的特性-2">不支持的特性</a></h3>
<ol>
<li>
<p><strong>不支持浮点数精确匹配</strong>：</p>
<pre><code class="language-wpl"># ⚠️ 注意：内部使用 i64，浮点数会被舍入
digit_range(1, 10)  # 只能匹配整数
</code></pre>
</li>
<li>
<p><strong>不支持无限范围</strong>：</p>
<pre><code class="language-wpl"># ❌ 不支持
digit_range(0, infinity)  # 没有无限值
</code></pre>
</li>
<li>
<p><strong>不支持多范围数组</strong>：</p>
<pre><code class="language-wpl"># ❌ 不支持（旧版本语法已废弃）
digit_range([1, 100], [10, 200])  # 请使用分支逻辑替代
</code></pre>
</li>
</ol>
<h2 id="完整示例-2"><a class="header" href="#完整示例-2">完整示例</a></h2>
<h3 id="示例-1日志严重性过滤"><a class="header" href="#示例-1日志严重性过滤">示例 1：日志严重性过滤</a></h3>
<pre><code class="language-wpl">rule log_error_filter {
    # 选择严重性级别字段
    | take(severity)

    # 过滤 ERROR 级别（1-2）
    | digit_range(1, 2)

    # 后续处理...
}

# 日志级别定义：
# 1 = CRITICAL
# 2 = ERROR
# 3 = WARNING
# 4 = WARN
# 5 = INFO
# 6 = DEBUG
</code></pre>
<h3 id="示例-2性能监控组合"><a class="header" href="#示例-2性能监控组合">示例 2：性能监控组合</a></h3>
<pre><code class="language-wpl">rule performance_monitor {
    # 检查响应时间
    | take(response_ms)
    | digit_range(0, 1000)  # 0-1000ms 认为正常

    # 检查状态码
    | take(status)
    | digit_range(200, 299)  # 2xx

    # 两个条件都满足才通过
}
</code></pre>
<h3 id="示例-3时间窗口分析"><a class="header" href="#示例-3时间窗口分析">示例 3：时间窗口分析</a></h3>
<pre><code class="language-wpl">rule weekday_check {
    # 工作日检查（1=周一, 7=周日）
    | take(day_of_week)
    | digit_range(1, 5)  # 周一到周五

    # 只分析工作日数据
}
</code></pre>
<h2 id="性能说明-4"><a class="header" href="#性能说明-4">性能说明</a></h2>
<ul>
<li><strong>时间复杂度</strong>：O(1) - 单次比较</li>
<li><strong>空间复杂度</strong>：O(1) - 原地检查</li>
<li><strong>性能特点</strong>：
<ul>
<li>纳秒级执行时间</li>
<li>简单的整数比较操作</li>
<li>性能极佳，适合高频调用</li>
</ul>
</li>
</ul>
<h2 id="错误处理-4"><a class="header" href="#错误处理-4">错误处理</a></h2>
<h3 id="常见错误-4"><a class="header" href="#常见错误-4">常见错误</a></h3>
<ol>
<li>
<p><strong>字段不存在</strong></p>
<pre><code>错误: &lt;pipe&gt; | not in range
原因: 当前没有活动字段
解决: 使用 take() 先选择字段
</code></pre>
</li>
<li>
<p><strong>字段类型不匹配</strong></p>
<pre><code>错误: &lt;pipe&gt; | not in range
原因: 字段不是数字类型（Digit）
解决: 确保字段是数值类型
</code></pre>
</li>
<li>
<p><strong>数值不在任何范围内</strong></p>
<pre><code>错误: &lt;pipe&gt; | not in range
原因: 字段值不满足任何一个范围条件
解决: 检查范围设置是否正确
</code></pre>
</li>
</ol>
<h2 id="与其他函数配合使用-2"><a class="header" href="#与其他函数配合使用-2">与其他函数配合使用</a></h2>
<h3 id="与字段选择器配合-2"><a class="header" href="#与字段选择器配合-2">与字段选择器配合</a></h3>
<pre><code class="language-wpl"># 先选择字段，再检查范围
| take(status_code)
| digit_range(200, 299)
</code></pre>
<h3 id="与条件检查配合-2"><a class="header" href="#与条件检查配合-2">与条件检查配合</a></h3>
<pre><code class="language-wpl"># 先检查字段存在，再检查范围
| has()
| digit_range(0, 100)
</code></pre>
<h3 id="与转换函数配合-1"><a class="header" href="#与转换函数配合-1">与转换函数配合</a></h3>
<pre><code class="language-wpl"># 组合使用进行复杂验证
| take(response_time)
| digit_range(0, 1000)  # 响应时间正常
| take(status_code)
| digit_range(200, 299)  # 状态码正常
</code></pre>
<h3 id="与分支逻辑配合-1"><a class="header" href="#与分支逻辑配合-1">与分支逻辑配合</a></h3>
<pre><code class="language-wpl"># 使用 alt 实现"或"逻辑 - 检查多个不连续范围
(
    # 分支 1：检查是否为成功状态码
    | take(status)
    | digit_range(200, 299)
)
|
(
    # 分支 2：检查是否为重定向状态码
    | take(status)
    | digit_range(300, 399)
)
</code></pre>
<h2 id="最佳实践-5"><a class="header" href="#最佳实践-5">最佳实践</a></h2>
<h3 id="1-范围设计原则"><a class="header" href="#1-范围设计原则">1. 范围设计原则</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：语义清晰的范围
digit_range(200, 299)  # HTTP 2xx 状态码

# ⚠️ 避免：使用旧的数组语法
# digit_range([200], [299])  # 已废弃
</code></pre>
<h3 id="2-简洁明了的单范围"><a class="header" href="#2-简洁明了的单范围">2. 简洁明了的单范围</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：简单直接的单范围
digit_range(0, 100)

# ✅ 推荐：多个范围使用分支逻辑
(digit_range(0, 50) | digit_range(100, 150))
</code></pre>
<h3 id="3-范围的可读性"><a class="header" href="#3-范围的可读性">3. 范围的可读性</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：添加注释说明范围含义
| digit_range(200, 299)  # HTTP 成功状态码

# ✅ 推荐：使用有意义的范围
| digit_range(18, 65)  # 工作年龄段
</code></pre>
<h3 id="4-边界值测试"><a class="header" href="#4-边界值测试">4. 边界值测试</a></h3>
<pre><code class="language-wpl"># 测试边界值是否符合预期
digit_range(100, 200)
# 测试：100 ✅, 200 ✅, 99 ❌, 201 ❌
</code></pre>
<h3 id="5-使用分支处理不连续范围"><a class="header" href="#5-使用分支处理不连续范围">5. 使用分支处理不连续范围</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：清晰的分支逻辑
(
    digit_range(1, 10)   # 第一个范围
    |
    digit_range(50, 100) # 第二个范围
)

# ❌ 避免：使用已废弃的数组语法
# digit_range([1, 50], [10, 100])
</code></pre>
<h2 id="调试技巧-3"><a class="header" href="#调试技巧-3">调试技巧</a></h2>
<h3 id="1-测试单个范围"><a class="header" href="#1-测试单个范围">1. 测试单个范围</a></h3>
<pre><code class="language-wpl"># 从简单的单个范围开始
| digit_range(0, 100)

# 如需多个范围，使用分支逻辑
| (digit_range(0, 100) | digit_range(200, 300))
</code></pre>
<h3 id="2-验证字段类型"><a class="header" href="#2-验证字段类型">2. 验证字段类型</a></h3>
<pre><code class="language-wpl"># 使用 digit_has() 确认字段是数字类型
| take(my_field)
| digit_has(0)  # 如果失败，说明不是数字字段
</code></pre>
<h3 id="3-检查边界值"><a class="header" href="#3-检查边界值">3. 检查边界值</a></h3>
<pre><code class="language-bash"># 准备测试数据
echo "value: 99" | wp-motor test.wpl    # 测试下界-1
echo "value: 100" | wp-motor test.wpl   # 测试下界
echo "value: 200" | wp-motor test.wpl   # 测试上界
echo "value: 201" | wp-motor test.wpl   # 测试上界+1
</code></pre>
<h2 id="常见问题-faq-4"><a class="header" href="#常见问题-faq-4">常见问题 (FAQ)</a></h2>
<h3 id="q1-如何检查单个特定值"><a class="header" href="#q1-如何检查单个特定值">Q1: 如何检查单个特定值？</a></h3>
<pre><code class="language-wpl"># 将下界和上界设为相同值
digit_range(200, 200)  # 只匹配 200
</code></pre>
<h3 id="q2-范围可以倒序吗"><a class="header" href="#q2-范围可以倒序吗">Q2: 范围可以倒序吗？</a></h3>
<p>技术上可以，但逻辑上没有意义：</p>
<pre><code class="language-wpl">digit_range(100, 50)  # begin &gt; end，永远不匹配
</code></pre>
<h3 id="q3-如何实现不在范围内的逻辑"><a class="header" href="#q3-如何实现不在范围内的逻辑">Q3: 如何实现“不在范围内“的逻辑？</a></h3>
<p>WPL 中管道失败会中断，可以使用分支逻辑：</p>
<pre><code class="language-wpl"># 使用否定逻辑（复杂）
# 建议：使用其他字段函数或在应用层处理
</code></pre>
<h3 id="q4-支持浮点数吗"><a class="header" href="#q4-支持浮点数吗">Q4: 支持浮点数吗？</a></h3>
<p>内部使用 <code>i64</code>，浮点数会被转换：</p>
<pre><code class="language-wpl"># 字段值 3.14 会被视为 3
digit_range(3, 4)  # 可能匹配 3.14（取决于解析方式）
</code></pre>
<h3 id="q5-如何检查多个不连续的范围"><a class="header" href="#q5-如何检查多个不连续的范围">Q5: 如何检查多个不连续的范围？</a></h3>
<p>使用分支逻辑（alt 操作符）：</p>
<pre><code class="language-wpl"># 检查 [1,10] 或 [100,200] 范围
(digit_range(1, 10) | digit_range(100, 200))
# 匹配：[1,10] 或 [100,200] 内的任何值
</code></pre>
<h3 id="q6-性能够用吗"><a class="header" href="#q6-性能够用吗">Q6: 性能够用吗？</a></h3>
<p>非常快！范围检查是简单的数值比较：</p>
<ul>
<li>O(1) 时间复杂度</li>
<li>纳秒级执行时间</li>
<li>适合高频调用场景</li>
</ul>
<h3 id="q7-旧的数组语法还能用吗"><a class="header" href="#q7-旧的数组语法还能用吗">Q7: 旧的数组语法还能用吗？</a></h3>
<p>不推荐使用，已废弃：</p>
<pre><code class="language-wpl"># ❌ 旧语法（已废弃）
digit_range([200], [299])

# ✅ 新语法（推荐）
digit_range(200, 299)
</code></pre>
<h2 id="与-digit_in-的对比"><a class="header" href="#与-digit_in-的对比">与 digit_in 的对比</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>digit_range</th><th>digit_in</th></tr>
</thead>
<tbody>
<tr><td>用途</td><td>单个范围检查</td><td>集合成员检查</td></tr>
<tr><td>参数</td><td>两个标量（begin, end）</td><td>一个数组（值列表）</td></tr>
<tr><td>适用场景</td><td>连续范围</td><td>离散值</td></tr>
<tr><td>示例</td><td><code>digit_range(0, 100)</code></td><td><code>digit_in([200, 404, 500])</code></td></tr>
<tr><td>复杂度</td><td>O(1)</td><td>O(n)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-wpl"># digit_range - 适合连续范围
digit_range(200, 299)  # 200, 201, ..., 299

# digit_in - 适合离散值
digit_in([200, 404, 500])  # 只匹配这三个值

# 多个不连续范围 - 使用分支逻辑
(digit_range(200, 299) | digit_range(300, 399))
</code></pre>
<h2 id="更多资源-4"><a class="header" href="#更多资源-4">更多资源</a></h2>
<ul>
<li><strong>开发指南</strong>: <code>docs/guide/wpl_field_func_development_guide.md</code></li>
<li><strong>源代码</strong>: <code>crates/wp-lang/src/ast/processor/function.rs</code></li>
<li><strong>测试用例</strong>: <code>crates/wp-lang/src/eval/builtins/pipe_fun.rs</code></li>
</ul>
<h2 id="版本历史-5"><a class="header" href="#版本历史-5">版本历史</a></h2>
<ul>
<li><strong>1.13.1</strong> (2026-02-02)
<ul>
<li>重构为双参数形式：<code>digit_range(begin, end)</code></li>
<li>废弃旧的数组语法：<code>digit_range([begins], [ends])</code></li>
<li>简化为单范围检查，性能优化至 O(1)</li>
<li>支持负数范围</li>
<li>添加完整的测试覆盖</li>
</ul>
</li>
</ul>
<hr>
<p><strong>提示</strong>: <code>digit_range</code> 现在是一个简单高效的单范围检查函数，适合处理连续的数值范围验证场景，如状态码、性能指标、时间段等。对于多个不连续范围，请使用分支逻辑（alt 操作符）。对于离散值检查，请使用 <code>digit_in</code> 函数。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="starts_with-函数使用指南"><a class="header" href="#starts_with-函数使用指南">starts_with 函数使用指南</a></h1>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p><code>starts_with</code> 是一个 WPL pipe 函数，用于检查字符串字段是否以指定的前缀开始。</p>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<pre><code class="language-wpl">field_name | starts_with('prefix')
</code></pre>
<h2 id="参数"><a class="header" href="#参数">参数</a></h2>
<ul>
<li><code>prefix</code>: 字符串类型，要检查的前缀</li>
</ul>
<h2 id="行为"><a class="header" href="#行为">行为</a></h2>
<ul>
<li>如果字段值以指定前缀开始，字段保持不变并继续传递</li>
<li>如果字段值不以指定前缀开始，字段转换为 <strong>ignore 类型</strong>，后续规则将忽略该字段</li>
<li>如果字段不是字符串类型，字段转换为 <strong>ignore 类型</strong></li>
<li>前缀匹配是大小写敏感的</li>
<li>空前缀 <code>''</code> 匹配任何字符串</li>
</ul>
<h2 id="使用示例-3"><a class="header" href="#使用示例-3">使用示例</a></h2>
<h3 id="示例-1-过滤-https-url"><a class="header" href="#示例-1-过滤-https-url">示例 1: 过滤 HTTPS URL</a></h3>
<pre><code class="language-wpl">rule https_filter {
    (chars:url) | starts_with('https://')
}
</code></pre>
<p><strong>输入:</strong> <code>https://example.com</code>
<strong>输出:</strong> 匹配成功，提取 <code>url = "https://example.com"</code></p>
<p><strong>输入:</strong> <code>http://example.com</code>
<strong>输出:</strong> <code>url</code> 字段转换为 ignore，规则匹配失败</p>
<h3 id="示例-2-过滤-api-路径"><a class="header" href="#示例-2-过滤-api-路径">示例 2: 过滤 API 路径</a></h3>
<pre><code class="language-wpl">rule api_filter {
    (chars:path) | starts_with('/api/')
}
</code></pre>
<p><strong>输入:</strong> <code>/api/users</code>
<strong>输出:</strong> 匹配成功，提取 <code>path = "/api/users"</code></p>
<p><strong>输入:</strong> <code>/home/users</code>
<strong>输出:</strong> <code>path</code> 字段转换为 ignore，规则匹配失败</p>
<h3 id="示例-3-检查日志级别"><a class="header" href="#示例-3-检查日志级别">示例 3: 检查日志级别</a></h3>
<pre><code class="language-wpl">rule error_log {
    (chars:log_level) | starts_with('ERROR'),
    (chars:message)
}
</code></pre>
<p><strong>输入:</strong> <code>ERROR: Database connection failed</code>
<strong>输出:</strong> 匹配成功</p>
<ul>
<li><code>log_level = "ERROR:"</code></li>
<li><code>message = "Database connection failed"</code></li>
</ul>
<h3 id="示例-4-结合其他函数使用"><a class="header" href="#示例-4-结合其他函数使用">示例 4: 结合其他函数使用</a></h3>
<pre><code class="language-wpl">rule secure_url {
    (chars:url) | starts_with('https://') | chars_has('secure')
}
</code></pre>
<p>只匹配以 <code>https://</code> 开头且包含 <code>secure</code> 的 URL。</p>
<h3 id="示例-5-多分支条件"><a class="header" href="#示例-5-多分支条件">示例 5: 多分支条件</a></h3>
<pre><code class="language-wpl">rule protocol_filter {
    (
        (chars:url) | starts_with('https://')
    ) | (
        (chars:url) | starts_with('wss://')
    )
}
</code></pre>
<p>匹配以 <code>https://</code> 或 <code>wss://</code> 开头的 URL。</p>
<h2 id="与-regex_match-的对比"><a class="header" href="#与-regex_match-的对比">与 regex_match 的对比</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>starts_with</th><th>regex_match</th></tr>
</thead>
<tbody>
<tr><td>性能</td><td>更快（字符串前缀检查）</td><td>较慢（正则表达式编译和匹配）</td></tr>
<tr><td>功能</td><td>只能检查前缀</td><td>支持复杂模式匹配</td></tr>
<tr><td>使用难度</td><td>简单直观</td><td>需要了解正则表达式</td></tr>
<tr><td>失败行为</td><td>转换为 ignore</td><td>解析失败</td></tr>
</tbody>
</table>
</div>
<p><strong>何时使用 starts_with:</strong></p>
<ul>
<li>只需要检查字符串前缀</li>
<li>性能要求高</li>
<li>简单场景</li>
<li>需要在管道中继续处理（通过 ignore 字段）</li>
</ul>
<p><strong>何时使用 regex_match:</strong></p>
<ul>
<li>需要复杂的模式匹配</li>
<li>需要检查中间或结尾内容</li>
<li>需要使用正则表达式特性（捕获组等）</li>
</ul>
<h2 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h2>
<ol>
<li><strong>大小写敏感</strong>: <code>starts_with('HTTP')</code> 不会匹配 <code>http://example.com</code></li>
<li><strong>完全匹配前缀</strong>: 前缀必须完全匹配，不支持通配符</li>
<li><strong>仅支持字符串</strong>: 如果字段不是字符串类型，将转换为 ignore</li>
<li><strong>ignore 类型传播</strong>: 转换为 ignore 的字段在后续管道函数中会被跳过</li>
</ol>
<h2 id="实现细节"><a class="header" href="#实现细节">实现细节</a></h2>
<ul>
<li>定义位置: <code>crates/wp-lang/src/ast/processor/function.rs</code></li>
<li>实现位置: <code>crates/wp-lang/src/eval/builtins/pipe_fun.rs</code></li>
<li>解析器: <code>crates/wp-lang/src/parser/wpl_fun.rs</code></li>
<li>测试: <code>crates/wp-lang/src/eval/builtins/pipe_fun.rs</code> (tests 模块)</li>
</ul>
<h2 id="相关函数"><a class="header" href="#相关函数">相关函数</a></h2>
<ul>
<li><code>regex_match(pattern)</code>: 正则表达式匹配</li>
<li><code>chars_has(value)</code>: 检查字段值是否等于指定字符串</li>
<li><code>chars_in([values...])</code>: 检查字段值是否在列表中</li>
<li><code>chars_replace(target, replacement)</code>: 替换字符串中的子串</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="not---结果反转包装函数"><a class="header" href="#not---结果反转包装函数">not() - 结果反转包装函数</a></h1>
<h2 id="概述-5"><a class="header" href="#概述-5">概述</a></h2>
<p><code>not()</code> 是一个包装函数，用于反转（取反）内部管道函数的成功/失败结果。当内部函数匹配成功时，<code>not()</code> 返回失败；当内部函数匹配失败时，<code>not()</code> 返回成功。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-wpl">| not(inner_function)
</code></pre>
<p><strong>参数</strong>：</p>
<ul>
<li><code>inner_function</code>: 任何字段管道函数（如 <code>f_chars_has</code>, <code>has</code>, <code>chars_has</code> 等）</li>
</ul>
<p><strong>返回</strong>：</p>
<ul>
<li>内部函数成功 → <code>not()</code> 失败</li>
<li>内部函数失败 → <code>not()</code> 成功</li>
</ul>
<p><strong>重要特性</strong>：</p>
<ul>
<li>✅ <strong>保留字段值</strong>：<code>not()</code> 只反转结果，不修改字段内容</li>
<li>✅ <strong>支持嵌套</strong>：可以使用 <code>not(not(...))</code> 实现双重否定</li>
<li>✅ <strong>自动字段选择</strong>：继承内部函数的字段选择行为</li>
<li>✅ <strong>零性能开销</strong>：仅在执行时克隆单个字段进行测试</li>
</ul>
<h2 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h2>
<h3 id="1-字符串不等于检查"><a class="header" href="#1-字符串不等于检查">1. 字符串不等于检查</a></h3>
<pre><code class="language-wpl"># 检查 dev_type 不等于 "NDS"
(chars:dev_type) | not(chars_has(NDS))

# 等价于
(chars:dev_type) | chars_not_has(NDS)
</code></pre>
<h3 id="2-字段不存在检查"><a class="header" href="#2-字段不存在检查">2. 字段不存在检查</a></h3>
<pre><code class="language-wpl"># 检查字段不存在
| not(f_has(optional_field))
</code></pre>
<h3 id="3-使用目标字段函数"><a class="header" href="#3-使用目标字段函数">3. 使用目标字段函数</a></h3>
<pre><code class="language-wpl"># 检查指定字段不等于某值
| not(f_chars_has(status, ERROR))

# 检查指定字段不在列表中
| not(f_chars_in(level, [DEBUG, TRACE]))
</code></pre>
<h2 id="高级用法-1"><a class="header" href="#高级用法-1">高级用法</a></h2>
<h3 id="双重否定"><a class="header" href="#双重否定">双重否定</a></h3>
<p>双重否定等同于肯定断言：</p>
<pre><code class="language-wpl"># not(not(...)) 等同于直接使用内部函数
| not(not(f_chars_has(status, OK)))

# 等价于
| f_chars_has(status, OK)
</code></pre>
<h3 id="组合复杂条件"><a class="header" href="#组合复杂条件">组合复杂条件</a></h3>
<pre><code class="language-wpl"># 字段存在但值不等于目标值
| f_has(dev_type)           # 确保字段存在
| not(chars_has(NDS))       # 确保值不等于 NDS
</code></pre>
<h3 id="与数值函数结合"><a class="header" href="#与数值函数结合">与数值函数结合</a></h3>
<pre><code class="language-wpl"># 检查状态码不在成功范围内
| not(f_digit_range(status, 200, 299))

# 检查端口号不在常用端口列表中
| not(f_digit_in(port, [80, 443, 8080]))
</code></pre>
<h3 id="与正则表达式结合"><a class="header" href="#与正则表达式结合">与正则表达式结合</a></h3>
<pre><code class="language-wpl"># 检查消息不匹配错误模式
| not(regex_match('(?i)error|fail|exception'))
</code></pre>
<h2 id="与现有函数对比"><a class="header" href="#与现有函数对比">与现有函数对比</a></h2>
<h3 id="notchars_has-vs-chars_not_has"><a class="header" href="#notchars_has-vs-chars_not_has">not(chars_has) vs chars_not_has</a></h3>
<p>虽然功能相似，但语义略有不同：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>字段不存在</th><th>非Chars类型</th><th>值不等于</th><th>值等于</th></tr>
</thead>
<tbody>
<tr><td><code>not(chars_has(X))</code></td><td>✅ 成功</td><td>✅ 成功</td><td>✅ 成功</td><td>❌ 失败</td></tr>
<tr><td><code>chars_not_has(X)</code></td><td>✅ 成功</td><td>✅ 成功</td><td>✅ 成功</td><td>❌ 失败</td></tr>
</tbody>
</table>
</div>
<p><strong>推荐使用</strong>：</p>
<ul>
<li>简单场景：使用 <code>chars_not_has</code> （更直观）</li>
<li>复杂场景：使用 <code>not()</code> 包装其他函数（更灵活）</li>
</ul>
<pre><code class="language-wpl"># ✅ 推荐：简单否定
| chars_not_has(ERROR)

# ✅ 推荐：复杂条件否定
| not(f_digit_range(code, 400, 499))
</code></pre>
<h2 id="实际应用场景-5"><a class="header" href="#实际应用场景-5">实际应用场景</a></h2>
<h3 id="场景-1过滤非错误日志"><a class="header" href="#场景-1过滤非错误日志">场景 1：过滤非错误日志</a></h3>
<pre><code class="language-wpl">rule filter_non_errors {
    # 解析日志级别
    (symbol(ERROR), symbol(WARN), symbol(INFO), symbol(DEBUG):level)

    # 只保留非 ERROR 和 WARN 级别的日志
    | take(level)
    | not(chars_in([ERROR, WARN]))
}
</code></pre>
<p><strong>输入</strong>：</p>
<pre><code>INFO: Application started
ERROR: Connection failed
DEBUG: Processing request
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>INFO: Application started     # ✅ 通过（非错误）
                              # ❌ 过滤掉 ERROR
DEBUG: Processing request     # ✅ 通过（非错误）
</code></pre>
<h3 id="场景-2排除特定设备类型"><a class="header" href="#场景-2排除特定设备类型">场景 2：排除特定设备类型</a></h3>
<pre><code class="language-wpl">rule exclude_device_types {
    # 解析设备类型字段
    (chars:dev_type)

    # 排除 NDS 和 IDS 设备
    | not(f_chars_in(dev_type, [NDS, IDS]))
}
</code></pre>
<p><strong>输入</strong>：</p>
<pre><code>dev_type=FIREWALL
dev_type=NDS
dev_type=ROUTER
dev_type=IDS
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>dev_type=FIREWALL    # ✅ 通过
                     # ❌ 过滤掉 NDS
dev_type=ROUTER      # ✅ 通过
                     # ❌ 过滤掉 IDS
</code></pre>
<h3 id="场景-3非标准端口检查"><a class="header" href="#场景-3非标准端口检查">场景 3：非标准端口检查</a></h3>
<pre><code class="language-wpl">rule non_standard_ports {
    # 解析端口号
    (digit:port)

    # 排除标准端口 80 和 443
    | not(f_digit_in(port, [80, 443]))

    # 同时必须在有效范围内
    | digit_range(1, 65535)
}
</code></pre>
<p><strong>输入</strong>：</p>
<pre><code>80
8080
443
9000
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>                # ❌ 过滤掉 80（标准端口）
8080            # ✅ 通过
                # ❌ 过滤掉 443（标准端口）
9000            # ✅ 通过
</code></pre>
<h3 id="场景-4排除测试环境日志"><a class="header" href="#场景-4排除测试环境日志">场景 4：排除测试环境日志</a></h3>
<pre><code class="language-wpl">rule exclude_test_env {
    # 解析环境标识
    (chars:env)

    # 排除测试和开发环境
    | not(f_chars_in(env, [test, dev, staging]))
}
</code></pre>
<h2 id="性能考虑-1"><a class="header" href="#性能考虑-1">性能考虑</a></h2>
<h3 id="性能特征"><a class="header" href="#性能特征">性能特征</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>操作</th><th>性能影响</th></tr>
</thead>
<tbody>
<tr><td>单层 <code>not()</code></td><td>&lt; 200ns（克隆单个字段）</td></tr>
<tr><td>双层 <code>not(not())</code></td><td>&lt; 400ns（两次克隆）</td></tr>
<tr><td>字段选择继承</td><td>0ns（无额外开销）</td></tr>
</tbody>
</table>
</div>
<h3 id="性能优化建议"><a class="header" href="#性能优化建议">性能优化建议</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：使用专用函数（更快）
| chars_not_has(ERROR)

# ⚠️ 可接受：使用 not() 包装（稍慢）
| not(chars_has(ERROR))

# ❌ 不推荐：过度嵌套
| not(not(not(chars_has(ERROR))))  # 无意义的多重否定
</code></pre>
<h2 id="常见陷阱"><a class="header" href="#常见陷阱">常见陷阱</a></h2>
<h3 id="陷阱-1混淆管道级-not-和组级-not"><a class="header" href="#陷阱-1混淆管道级-not-和组级-not">陷阱 1：混淆管道级 not() 和组级 not()</a></h3>
<pre><code class="language-wpl"># ❌ 错误：这是组级 not()，不是管道级
not(symbol(ERROR):test)

# ✅ 正确：管道级 not() 用于管道函数
(chars:status) | not(chars_has(ERROR))
</code></pre>
<h3 id="陷阱-2期望-not-修改字段值"><a class="header" href="#陷阱-2期望-not-修改字段值">陷阱 2：期望 not() 修改字段值</a></h3>
<pre><code class="language-wpl"># ❌ 误解：以为 not() 会修改字段
(chars:status) | not(chars_has(ERROR))
# 字段值仍然是原始值，not() 只反转匹配结果

# ✅ 正确：如需修改值，使用转换函数
(chars:status) | chars_replace(ERROR, OK)
</code></pre>
<h3 id="陷阱-3not-包装非字段函数"><a class="header" href="#陷阱-3not-包装非字段函数">陷阱 3：not() 包装非字段函数</a></h3>
<pre><code class="language-wpl"># ❌ 错误：take 不是字段管道函数
| not(take(field_name))
# 会报错：not() can only wrap field pipe functions

# ✅ 正确：包装字段管道函数
| not(f_has(field_name))
</code></pre>
<h2 id="与组级-not-的区别"><a class="header" href="#与组级-not-的区别">与组级 not() 的区别</a></h2>
<p>WPL 中有两种 <code>not()</code>：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>管道级 <code>not()</code></th><th>组级 <code>not()</code></th></tr>
</thead>
<tbody>
<tr><td>用途</td><td>反转管道函数结果</td><td>反转字段组匹配</td></tr>
<tr><td>语法位置</td><td>管道中 <code>| not(...)</code></td><td>字段组定义 <code>not(...)</code></td></tr>
<tr><td>参数类型</td><td>管道函数</td><td>字段定义</td></tr>
<tr><td>返回结果</td><td>成功/失败</td><td>ignore 字段</td></tr>
</tbody>
</table>
</div>
<p><strong>示例对比</strong>：</p>
<pre><code class="language-wpl"># 管道级 not()：反转函数结果
(chars:status) | not(chars_has(ERROR))

# 组级 not()：字段存在时失败
not(symbol(ERROR):error_marker)
</code></pre>
<h2 id="最佳实践-6"><a class="header" href="#最佳实践-6">最佳实践</a></h2>
<h3 id="1-优先使用专用函数"><a class="header" href="#1-优先使用专用函数">1. 优先使用专用函数</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：使用 chars_not_has
| chars_not_has(ERROR)

# ⚠️ 次选：使用 not() 包装
| not(chars_has(ERROR))
</code></pre>
<h3 id="2-not-用于无专用函数的场景"><a class="header" href="#2-not-用于无专用函数的场景">2. not() 用于无专用函数的场景</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：没有 digit_not_in，使用 not()
| not(f_digit_in(port, [80, 443]))

# ✅ 推荐：没有 digit_not_range，使用 not()
| not(digit_range(200, 299))
</code></pre>
<h3 id="3-组合多个条件"><a class="header" href="#3-组合多个条件">3. 组合多个条件</a></h3>
<pre><code class="language-wpl"># ✅ 推荐：清晰的逻辑组合
| f_has(status)              # 字段必须存在
| not(chars_in([ERROR, FATAL]))  # 且不是错误状态
</code></pre>
<h3 id="4-避免过度嵌套"><a class="header" href="#4-避免过度嵌套">4. 避免过度嵌套</a></h3>
<pre><code class="language-wpl"># ❌ 不推荐：双重否定令人困惑
| not(not(chars_has(OK)))

# ✅ 推荐：直接使用肯定形式
| chars_has(OK)
</code></pre>
<h2 id="故障排查"><a class="header" href="#故障排查">故障排查</a></h2>
<h3 id="问题not-没有反转结果"><a class="header" href="#问题not-没有反转结果">问题：not() 没有反转结果</a></h3>
<p><strong>可能原因</strong>：混淆了管道级和组级 <code>not()</code></p>
<pre><code class="language-wpl"># 检查是否在正确位置使用
(chars:status) | not(chars_has(ERROR))  # ✅ 正确
not(chars:status)                        # ❌ 错误（这是组级）
</code></pre>
<h3 id="问题报错-can-only-wrap-field-pipe-functions"><a class="header" href="#问题报错-can-only-wrap-field-pipe-functions">问题：报错 “can only wrap field pipe functions”</a></h3>
<p><strong>解决方案</strong>：确保包装的是字段管道函数</p>
<pre><code class="language-wpl">| not(take(field))        # ❌ take 是选择器
| not(f_has(field))       # ✅ f_has 是管道函数
</code></pre>
<h2 id="版本历史-6"><a class="header" href="#版本历史-6">版本历史</a></h2>
<ul>
<li><strong>1.15.1</strong> (2026-02-07)
<ul>
<li>新增 <code>not()</code> 管道级包装函数</li>
<li>支持反转任何字段管道函数结果</li>
<li>支持嵌套和自动字段选择</li>
</ul>
</li>
</ul>
<h2 id="相关文档-5"><a class="header" href="#相关文档-5">相关文档</a></h2>
<ul>
<li><a href="#字段存在性检查-field-existence">字段存在性检查函数</a></li>
<li><a href="#字符串匹配函数-string-matching">字符串匹配函数</a></li>
<li><a href="#wpl-group-逻辑">组级 not() 文档</a></li>
<li><a href="#wpl-field-functions-函数索引">函数索引</a></li>
</ul>
<hr>
<p><strong>提示</strong>: <code>not()</code> 是一个强大的工具，但不要过度使用。大多数情况下，使用专用的否定函数（如 <code>chars_not_has</code>）更直观、性能更好。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-group-逻辑"><a class="header" href="#wpl-group-逻辑">WPL Group 逻辑</a></h1>
<p>WPL 提供了多种 group 包装器，用于控制字段解析的逻辑行为。Group 可以包含一个或多个字段，并根据不同的逻辑语义决定解析成功或失败。</p>
<h2 id="group-类型"><a class="header" href="#group-类型">Group 类型</a></h2>
<h3 id="seq---序列默认"><a class="header" href="#seq---序列默认">seq - 序列（默认）</a></h3>
<p>默认的 group 类型，要求所有字段按顺序成功解析。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">(field1, field2, field3)
seq(field1, field2, field3)
</code></pre>
<p><strong>行为：</strong></p>
<ul>
<li>按顺序解析所有字段</li>
<li>所有字段都必须成功</li>
<li>任一字段失败则整个 group 失败</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">(digit:id, chars:name, ip:addr)
</code></pre>
<h3 id="opt---可选"><a class="header" href="#opt---可选">opt - 可选</a></h3>
<p>将 group 标记为可选，失败时不影响整体解析。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">opt(field1, field2)
</code></pre>
<p><strong>行为：</strong></p>
<ul>
<li>尝试解析所有字段</li>
<li>解析失败时不返回错误</li>
<li>成功时返回解析结果，失败时跳过</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">opt(symbol([DEBUG]):level), chars:msg
</code></pre>
<h3 id="alt---选择"><a class="header" href="#alt---选择">alt - 选择</a></h3>
<p>尝试多个解析选项，任一成功即可。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">alt(field1, field2, field3)
</code></pre>
<p><strong>行为：</strong></p>
<ul>
<li>依次尝试每个字段</li>
<li>第一个成功的字段被采用</li>
<li>所有字段都失败时，group 失败</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">alt(ip:addr, chars:addr)  # 尝试解析 IP，失败则解析为字符串
</code></pre>
<h3 id="some_of---部分匹配"><a class="header" href="#some_of---部分匹配">some_of - 部分匹配</a></h3>
<p>要求至少一个字段成功即可。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">some_of(field1, field2, field3)
</code></pre>
<p><strong>行为：</strong></p>
<ul>
<li>尝试解析所有字段</li>
<li>至少一个字段成功即可</li>
<li>所有字段都失败时，group 失败</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl">some_of(digit:port, chars:service)
</code></pre>
<h3 id="not---负向断言"><a class="header" href="#not---负向断言">not - 负向断言</a></h3>
<p>反向逻辑，当内部字段解析失败时才成功。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-wpl">not(field)
</code></pre>
<p><strong>行为：</strong></p>
<ul>
<li>尝试解析内部字段</li>
<li>内部字段失败时，not() 成功</li>
<li>内部字段成功时，not() 失败</li>
<li>成功时返回 <code>ignore</code> 类型字段</li>
</ul>
<p><strong>输入消费：</strong></p>
<ul>
<li><code>not(symbol(...))</code> - 会消费输入（symbol 在失败时可能消费空白字符）</li>
<li><code>not(peek_symbol(...))</code> - 不消费输入（peek_symbol 永不消费）</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-wpl"># 确保不存在 ERROR 关键字
not(symbol(ERROR):check)

# 与 peek_symbol 配合，不消费输入
not(peek_symbol(ERROR):check), (chars:msg)
</code></pre>
<h2 id="使用场景-1"><a class="header" href="#使用场景-1">使用场景</a></h2>
<h3 id="1-条件解析"><a class="header" href="#1-条件解析">1. 条件解析</a></h3>
<pre><code class="language-wpl"># 解析可选的调试信息
opt(symbol([DEBUG]):level), chars:msg
</code></pre>
<h3 id="2-格式兼容"><a class="header" href="#2-格式兼容">2. 格式兼容</a></h3>
<pre><code class="language-wpl"># 支持多种 IP 地址格式
alt(ip:addr, chars:addr)
</code></pre>
<h3 id="3-负向过滤"><a class="header" href="#3-负向过滤">3. 负向过滤</a></h3>
<pre><code class="language-wpl"># 只处理非错误日志
not(symbol(ERROR)), (chars:msg)
</code></pre>
<h3 id="4-宽松匹配"><a class="header" href="#4-宽松匹配">4. 宽松匹配</a></h3>
<pre><code class="language-wpl"># 至少匹配端口或服务名之一
some_of(digit:port, chars:service)
</code></pre>
<h2 id="组合使用"><a class="header" href="#组合使用">组合使用</a></h2>
<p>Group 可以嵌套组合，实现复杂的解析逻辑：</p>
<pre><code class="language-wpl"># 可选的 IP 或域名
opt(alt(ip:addr, chars:domain))

# 确保不是 ERROR，然后解析消息
not(peek_symbol(ERROR)), (alt(json, kv, chars):msg)
</code></pre>
<h2 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h2>
<ol>
<li>
<p><strong>Group 不能嵌套在 Group 内部</strong></p>
<pre><code class="language-wpl"># ❌ 错误：不支持嵌套
(chars, (digit, chars))

# ✓ 正确：使用多个并列 group
(chars), (digit, chars)
</code></pre>
</li>
<li>
<p><strong>not() 只能包含单个字段</strong></p>
<pre><code class="language-wpl"># ✓ 正确
not(symbol(ERROR):check)

# ❌ 错误
not(symbol(ERROR), symbol(FATAL))
</code></pre>
</li>
<li>
<p><strong>输入消费行为取决于内部 parser</strong></p>
<ul>
<li>使用 <code>peek_symbol</code> 等非消费 parser 可以实现前瞻断言</li>
<li>使用 <code>symbol</code>、<code>digit</code> 等消费 parser 会改变输入位置</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wpl-学习目标与练习"><a class="header" href="#wpl-学习目标与练习">WPL 学习目标与练习</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="实战教程-t1-t4"><a class="header" href="#实战教程-t1-t4">实战教程 (T1-T4)</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-对象模型语言"><a class="header" href="#oml-对象模型语言">OML 对象模型语言</a></h1>
<p>OML (Object Modeling Language) 是 Warp Parse 使用的数据转换语言，用于对 WPL 解析后的结构化数据进行转换、聚合和富化。</p>
<hr>
<h2 id="-文档导航-5"><a class="header" href="#-文档导航-5">📚 文档导航</a></h2>
<h3 id="按学习路径-1"><a class="header" href="#按学习路径-1">按学习路径</a></h3>
<pre><code>🆕 新手入门
   ↓
01-quickstart.md ────────→ 5分钟上手，复制即用
   ↓
07-complete-example.md ──→ 🌟 完整功能演示（强烈推荐）
   ↓
02-core-concepts.md ─────→ 理解设计理念和核心概念
   ↓
03-practical-guide.md ───→ 按任务查找解决方案
   ↓
04-functions-reference.md → 查阅函数
   ↓
05-integration.md ───────→ 集成到数据流
</code></pre>
<h3 id="按用户角色-1"><a class="header" href="#按用户角色-1">按用户角色</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>我是…</th><th>推荐阅读</th></tr>
</thead>
<tbody>
<tr><td><strong>OML 新手</strong></td><td><a href="#oml-快速入门">01-quickstart.md</a> → <a href="#oml-完整功能示例">07-complete-example.md</a></td></tr>
<tr><td><strong>日常使用者</strong></td><td><a href="#oml-实战指南">03-practical-guide.md</a> - 按任务查找</td></tr>
<tr><td><strong>开发者/集成</strong></td><td><a href="#oml-完整功能示例">07-complete-example.md</a> + <a href="#oml-函数参考">04-functions-reference.md</a></td></tr>
<tr><td><strong>系统集成</strong></td><td><a href="#oml-集成指南">05-integration.md</a> - WPL/OML/Sink 关联</td></tr>
</tbody>
</table>
</div>
<h3 id="按任务查找-1"><a class="header" href="#按任务查找-1">按任务查找</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>我想…</th><th>查看文档</th></tr>
</thead>
<tbody>
<tr><td>🚀 快速上手</td><td><a href="#oml-快速入门">01-quickstart.md</a></td></tr>
<tr><td>🌟 查看完整示例</td><td><a href="#oml-完整功能示例">07-complete-example.md</a></td></tr>
<tr><td>💡 理解概念</td><td><a href="#oml-核心概念">02-core-concepts.md</a></td></tr>
<tr><td>📝 提取字段</td><td><a href="#数据提取">03-practical-guide.md § 数据提取</a></td></tr>
<tr><td>🔄 类型转换</td><td><a href="#数据转换">03-practical-guide.md § 数据转换</a></td></tr>
<tr><td>📦 创建对象/数组</td><td><a href="#数据聚合-1">03-practical-guide.md § 数据聚合</a></td></tr>
<tr><td>✅ 条件判断</td><td><a href="#条件处理-1">03-practical-guide.md § 条件处理</a></td></tr>
<tr><td>🔍 SQL 查询</td><td><a href="#数据富化-sql-查询">03-practical-guide.md § 数据富化</a></td></tr>
<tr><td>⚙️ 查某个函数</td><td><a href="#oml-函数参考">04-functions-reference.md</a></td></tr>
<tr><td>🔗 集成到流水线</td><td><a href="#oml-集成指南">05-integration.md</a></td></tr>
<tr><td>📖 查语法规则</td><td><a href="#oml-语法参考">06-grammar-reference.md</a></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-文档列表-1"><a class="header" href="#-文档列表-1">📖 文档列表</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>文档</th><th>内容</th><th>适合人群</th></tr>
</thead>
<tbody>
<tr><td><a href="#oml-快速入门">01-quickstart.md</a></td><td>5 分钟快速入门 + 3 个最常用操作</td><td>所有人</td></tr>
<tr><td><a href="#oml-完整功能示例">🌟 07-complete-example.md</a></td><td>完整功能演示（强烈推荐）</td><td>所有人</td></tr>
<tr><td><a href="#oml-核心概念">02-core-concepts.md</a></td><td>设计理念 + 类型系统 + 读取语义</td><td>想深入理解的用户</td></tr>
<tr><td><a href="#oml-实战指南">03-practical-guide.md</a></td><td>按任务组织的实战示例</td><td>日常使用者</td></tr>
<tr><td><a href="#oml-函数参考">04-functions-reference.md</a></td><td>所有函数的标准化参考</td><td>开发者</td></tr>
<tr><td><a href="#oml-集成指南">05-integration.md</a></td><td>WPL/OML/Sink 集成指南</td><td>系统集成者</td></tr>
<tr><td><a href="#oml-语法参考">06-grammar-reference.md</a></td><td>EBNF 形式化语法定义</td><td>编译器开发者</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-快速示例-1"><a class="header" href="#-快速示例-1">⚡ 快速示例</a></h2>
<h3 id="基础字段提取"><a class="header" href="#基础字段提取">基础字段提取</a></h3>
<pre><code class="language-oml">name : nginx_access
rule : /nginx/access_log
---
user_id = read(user_id) ;
uri = read(request_uri) ;
status : digit = read(status) ;
</code></pre>
<h3 id="数据聚合"><a class="header" href="#数据聚合">数据聚合</a></h3>
<pre><code class="language-oml">name : system_metrics
rule : /system/metrics
---
metrics : obj = object {
    hostname : chars = read(hostname) ;
    cpu : float = read(cpu_usage) ;
    memory : float = read(mem_usage) ;
} ;
</code></pre>
<h3 id="条件处理"><a class="header" href="#条件处理">条件处理</a></h3>
<pre><code class="language-oml">name : log_classifier
rule : /app/logs
---
level = match read(status_code) {
    in (digit(200), digit(299)) =&gt; chars(success) ;
    in (digit(400), digit(499)) =&gt; chars(client_error) ;
    in (digit(500), digit(599)) =&gt; chars(server_error) ;
    _ =&gt; chars(unknown) ;
} ;
</code></pre>
<h3 id="管道转换"><a class="header" href="#管道转换">管道转换</a></h3>
<pre><code class="language-oml">name : data_transform
rule : /data/raw
---
# 时间转时间戳
ts = read(event_time) | Time::to_ts_zone(0, ms) ;

# URL 解析
domain = read(url) | url(domain) ;
path = read(url) | url(path) ;

# Base64 解码
decoded = read(base64_data) | base64_decode(Utf8) ;
</code></pre>
<h3 id="sql-数据富化"><a class="header" href="#sql-数据富化">SQL 数据富化</a></h3>
<pre><code class="language-oml">name : user_enrichment
rule : /app/user_activity
---
user_id = read(user_id) ;

# 从数据库查询用户信息
user_name, user_level =
    select name, level
    from users
    where id = read(user_id) ;
</code></pre>
<p>更多示例请查看：<a href="#oml-完整功能示例">🌟 完整功能示例</a> 和 <a href="#oml-实战指南">实战指南</a></p>
<hr>
<h2 id="-核心特性-1"><a class="header" href="#-核心特性-1">🎯 核心特性</a></h2>
<ul>
<li><strong>声明式</strong>：描述“想要什么“，而非“怎么做“</li>
<li><strong>类型安全</strong>：8 种数据类型，自动推断或显式声明</li>
<li><strong>WPL 关联</strong>：通过 <code>rule</code> 字段匹配 WPL 解析规则</li>
<li><strong>读取模式</strong>：read（非破坏性）vs take（破坏性）</li>
<li><strong>强大的管道</strong>：链式转换（时间/编解码/URL 解析等）</li>
<li><strong>条件匹配</strong>：match 表达式支持范围、否定、多源匹配</li>
<li><strong>数据聚合</strong>：object（对象）和 collect（数组）</li>
<li><strong>SQL 集成</strong>：直接查询数据库进行数据富化</li>
</ul>
<hr>
<h2 id="-wpl-与-oml-关联"><a class="header" href="#-wpl-与-oml-关联">🔗 WPL 与 OML 关联</a></h2>
<p>OML 通过 <code>rule</code> 字段与 WPL 的 <code>package/rule</code> 建立关联：</p>
<pre><code>原始数据
    ↓
[WPL 解析] → 生成结构化数据 + rule 标识
    ↓
数据携带: rule = "/nginx/access_log"
    ↓
[查找匹配的 OML] → 匹配 rule 字段
    ↓
[执行 OML 转换]
    ↓
[输出到 Sink]
</code></pre>
<p><strong>示例</strong>：</p>
<p>WPL 规则：</p>
<pre><code class="language-wpl">package nginx {
    rule access_log {
        (ip:client_ip, chars:uri, digit:status)
    }
}
</code></pre>
<p>OML 配置：</p>
<pre><code class="language-oml">name : nginx_handler
rule : /nginx/access_log    # 匹配 WPL 的 package/rule
---
client : ip = read(client_ip) ;
uri : chars = read(uri) ;
status : digit = read(status) ;
</code></pre>
<hr>
<h2 id="-快速帮助-1"><a class="header" href="#-快速帮助-1">💬 快速帮助</a></h2>
<h3 id="常见问题-4"><a class="header" href="#常见问题-4">常见问题</a></h3>
<p><strong>Q: 从哪里开始学习？</strong>
A: 从 <a href="#oml-快速入门">01-quickstart.md</a> 开始，然后查看 <a href="#oml-完整功能示例">🌟 完整功能示例</a>。</p>
<p><strong>Q: 如何将 OML 与 WPL 关联？</strong>
A: 使用 <code>rule</code> 字段匹配 WPL 的 <code>package/rule</code> 值，详见 <a href="#oml-集成指南">05-integration.md</a>。</p>
<p><strong>Q: read 和 take 有什么区别？</strong>
A: <code>read</code> 是非破坏性的（可重复读取），<code>take</code> 是破坏性的（读取后移除），详见 <a href="#读取语义read-vs-take">02-core-concepts.md</a>。</p>
<p><strong>Q: 某个函数怎么用？</strong>
A: 查看 <a href="#oml-函数参考">04-functions-reference.md</a> 或 <a href="#oml-完整功能示例">🌟 完整功能示例</a>。</p>
<p><strong>Q: 如何调试 OML 转换？</strong>
A: 参考 <a href="#故障排查-1">05-integration.md § 故障排查</a>。</p>
<hr>
<h2 id="-相关文档-1"><a class="header" href="#-相关文档-1">📝 相关文档</a></h2>
<ul>
<li><a href="10-user/03-wpl/README.html">WPL 规则语言</a> - 数据解析</li>
<li><a href="10-user/05-connectors/02-sinks/README.html">Sink 配置</a> - 数据输出</li>
<li><a href="10-user/02-config/README.html">配置指南</a> - 系统配置</li>
</ul>
<hr>
<p><strong>开始学习：</strong> <a href="#oml-快速入门">01-quickstart.md</a> - 5分钟快速入门<br><strong>完整示例：</strong> <a href="#oml-完整功能示例">🌟 07-complete-example.md</a> - 所有功能演示</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-完整功能示例"><a class="header" href="#oml-完整功能示例">OML 完整功能示例</a></h1>
<blockquote>
<p>一个完整的示例，展示 OML 的所有核心功能</p>
</blockquote>
<p>本文档提供一个全面的 OML 示例，涵盖所有核心功能，包括基础操作、内置函数、管道函数、高级匹配等。这是学习和参考 OML 功能的最佳起点。</p>
<hr>
<h2 id="-快速导航-2"><a class="header" href="#-快速导航-2">📚 快速导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>章节</th><th>内容</th></tr>
</thead>
<tbody>
<tr><td><a href="#原始数据">原始数据</a></td><td>测试数据</td></tr>
<tr><td><a href="#wpl-解析规则">WPL 解析规则</a></td><td>数据解析规则</td></tr>
<tr><td><a href="#oml-配置">OML 配置</a></td><td>完整的 OML 转换配置</td></tr>
<tr><td><a href="#功能详解">功能详解</a></td><td>每个功能的详细说明</td></tr>
<tr><td><a href="#关键要点">关键要点</a></td><td>WPL 与 OML 关联、功能清单</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="原始数据"><a class="header" href="#原始数据">原始数据</a></h2>
<pre><code>222.133.52.20 simple_chars 80 192.168.1.10 select_one left 2025-12-29 12:00:00 {"msg":"hello"} "" aGVsbG8gd29ybGQ= ["val1","val2","val3"] /home/user/file.txt http://example.com/path/to/resource?foo=1&amp;bar=2 [{"one":{"two":"nested"}}] foo bar baz qux 500 ext_value_1 ext_value_2 http://localhost:8080/bua/sync/health?a=test 525tab beijing shanghai 10.0.0.1 10.0.0.100 success enabled true sport:8080 dport:9090 details[0]/process_name:proc1 details[1]/process_name:proc2 optional_field:exists source_field:data another_field:value
</code></pre>
<hr>
<h2 id="wpl-解析规则"><a class="header" href="#wpl-解析规则">WPL 解析规则</a></h2>
<pre><code class="language-wpl">package T4 {
    rule case {
        (
            ip:sip,
            chars:simple_chars,
            digit:simple_port,
            ip:simple_ip,
            chars:select_one,
            chars:match_chars,
            time:timestamp_zone,
            json(chars@msg: json_msg),
            chars:empty_chars,
            base64 | (chars:base64),
            array/chars:array_str,
            chars:path,
            chars:url,
            array:obj,
            chars:one,
            chars:two,
            chars:three,
            chars:four,
            digit:num_range,
            chars:extend1,
            chars:extend2,
            chars:html,
            chars:str,
            chars:city1,
            chars:city2,
            ip:src_ip,
            ip:dst_ip,
            chars:status,
            chars:enabled,
            bool:enabled
        )
    }
}
</code></pre>
<p><strong>说明</strong>：WPL 规则将原始数据解析为结构化字段，并附加 <code>rule = T4/case</code> 标识。</p>
<hr>
<h2 id="oml-配置"><a class="header" href="#oml-配置">OML 配置</a></h2>
<pre><code class="language-oml">name : T4
rule : T4/case
---

// ==================== 1. 基础操作 ====================

// 1.1 直接赋值字面量
direct_chars = chars(13);
direct_digit = digit(13);

// 1.2 简单取值
simple_chars = read(simple_chars);
simple_port : digit = read(simple_port);
simple_ip : ip = read(simple_ip);

// 1.3 选择取值（按顺序尝试多个字段）
select_chars = read(option:[select_one, select_two]);

// 1.4 默认值处理（字段不存在时使用默认值）
field_with_default = read(optional_field) { _ : chars(DEFAULT_VALUE) };
version_fallback : chars = read(version) { _ : chars(v1.0.0) };

// 1.5 多目标同时赋值
target1, target2 : chars = read();
name_alias, name_copy = read(name);

// 1.6 匿名目标（丢弃不需要的返回值）
_, useful_field = read(option:[field1, field2]);

// 1.7 take vs read 区别（破坏性 vs 非破坏性）
field_taken = take(source_field);                                    // take 会移除源字段
field_taken_again = take(source_field) { _ : chars(already_taken) }; // 再次 take 失败
field_read1 = read(another_field);                                   // read 不移除
field_read2 = read(another_field);                                   // 可重复读取

// 1.8 通配符批量操作
all_fields = take();                      // 取所有字段
path_fields = take(keys:[*/path]);        // 批量匹配：所有以 /path 结尾
a_name_fields = read(keys:[A*/name]);     // 前缀匹配：A 开头、/name 结尾

// ==================== 2. 内置函数 ====================

// 2.1 时间函数
current_time = Now::time();  // 获取当前完整时间
current_date = Now::date();  // 获取当前日期（YYYYMMDD）
current_hour = Now::hour();  // 获取当前小时（YYYYMMDDHH）

// ==================== 3. 模式匹配 ====================

// 3.1 单源 match（简单匹配）
match_chars = match read(option:[match_chars]) {
    chars(left) =&gt; chars(1);
    chars(middle) =&gt; chars(2);
    chars(right) =&gt; chars(3);
};

// 3.2 范围判断（in 操作符）
num_range = match read(option:[num_range]) {
    in (digit(0), digit(1000)) =&gt; read(num_range);
    _ =&gt; digit(0);
};

// 3.3 双源 match（匹配两个字段的组合）
location : chars = match (read(city1), read(city2)) {
    (chars(beijing), chars(shanghai)) =&gt; chars(east_region);
    (chars(chengdu), chars(chongqing)) =&gt; chars(west_region);
    _ =&gt; chars(unknown_region);
};

region_by_ip : chars = match (read(src_ip), read(dst_ip)) {
    (ip(10.0.0.1), ip(10.0.0.100)) =&gt; chars(internal);
    _ =&gt; chars(external);
};

// 3.4 match 否定条件（! 操作符）
valid_status = match read(status) {
    !chars(error) =&gt; chars(ok);
    !chars(failed) =&gt; chars(success);
    _ =&gt; chars(unknown);
};

// 3.5 布尔类型 match
is_enabled : digit = match read(enabled) {
    bool(true) =&gt; digit(1);
    bool(false) =&gt; digit(0);
    _ =&gt; digit(-1);
};

// ==================== 4. 管道函数 ====================

// 4.1 时间转换
timestamp_zone = pipe read(timestamp_zone) | Time::to_ts_zone(0, ms);  // 修改时区
timestamp_s = pipe read(timestamp_zone) | Time::to_ts;                 // 转秒级时间戳
timestamp_ms = pipe @current_time | Time::to_ts_ms;                    // 转毫秒级时间戳
timestamp_us = pipe @current_time | Time::to_ts_us;                    // 转微秒级时间戳
timestamp_zone_8 = pipe @current_time | Time::to_ts_zone(8, s);        // UTC+8 时区

// 4.2 编码/解码
base64_decoded = pipe read(base64) | base64_decode(Utf8);  // Base64 解码
base64_encoded = pipe read(base64) | base64_encode;        // Base64 编码

// 4.3 转义/反转义
html_escaped = pipe read(html) | html_escape;              // HTML 转义
html_unescaped = pipe read(html) | html_unescape;          // HTML 反转义
json_escaped = pipe read(json_escape) | json_escape;       // JSON 转义
json_unescaped = pipe @json_escaped | json_unescape;       // JSON 反转义
str_escaped = pipe read(str) | str_escape;                 // 字符串转义

// 4.4 数据转换
to_str_result = pipe read(str) | to_str;                   // 转为字符串
array_json = pipe read(array_str) | to_json;               // 数组转 JSON
ip_to_int = pipe read(simple_ip) | ip4_to_int;             // IPv4 转整数

// 4.5 集合操作
array_first = pipe read(array_str) | nth(0);               // 获取数组第 0 个元素
obj_nested = pipe read(obj) | nth(0) | get(one/two);       // 对象嵌套取值

// 4.6 数据提取
file_name = pipe read(path) | path(name);                  // 提取文件名
file_path = pipe read(path) | path(path);                  // 提取文件路径
url_domain = pipe read(url) | url(domain);                 // 提取 URL domain
url_host = pipe read(url) | url(host);                     // 提取 URL host
url_uri = pipe read(url) | url(uri);                       // 提取 URL uri
url_path = pipe read(url) | url(path);                     // 提取 URL path
url_params = pipe read(url) | url(params);                 // 提取 URL params

// 4.7 其他管道函数
skip_empty_result = pipe read(empty_chars) | skip_empty;   // 跳过空值

// 4.8 省略 pipe 关键字（新语法）
simple_transform = read(data) | to_json;                   // 直接省略 pipe
chained_ops = read(array_data) | nth(0) | to_str;          // 链式调用
url_extract = read(url_field) | url(domain);               // 简化写法

// 4.9 链式管道操作
nested_extract = pipe read(complex_obj) | nth(0) | get(level1/level2/level3);
multi_transform = pipe read(raw_data) | base64_decode(Utf8) | to_json;

// ==================== 5. 字符串操作 ====================

// 5.1 字符串格式化（fmt 函数）
splice = fmt("{one}:{two}|{three}:{four}", read(one), read(two), read(three), read(four));

// ==================== 6. 对象与数组 ====================

// 6.1 对象创建（聚合多个字段）
extends = object {
    extend1, extend2 = read();
};

// 6.2 数组收集（collect）
collected_ports : array = collect read(keys:[sport, dport, extra_port]);
wildcard_items : array = collect take(keys:[details[*]/process_name]);  // 支持通配符收集
</code></pre>
<hr>
<h2 id="功能详解"><a class="header" href="#功能详解">功能详解</a></h2>
<h3 id="1-基础操作"><a class="header" href="#1-基础操作">1. 基础操作</a></h3>
<h4 id="11-字面量赋值"><a class="header" href="#11-字面量赋值">1.1 字面量赋值</a></h4>
<p>直接创建常量值：</p>
<pre><code class="language-oml">direct_chars = chars(13);
direct_digit = digit(13);
</code></pre>
<h4 id="12-简单取值"><a class="header" href="#12-简单取值">1.2 简单取值</a></h4>
<p>从输入数据读取字段：</p>
<pre><code class="language-oml">simple_chars = read(simple_chars);
simple_port : digit = read(simple_port);  // 显式类型转换
simple_ip : ip = read(simple_ip);
</code></pre>
<h4 id="13-选择取值"><a class="header" href="#13-选择取值">1.3 选择取值</a></h4>
<p>按优先级尝试多个字段：</p>
<pre><code class="language-oml">select_chars = read(option:[select_one, select_two]);
// 先尝试 select_one，不存在则尝试 select_two
</code></pre>
<h4 id="14-默认值处理"><a class="header" href="#14-默认值处理">1.4 默认值处理</a></h4>
<p>字段不存在时使用默认值：</p>
<pre><code class="language-oml">field_with_default = read(optional_field) { _ : chars(DEFAULT_VALUE) };
version_fallback : chars = read(version) { _ : chars(v1.0.0) };
</code></pre>
<h4 id="15-多目标赋值"><a class="header" href="#15-多目标赋值">1.5 多目标赋值</a></h4>
<p>一次赋值给多个目标：</p>
<pre><code class="language-oml">target1, target2 : chars = read();
name_alias, name_copy = read(name);
</code></pre>
<h4 id="16-匿名目标"><a class="header" href="#16-匿名目标">1.6 匿名目标</a></h4>
<p>丢弃不需要的返回值：</p>
<pre><code class="language-oml">_, useful_field = read(option:[field1, field2]);
// 第一个返回值被丢弃
</code></pre>
<h4 id="17-take-vs-read"><a class="header" href="#17-take-vs-read">1.7 take vs read</a></h4>
<ul>
<li><code>take</code>：破坏性读取，移除源字段</li>
<li><code>read</code>：非破坏性读取，保留源字段</li>
</ul>
<pre><code class="language-oml">field_taken = take(source_field);      // 源字段被移除
field_taken_again = take(source_field) { _ : chars(already_taken) }; // 失败

field_read1 = read(another_field);     // 源字段保留
field_read2 = read(another_field);     // 可以再次读取
</code></pre>
<h4 id="18-通配符批量操作"><a class="header" href="#18-通配符批量操作">1.8 通配符批量操作</a></h4>
<p>使用通配符匹配多个字段：</p>
<pre><code class="language-oml">all_fields = take();                   // 取所有字段
path_fields = take(keys:[*/path]);     // 所有以 /path 结尾
a_name_fields = read(keys:[A*/name]);  // A 开头、/name 结尾
</code></pre>
<hr>
<h3 id="2-内置函数"><a class="header" href="#2-内置函数">2. 内置函数</a></h3>
<p>时间相关函数：</p>
<pre><code class="language-oml">current_time = Now::time();  // 2025-12-29 12:00:00
current_date = Now::date();  // 20251229
current_hour = Now::hour();  // 2025122912
</code></pre>
<hr>
<h3 id="3-模式匹配"><a class="header" href="#3-模式匹配">3. 模式匹配</a></h3>
<h4 id="31-单源-match"><a class="header" href="#31-单源-match">3.1 单源 match</a></h4>
<p>基于单个字段的值进行匹配：</p>
<pre><code class="language-oml">match_chars = match read(option:[match_chars]) {
    chars(left) =&gt; chars(1);
    chars(middle) =&gt; chars(2);
    chars(right) =&gt; chars(3);
};
</code></pre>
<h4 id="32-范围判断"><a class="header" href="#32-范围判断">3.2 范围判断</a></h4>
<p>使用 <code>in</code> 操作符判断范围：</p>
<pre><code class="language-oml">num_range = match read(option:[num_range]) {
    in (digit(0), digit(1000)) =&gt; read(num_range);
    _ =&gt; digit(0);
};
</code></pre>
<h4 id="33-双源-match"><a class="header" href="#33-双源-match">3.3 双源 match</a></h4>
<p>匹配两个字段的组合：</p>
<pre><code class="language-oml">location : chars = match (read(city1), read(city2)) {
    (chars(beijing), chars(shanghai)) =&gt; chars(east_region);
    (chars(chengdu), chars(chongqing)) =&gt; chars(west_region);
    _ =&gt; chars(unknown_region);
};
</code></pre>
<h4 id="34-否定条件"><a class="header" href="#34-否定条件">3.4 否定条件</a></h4>
<p>使用 <code>!</code> 操作符进行否定匹配：</p>
<pre><code class="language-oml">valid_status = match read(status) {
    !chars(error) =&gt; chars(ok);
    !chars(failed) =&gt; chars(success);
    _ =&gt; chars(unknown);
};
</code></pre>
<h4 id="35-布尔类型-match"><a class="header" href="#35-布尔类型-match">3.5 布尔类型 match</a></h4>
<p>匹配布尔值：</p>
<pre><code class="language-oml">is_enabled : digit = match read(enabled) {
    bool(true) =&gt; digit(1);
    bool(false) =&gt; digit(0);
    _ =&gt; digit(-1);
};
</code></pre>
<hr>
<h3 id="4-管道函数"><a class="header" href="#4-管道函数">4. 管道函数</a></h3>
<h4 id="41-时间转换"><a class="header" href="#41-时间转换">4.1 时间转换</a></h4>
<pre><code class="language-oml">timestamp_zone = pipe read(timestamp_zone) | Time::to_ts_zone(0, ms);  // UTC 毫秒
timestamp_s = pipe read(timestamp_zone) | Time::to_ts;                 // 秒级
timestamp_ms = pipe @current_time | Time::to_ts_ms;                    // 毫秒级
timestamp_us = pipe @current_time | Time::to_ts_us;                    // 微秒级
timestamp_zone_8 = pipe @current_time | Time::to_ts_zone(8, s);        // UTC+8
</code></pre>
<h4 id="42-编码解码"><a class="header" href="#42-编码解码">4.2 编码/解码</a></h4>
<pre><code class="language-oml">base64_decoded = pipe read(base64) | base64_decode(Utf8);
base64_encoded = pipe read(base64) | base64_encode;
</code></pre>
<h4 id="43-转义反转义"><a class="header" href="#43-转义反转义">4.3 转义/反转义</a></h4>
<pre><code class="language-oml">html_escaped = pipe read(html) | html_escape;
html_unescaped = pipe read(html) | html_unescape;
json_escaped = pipe read(json_escape) | json_escape;
json_unescaped = pipe @json_escaped | json_unescape;
str_escaped = pipe read(str) | str_escape;
</code></pre>
<h4 id="44-数据转换"><a class="header" href="#44-数据转换">4.4 数据转换</a></h4>
<pre><code class="language-oml">to_str_result = pipe read(str) | to_str;
array_json = pipe read(array_str) | to_json;
ip_to_int = pipe read(simple_ip) | ip4_to_int;
</code></pre>
<h4 id="45-集合操作"><a class="header" href="#45-集合操作">4.5 集合操作</a></h4>
<pre><code class="language-oml">array_first = pipe read(array_str) | nth(0);           // 获取第 0 个元素
obj_nested = pipe read(obj) | nth(0) | get(one/two);   // 嵌套取值
</code></pre>
<h4 id="46-数据提取"><a class="header" href="#46-数据提取">4.6 数据提取</a></h4>
<pre><code class="language-oml">file_name = pipe read(path) | path(name);      // file.txt
file_path = pipe read(path) | path(path);      // /home/user
url_domain = pipe read(url) | url(domain);     // example.com
url_host = pipe read(url) | url(host);         // example.com
url_uri = pipe read(url) | url(uri);           // /path/to/resource?foo=1&amp;bar=2
url_path = pipe read(url) | url(path);         // /path/to/resource
url_params = pipe read(url) | url(params);     // foo=1&amp;bar=2
</code></pre>
<h4 id="47-控制函数"><a class="header" href="#47-控制函数">4.7 控制函数</a></h4>
<pre><code class="language-oml">skip_empty_result = pipe read(empty_chars) | skip_empty;  // 跳过空值
</code></pre>
<h4 id="48-简化语法"><a class="header" href="#48-简化语法">4.8 简化语法</a></h4>
<p>省略 <code>pipe</code> 关键字：</p>
<pre><code class="language-oml">simple_transform = read(data) | to_json;
chained_ops = read(array_data) | nth(0) | to_str;
url_extract = read(url_field) | url(domain);
</code></pre>
<h4 id="49-链式操作"><a class="header" href="#49-链式操作">4.9 链式操作</a></h4>
<pre><code class="language-oml">nested_extract = pipe read(complex_obj) | nth(0) | get(level1/level2/level3);
multi_transform = pipe read(raw_data) | base64_decode(Utf8) | to_json;
</code></pre>
<hr>
<h3 id="5-字符串操作"><a class="header" href="#5-字符串操作">5. 字符串操作</a></h3>
<p>格式化字符串：</p>
<pre><code class="language-oml">splice = fmt("{one}:{two}|{three}:{four}", read(one), read(two), read(three), read(four));
// 输出：foo:bar|baz:qux
</code></pre>
<hr>
<h3 id="6-对象与数组"><a class="header" href="#6-对象与数组">6. 对象与数组</a></h3>
<h4 id="61-对象创建"><a class="header" href="#61-对象创建">6.1 对象创建</a></h4>
<p>聚合多个字段为对象：</p>
<pre><code class="language-oml">extends = object {
    extend1, extend2 = read();
};
</code></pre>
<h4 id="62-数组收集"><a class="header" href="#62-数组收集">6.2 数组收集</a></h4>
<p>收集多个字段为数组：</p>
<pre><code class="language-oml">collected_ports : array = collect read(keys:[sport, dport, extra_port]);
// 输出：[8080, 9090, ...]

wildcard_items : array = collect take(keys:[details[*]/process_name]);
// 输出：["proc1", "proc2"]
</code></pre>
<hr>
<h2 id="关键要点"><a class="header" href="#关键要点">关键要点</a></h2>
<h3 id="wpl-与-oml-关联"><a class="header" href="#wpl-与-oml-关联">WPL 与 OML 关联</a></h3>
<pre><code>原始数据
    ↓
[WPL 解析] → 生成结构化数据 + rule 标识
    ↓
数据携带: rule = "T4/case"
    ↓
[查找匹配的 OML] → 匹配 rule 字段
    ↓
[执行 OML 转换] → 应用本示例的转换逻辑
    ↓
输出到 Sink
</code></pre>
<p><strong>关键</strong>：OML 的 <code>rule : T4/case</code> 与 WPL 的 <code>package T4 { rule case { ... } }</code> 对应。</p>
<h3 id="功能覆盖清单"><a class="header" href="#功能覆盖清单">功能覆盖清单</a></h3>
<ul>
<li>✅ 基础操作：字面量、取值、默认值、通配符</li>
<li>✅ 内置函数：时间函数</li>
<li>✅ 模式匹配：单源、双源、范围、否定、布尔</li>
<li>✅ 管道函数：时间、编解码、转义、转换、集合、提取</li>
<li>✅ 字符串操作：格式化</li>
<li>✅ 对象与数组：聚合、收集</li>
</ul>
<hr>
<h2 id="下一步-4"><a class="header" href="#下一步-4">下一步</a></h2>
<ul>
<li><a href="#oml-快速入门">快速入门</a> - 学习基础语法</li>
<li><a href="#oml-核心概念">核心概念</a> - 理解设计理念</li>
<li><a href="#oml-实战指南">实战指南</a> - 查找具体任务的解决方案</li>
<li><a href="#oml-函数参考">函数参考</a> - 查阅所有可用函数</li>
<li><a href="#oml-集成指南">集成指南</a> - 了解如何集成到数据流</li>
</ul>
<hr>
<p><strong>提示</strong>：这个示例是学习 OML 的最佳参考，建议收藏并在实际使用时对照查阅。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-快速入门"><a class="header" href="#oml-快速入门">OML 快速入门</a></h1>
<blockquote>
<p>5 分钟快速上手 OML（Object Modeling Language）</p>
</blockquote>
<p><strong>💡 提示</strong>：想要查看所有功能的完整演示？请访问 <strong><a href="#oml-完整功能示例">完整功能示例</a></strong></p>
<hr>
<h2 id="-快速导航-3"><a class="header" href="#-快速导航-3">📚 快速导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>章节</th><th>内容</th></tr>
</thead>
<tbody>
<tr><td><a href="#什么是-oml">什么是 OML</a></td><td>OML 简介</td></tr>
<tr><td><a href="#最小示例-1">最小示例</a></td><td>5 行代码上手</td></tr>
<tr><td><a href="#基本语法-7">基本语法</a></td><td>配置结构、WPL 关联、语法规则</td></tr>
<tr><td><a href="#三个最常用操作">三个最常用操作</a></td><td>读取字段、类型转换、数据聚合</td></tr>
<tr><td><a href="#常用数据类型">常用数据类型</a></td><td>8 种数据类型速查</td></tr>
<tr><td><a href="#常用内置函数">常用内置函数</a></td><td>时间函数</td></tr>
<tr><td><a href="#read-vs-take两种读取模式">read vs take</a></td><td>两种读取模式对比</td></tr>
<tr><td><a href="#完整示例日志处理">完整示例</a></td><td>日志处理完整示例</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="什么是-oml"><a class="header" href="#什么是-oml">什么是 OML</a></h2>
<p>OML 是一种声明式的数据转换语言，用于将解析后的结构化数据转换为目标格式。它提供了简洁的语法来完成字段提取、类型转换、数据聚合等常见操作。</p>
<h2 id="最小示例-1"><a class="header" href="#最小示例-1">最小示例</a></h2>
<pre><code class="language-oml">name : my_first_oml
rule : /nginx/access_log
---
user_id = read(user_id) ;
timestamp : time = Now::time() ;
</code></pre>
<p><strong>说明</strong>：</p>
<ul>
<li><code>name : my_first_oml</code> - OML 配置名称声明</li>
<li><code>rule : /nginx/access_log</code> - 匹配 WPL 的 package/rule 值（关键！）</li>
<li><code>---</code> - 分隔符，区分声明区和配置区</li>
<li><code>user_id = read(user_id)</code> - 从输入读取 user_id 字段</li>
<li><code>timestamp : time = Now::time()</code> - 调用内置函数获取当前时间</li>
</ul>
<p><strong>重要</strong>：<code>rule</code> 字段用于关联 WPL 解析规则，只有当数据的 WPL rule 匹配时，这个 OML 配置才会被应用。</p>
<h2 id="基本语法-7"><a class="header" href="#基本语法-7">基本语法</a></h2>
<h3 id="1-配置结构"><a class="header" href="#1-配置结构">1. 配置结构</a></h3>
<pre><code class="language-oml">name : &lt;配置名称&gt;
rule : &lt;WPL 规则匹配模式&gt;
---
&lt;目标字段&gt;[:&lt;类型&gt;] = &lt;表达式&gt; ;
</code></pre>
<h3 id="2-wpl-与-oml-的关联"><a class="header" href="#2-wpl-与-oml-的关联">2. WPL 与 OML 的关联</a></h3>
<p><strong>关键概念</strong>：一个 WPL 规则可以对应一个或多个 OML 配置。</p>
<pre><code>WPL 解析 → 数据携带 rule 标识 → 匹配 OML 的 rule 字段 → 执行转换
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># OML 配置
name : nginx_access
rule : /nginx/access_log    # 匹配 WPL 的 package/rule 值
---
# 转换逻辑...
</code></pre>
<p>当 WPL 解析后的数据携带 <code>rule = /nginx/access_log</code> 时，这个 OML 配置会被自动应用。</p>
<p><strong>支持通配符</strong>：</p>
<ul>
<li><code>rule : /nginx/*</code> - 匹配所有 /nginx/ 开头的规则</li>
<li><code>rule : */access_log</code> - 匹配所有以 /access_log 结尾的规则</li>
<li><code>rule : *</code> - 匹配所有规则</li>
</ul>
<h3 id="3-必须记住的规则"><a class="header" href="#3-必须记住的规则">3. 必须记住的规则</a></h3>
<ul>
<li>每个配置条目必须以分号 <code>;</code> 结束</li>
<li>使用 <code>---</code> 分隔配置的不同部分</li>
<li><code>rule</code> 字段用于匹配 WPL 的 package/rule 值</li>
<li>类型声明可选，默认为 <code>auto</code> 自动推断</li>
</ul>
<h2 id="三个最常用操作"><a class="header" href="#三个最常用操作">三个最常用操作</a></h2>
<h3 id="操作-1读取字段"><a class="header" href="#操作-1读取字段">操作 1：读取字段</a></h3>
<p><strong>场景</strong>：从输入数据中提取字段</p>
<pre><code class="language-oml">name : read_example
---
# 读取单个字段
user_id = read(user_id) ;

# 读取并指定类型
port : digit = read(port) ;

# 读取时提供默认值
country = read(country) { _ : chars(CN) } ;
</code></pre>
<p><strong>输入示例</strong>：</p>
<pre><code>user_id = "user123"
port = "8080"
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>user_id = "user123"
port = 8080
country = "CN"  # 使用默认值
</code></pre>
<h3 id="操作-2类型转换"><a class="header" href="#操作-2类型转换">操作 2：类型转换</a></h3>
<p><strong>场景</strong>：转换字段类型</p>
<pre><code class="language-oml">name : type_conversion
---
# 字符串转 IP
src_ip : ip = read(src_ip) ;

# 字符串转整数
port : digit = read(port) ;

# 字符串转浮点数
cpu_usage : float = read(cpu) ;

# 字符串转时间
event_time : time = read(time) ;
</code></pre>
<p><strong>输入示例</strong>：</p>
<pre><code>src_ip = "192.168.1.100"
port = "8080"
cpu = "85.5"
time = "2024-01-15 14:30:00"
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>src_ip = 192.168.1.100  # IP 类型
port = 8080              # 整数
cpu_usage = 85.5         # 浮点数
event_time = 2024-01-15 14:30:00  # 时间类型
</code></pre>
<h3 id="操作-3数据聚合"><a class="header" href="#操作-3数据聚合">操作 3：数据聚合</a></h3>
<p><strong>场景</strong>：将多个字段组合成对象或数组</p>
<h4 id="创建对象"><a class="header" href="#创建对象">创建对象</a></h4>
<pre><code class="language-oml">name : create_object
---
system_info : obj = object {
    hostname : chars = read(hostname) ;
    cpu : float = read(cpu_usage) ;
    memory : float = read(mem_usage) ;
} ;
</code></pre>
<p><strong>输入</strong>：</p>
<pre><code>hostname = "web-server-01"
cpu_usage = "75.5"
mem_usage = "60.2"
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-json">{
    "system_info": {
        "hostname": "web-server-01",
        "cpu": 75.5,
        "memory": 60.2
    }
}
</code></pre>
<h4 id="创建数组"><a class="header" href="#创建数组">创建数组</a></h4>
<pre><code class="language-oml">name : create_array
---
# 收集多个字段到数组
ports : array = collect read(keys:[sport, dport]) ;
</code></pre>
<p><strong>输入</strong>：</p>
<pre><code>sport = "8080"
dport = "443"
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>ports = [8080, 443]
</code></pre>
<h2 id="常用数据类型"><a class="header" href="#常用数据类型">常用数据类型</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类型</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><code>auto</code></td><td>自动推断（默认）</td><td><code>value = read() ;</code></td></tr>
<tr><td><code>chars</code></td><td>字符串</td><td><code>name : chars = read() ;</code></td></tr>
<tr><td><code>digit</code></td><td>整数</td><td><code>count : digit = read() ;</code></td></tr>
<tr><td><code>float</code></td><td>浮点数</td><td><code>ratio : float = read() ;</code></td></tr>
<tr><td><code>ip</code></td><td>IP 地址</td><td><code>addr : ip = read() ;</code></td></tr>
<tr><td><code>time</code></td><td>时间</td><td><code>timestamp : time = Now::time() ;</code></td></tr>
<tr><td><code>obj</code></td><td>对象</td><td><code>info : obj = object { ... } ;</code></td></tr>
<tr><td><code>array</code></td><td>数组</td><td><code>items : array = collect read(...) ;</code></td></tr>
</tbody>
</table>
</div>
<h2 id="常用内置函数"><a class="header" href="#常用内置函数">常用内置函数</a></h2>
<pre><code class="language-oml">name : builtin_functions
---
# 获取当前时间
now : time = Now::time() ;

# 获取当前日期（YYYYMMDD 格式）
today : digit = Now::date() ;

# 获取当前小时（YYYYMMDDHH 格式）
current_hour : digit = Now::hour() ;
</code></pre>
<h2 id="read-vs-take两种读取模式"><a class="header" href="#read-vs-take两种读取模式">read vs take：两种读取模式</a></h2>
<h3 id="read非破坏性"><a class="header" href="#read非破坏性">read（非破坏性）</a></h3>
<ul>
<li>可以多次读取同一字段</li>
<li>不会从输入中移除字段</li>
</ul>
<pre><code class="language-oml">name : read_mode
---
field1 = read(data) ;
field2 = read(data) ;  # 仍可读取到 data
</code></pre>
<h3 id="take破坏性"><a class="header" href="#take破坏性">take（破坏性）</a></h3>
<ul>
<li>读取后会从输入中移除</li>
<li>后续无法再读取同一字段</li>
</ul>
<pre><code class="language-oml">name : take_mode
---
field1 = take(data) ;
field2 = take(data) ;  # 读取失败，data 已被移除
</code></pre>
<p><strong>使用建议</strong>：</p>
<ul>
<li>需要复用字段时使用 <code>read</code></li>
<li>确保字段只使用一次时使用 <code>take</code></li>
</ul>
<h2 id="完整示例日志处理"><a class="header" href="#完整示例日志处理">完整示例：日志处理</a></h2>
<p>这个示例展示了 OML 的主要功能：字段提取、类型转换、条件判断、数据聚合。</p>
<p><strong>输入数据（WPL 解析后）：</strong></p>
<pre><code>user_id = "user123"
uri = "/api/users"
status = "200"
timestamp = "2024-01-15 14:30:00"
</code></pre>
<p><strong>OML 配置：</strong></p>
<pre><code class="language-oml">name : access_log_processor
rule : /nginx/access_log
---
# 基础字段提取
user_id = read(user_id) ;
request_uri = read(uri) ;
status_code : digit = read(status) ;

# 时间处理
event_time : time = read(timestamp) ;
event_date : digit = Now::date() ;

# 条件转换（状态码分类）
status_level = match read(status_code) {
    in (digit(200), digit(299)) =&gt; chars(success) ;
    in (digit(400), digit(499)) =&gt; chars(client_error) ;
    in (digit(500), digit(599)) =&gt; chars(server_error) ;
    _ =&gt; chars(other) ;
} ;

# 数据聚合
log_entry : obj = object {
    user : chars = read(user_id) ;
    uri : chars = read(request_uri) ;
    status : digit = read(status_code) ;
    level : chars = read(status_level) ;
    time : time = read(event_time) ;
} ;
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code class="language-json">{
    "log_entry": {
        "user": "user123",
        "uri": "/api/users",
        "status": 200,
        "level": "success",
        "time": "2024-01-15 14:30:00"
    }
}
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li><code>rule : /nginx/access_log</code> 匹配 WPL 的 package/rule 值</li>
<li><code>match</code> 表达式实现条件分类</li>
<li><code>object</code> 聚合多个字段为结构化输出</li>
<li>类型自动转换（<code>status</code> 从字符串转为整数）</li>
</ul>
<hr>
<h2 id="-完整类型系统与功能"><a class="header" href="#-完整类型系统与功能">📚 完整类型系统与功能</a></h2>
<p><strong>OML 支持 8 种数据类型和丰富的函数库</strong>，涵盖数据提取、转换、聚合、条件处理等。</p>
<p>👉 <strong>查看完整示例：</strong> <a href="#oml-完整功能示例">07-complete-example.md</a></p>
<p>该文档包含：</p>
<ul>
<li>✅ 所有核心功能的完整示例代码</li>
<li>✅ 可运行的原始数据、WPL 规则和 OML 配置</li>
<li>✅ 每个功能的详细说明和使用建议</li>
<li>✅ 基础操作、内置函数、管道函数、模式匹配等</li>
</ul>
<p><strong>快速预览主要功能：</strong></p>
<ul>
<li><strong>基础操作</strong>：字面量赋值、取值、默认值、通配符批量操作</li>
<li><strong>内置函数</strong>：<code>Now::time()</code>、<code>Now::date()</code>、<code>Now::hour()</code></li>
<li><strong>管道函数</strong>：Base64 编解码、HTML 转义、时间转换、URL 解析</li>
<li><strong>模式匹配</strong>：单源/双源 match、范围判断、否定条件</li>
<li><strong>数据聚合</strong>：对象创建、数组收集</li>
<li><strong>SQL 集成</strong>：数据库查询和富化</li>
</ul>
<hr>
<h2 id="下一步学习"><a class="header" href="#下一步学习">下一步学习</a></h2>
<h3 id="理解概念-1"><a class="header" href="#理解概念-1">理解概念</a></h3>
<ul>
<li><a href="#oml-核心概念">核心概念</a> - 深入理解 OML 的设计理念
<ul>
<li>WPL 与 OML 协作关系</li>
<li>read vs take 读取语义</li>
<li>类型系统和表达式</li>
</ul>
</li>
</ul>
<h3 id="实战应用-1"><a class="header" href="#实战应用-1">实战应用</a></h3>
<ul>
<li><a href="#oml-实战指南">实战指南</a> - 按任务查找解决方案
<ul>
<li>数据提取、转换、聚合</li>
<li>条件处理、SQL 查询</li>
<li>复杂场景示例</li>
</ul>
</li>
</ul>
<h3 id="查阅参考-2"><a class="header" href="#查阅参考-2">查阅参考</a></h3>
<ul>
<li><a href="#oml-函数参考">函数参考</a> - 查阅所有可用函数</li>
<li><a href="#oml-集成指南">集成指南</a> - 将 OML 集成到数据流</li>
<li><a href="#oml-语法参考">语法参考</a> - 完整的语法规则</li>
</ul>
<hr>
<h2 id="快速提示"><a class="header" href="#快速提示">快速提示</a></h2>
<ol>
<li><strong>从简单开始</strong>：先使用基本的 read 操作，熟悉后再使用高级特性</li>
<li><strong>显式类型</strong>：对于重要字段，建议显式声明类型避免意外转换</li>
<li><strong>提供默认值</strong>：对于可能缺失的字段，使用 <code>{ _ : &lt;默认值&gt; }</code> 语法</li>
<li><strong>使用对象组织数据</strong>：复杂数据用 <code>object</code> 聚合，便于理解和维护</li>
<li><strong>分号不能省</strong>：每个配置条目必须以分号结束</li>
</ol>
<hr>
<h2 id="相关资源-3"><a class="header" href="#相关资源-3">相关资源</a></h2>
<ul>
<li>完整功能示例：<a href="#oml-完整功能示例">07-complete-example.md</a></li>
<li>WPL 规则语言：<a href="10-user/03-wpl/README.html">../03-wpl/README.md</a></li>
<li>配置指南：<a href="10-user/02-config/README.html">../02-config/README.md</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-核心概念"><a class="header" href="#oml-核心概念">OML 核心概念</a></h1>
<p>本文档介绍 OML 的核心设计理念和基础概念，帮助你深入理解 OML 的工作原理。</p>
<hr>
<h2 id="-文档导航-6"><a class="header" href="#-文档导航-6">📚 文档导航</a></h2>
<h3 id="快速导航-1"><a class="header" href="#快速导航-1">快速导航</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>主题</th><th>内容</th></tr>
</thead>
<tbody>
<tr><td><a href="#oml-设计理念"><strong>设计理念</strong></a></td><td>WPL 协作关系、声明式语法、不可变数据流</td></tr>
<tr><td><a href="#类型系统-1"><strong>类型系统</strong></a></td><td>8 种基本类型、自动推断、类型转换</td></tr>
<tr><td><a href="#读取语义read-vs-take"><strong>读取语义</strong></a></td><td>read vs take、破坏性与非破坏性、读取优先级</td></tr>
<tr><td><a href="#表达式类型"><strong>表达式类型</strong></a></td><td>值表达式、函数调用、管道、条件、聚合</td></tr>
<tr><td><a href="#默认值机制"><strong>默认值机制</strong></a></td><td>默认值语法、函数默认值、限制说明</td></tr>
<tr><td><a href="#通配符与批量处理"><strong>通配符</strong></a></td><td>通配符语法、批量目标、使用限制</td></tr>
<tr><td><a href="#参数化读取"><strong>参数化读取</strong></a></td><td>option 优先级、keys 收集、JSON 路径</td></tr>
<tr><td><a href="#表达式组合"><strong>表达式组合</strong></a></td><td>嵌套对象、管道链、复杂 match</td></tr>
<tr><td><a href="#作用域规则"><strong>作用域规则</strong></a></td><td>目标字段作用域、全局字段</td></tr>
<tr><td><a href="#最佳实践-7"><strong>最佳实践</strong></a></td><td>读取模式选择、类型声明、默认值、通配符使用</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="oml-设计理念"><a class="header" href="#oml-设计理念">OML 设计理念</a></h2>
<h3 id="wpl-与-oml-的协作关系"><a class="header" href="#wpl-与-oml-的协作关系">WPL 与 OML 的协作关系</a></h3>
<p>OML 不是独立工作的，它与 WPL 紧密配合：</p>
<pre><code>1. WPL 解析原始数据
   ↓
2. 生成结构化数据 + rule 标识（如 /nginx/access_log）
   ↓
3. 系统查找匹配的 OML 配置（通过 rule 字段）
   ↓
4. 执行 OML 转换
   ↓
5. 输出到 Sink
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>每个 OML 配置通过 <code>rule</code> 字段声明它处理哪些 WPL 规则的数据</li>
<li>一个 WPL 规则可以对应多个 OML 配置</li>
<li>支持通配符匹配，如 <code>rule : /nginx/*</code> 匹配所有 nginx 相关规则</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">name : nginx_access_handler
rule : /nginx/access_log    # 只处理这个 WPL 规则的数据
---
# 转换逻辑...
</code></pre>
<h3 id="声明式而非命令式"><a class="header" href="#声明式而非命令式">声明式而非命令式</a></h3>
<p>OML 采用声明式语法，你只需要描述<strong>想要什么结果</strong>，而不是<strong>如何实现</strong>：</p>
<pre><code class="language-oml"># 声明式：描述结果
user_info : obj = object {
    id : chars = read(user_id) ;
    name : chars = read(username) ;
} ;
</code></pre>
<p>对比命令式伪代码：</p>
<pre><code>user_info = new Object()
user_info.id = get_field("user_id")
user_info.name = get_field("username")
convert_to_chars(user_info.id)
convert_to_chars(user_info.name)
</code></pre>
<h3 id="不可变数据流"><a class="header" href="#不可变数据流">不可变数据流</a></h3>
<p>OML 中的数据转换是单向流动的：</p>
<pre><code>输入数据 → OML 转换 → 输出数据
</code></pre>
<ul>
<li>输入数据不会被修改（除非使用 <code>take</code>）</li>
<li>每个转换步骤都产生新的值</li>
<li>便于理解和调试</li>
</ul>
<h2 id="类型系统-1"><a class="header" href="#类型系统-1">类型系统</a></h2>
<h3 id="基本类型"><a class="header" href="#基本类型">基本类型</a></h3>
<p>OML 提供 8 种基本数据类型：</p>
<pre><code class="language-oml">name : types_example
---
# 字符串
text : chars = chars(hello) ;

# 整数
count : digit = digit(42) ;

# 浮点数
ratio : float = float(3.14) ;

# IP 地址
address : ip = ip(192.168.1.1) ;

# 时间
timestamp : time = Now::time() ;

# 布尔值
flag : bool = bool(true) ;

# 对象
info : obj = object { ... } ;

# 数组
items : array = collect read(keys:[...]) ;
</code></pre>
<h3 id="自动类型推断"><a class="header" href="#自动类型推断">自动类型推断</a></h3>
<p>当不指定类型时，OML 会自动推断：</p>
<pre><code class="language-oml">name : auto_type
---
# 自动推断为 chars
name = read(name) ;

# 自动推断为 digit
count = digit(100) ;

# 显式指定类型（推荐）
port : digit = read(port) ;
</code></pre>
<p><strong>最佳实践</strong>：对于重要字段，建议显式声明类型以避免意外。</p>
<h3 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h3>
<p>OML 会在必要时自动进行类型转换：</p>
<pre><code class="language-oml">name : type_cast
---
# 从字符串 "8080" 转换为整数 8080
port : digit = read(port) ;

# 从字符串 "192.168.1.1" 转换为 IP
ip_addr : ip = read(src_ip) ;

# 从字符串转换为时间
event_time : time = read(timestamp) ;
</code></pre>
<h2 id="读取语义read-vs-take"><a class="header" href="#读取语义read-vs-take">读取语义：read vs take</a></h2>
<p>这是 OML 中最重要的概念之一。</p>
<h3 id="read非破坏性读取"><a class="header" href="#read非破坏性读取">read：非破坏性读取</a></h3>
<p><strong>特性</strong>：</p>
<ul>
<li>从源数据<strong>克隆</strong>值到目标</li>
<li>源数据保持不变</li>
<li>可以多次读取同一字段</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>字段需要在多处使用</li>
<li>需要保留原始数据</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">name : read_example
---
# 假设输入：data = "hello"

field1 = read(data) ;  # field1 = "hello"，src.data 仍存在
field2 = read(data) ;  # field2 = "hello"，可以再次读取
field3 = read(data) ;  # field3 = "hello"，仍然可以读取
</code></pre>
<h3 id="take破坏性读取"><a class="header" href="#take破坏性读取">take：破坏性读取</a></h3>
<p><strong>特性</strong>：</p>
<ul>
<li>从源数据<strong>移走</strong>值到目标</li>
<li>源数据中该字段被删除</li>
<li>只能读取一次</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>字段只需要使用一次</li>
<li>需要确保字段不被重复使用</li>
<li>优化性能（避免数据复制）</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">name : take_example
---
# 假设输入：data = "hello"

field1 = take(data) ;  # field1 = "hello"，src.data 被移除
field2 = take(data) ;  # 失败！data 已经不存在
</code></pre>
<h3 id="读取优先级"><a class="header" href="#读取优先级">读取优先级</a></h3>
<p><code>read</code> 和 <code>take</code> 都遵循以下查找顺序：</p>
<ol>
<li>先查找<strong>目标记录</strong>（dst）</li>
<li>如果未找到，再查找<strong>源记录</strong>（src）</li>
</ol>
<pre><code class="language-oml">name : lookup_priority
---
# 假设：src.value = "A"

field1 = read(value) ;     # "A" (从 src 读取)
field2 = read(field1) ;    # "A" (从 dst 读取，field1 已在目标中)
</code></pre>
<h2 id="表达式类型"><a class="header" href="#表达式类型">表达式类型</a></h2>
<h3 id="值表达式"><a class="header" href="#值表达式">值表达式</a></h3>
<p>直接构造常量值：</p>
<pre><code class="language-oml">name : value_expr
---
# 字符串
text = chars(hello) ;

# 整数
count = digit(100) ;

# IP
ip_addr = ip(192.168.1.1) ;
</code></pre>
<h3 id="函数调用"><a class="header" href="#函数调用">函数调用</a></h3>
<p>调用内置函数：</p>
<pre><code class="language-oml">name : function_call
---
# 时间函数
now = Now::time() ;
today = Now::date() ;
hour = Now::hour() ;
</code></pre>
<h3 id="管道表达式"><a class="header" href="#管道表达式">管道表达式</a></h3>
<p>链式处理数据：</p>
<pre><code class="language-oml">name : pipe_expr
---
# 读取 → 转 JSON → Base64 编码
encoded = pipe read(data) | to_json | base64_encode ;

# 也可以省略 pipe 关键字
encoded2 = read(data) | to_json | base64_encode ;
</code></pre>
<h3 id="条件表达式"><a class="header" href="#条件表达式">条件表达式</a></h3>
<p>基于条件选择值：</p>
<pre><code class="language-oml">name : match_expr
---
level = match read(status) {
    in (digit(200), digit(299)) =&gt; chars(success) ;
    in (digit(400), digit(499)) =&gt; chars(error) ;
    _ =&gt; chars(other) ;
} ;
</code></pre>
<h3 id="聚合表达式"><a class="header" href="#聚合表达式">聚合表达式</a></h3>
<p>创建复合数据结构：</p>
<pre><code class="language-oml">name : aggregate_expr
---
# 对象聚合
info : obj = object {
    name = read(name) ;
    age = read(age) ;
} ;

# 数组聚合
items : array = collect read(keys:[a, b, c]) ;
</code></pre>
<h2 id="默认值机制"><a class="header" href="#默认值机制">默认值机制</a></h2>
<h3 id="默认值语法"><a class="header" href="#默认值语法">默认值语法</a></h3>
<p>当字段不存在或读取失败时，使用默认值：</p>
<pre><code class="language-oml">name : default_value
---
# 语法：read(...) { _ : &lt;默认值&gt; }
country = read(country) { _ : chars(CN) } ;
version = read(version) { _ : chars(1.0.0) } ;
port = read(port) { _ : digit(8080) } ;
</code></pre>
<h3 id="默认值可以是函数调用"><a class="header" href="#默认值可以是函数调用">默认值可以是函数调用</a></h3>
<pre><code class="language-oml">name : default_with_function
---
# 如果 timestamp 不存在，使用当前时间
event_time = read(timestamp) { _ : Now::time() } ;
</code></pre>
<h3 id="默认值可以是读取"><a class="header" href="#默认值可以是读取">默认值可以是读取</a></h3>
<pre><code class="language-oml">name : default_with_read
---
# 如果 id 不存在，尝试读取 user_id
user_id = read(id) { _ : read(user_id) } ;
</code></pre>
<h3 id="限制"><a class="header" href="#限制">限制</a></h3>
<ul>
<li><code>@ref</code> 语法糖不支持默认值</li>
<li>默认值表达式不能是 <code>match</code>、<code>object</code>、<code>collect</code> 等复杂表达式</li>
</ul>
<h2 id="通配符与批量处理"><a class="header" href="#通配符与批量处理">通配符与批量处理</a></h2>
<h3 id="通配符语法"><a class="header" href="#通配符语法">通配符语法</a></h3>
<p>使用 <code>*</code> 匹配多个字段：</p>
<pre><code class="language-oml">name : wildcard
---
# 收集所有以 cpu_ 开头的字段
cpu_metrics = collect read(keys:[cpu_*]) ;

# 收集所有以 /path 结尾的字段
paths = collect read(keys:[*/path]) ;
</code></pre>
<h3 id="批量目标"><a class="header" href="#批量目标">批量目标</a></h3>
<p>目标字段名包含 <code>*</code> 时进入批量模式：</p>
<pre><code class="language-oml">name : batch_target
---
# 取走所有字段
* = take() ;

# 取走所有以 alert_ 开头的字段
alert* = take() ;

# 取走所有以 _log 结尾的字段
*_log = take() ;
</code></pre>
<p><strong>限制</strong>：批量模式只支持 <code>read</code> 和 <code>take</code>，不支持其他表达式。</p>
<h2 id="参数化读取"><a class="header" href="#参数化读取">参数化读取</a></h2>
<h3 id="option按优先级尝试"><a class="header" href="#option按优先级尝试">option：按优先级尝试</a></h3>
<pre><code class="language-oml">name : option_param
---
# 按顺序尝试读取 id、uid、user_id
user_id = read(option:[id, uid, user_id]) ;
</code></pre>
<p><strong>行为</strong>：</p>
<ul>
<li>从左到右尝试每个字段</li>
<li>返回第一个存在的字段值</li>
<li>如果都不存在，返回失败（可配合默认值）</li>
</ul>
<h3 id="keys收集多个字段"><a class="header" href="#keys收集多个字段">keys：收集多个字段</a></h3>
<pre><code class="language-oml">name : keys_param
---
# 收集多个字段为数组
ports = collect read(keys:[sport, dport]) ;
</code></pre>
<p><strong>行为</strong>：</p>
<ul>
<li>读取所有指定的字段</li>
<li>支持通配符 <code>*</code></li>
<li>返回数组</li>
</ul>
<h3 id="json-路径"><a class="header" href="#json-路径">JSON 路径</a></h3>
<p>读取嵌套数据：</p>
<pre><code class="language-oml">name : json_path
---
# 读取 /user/info/name
username = read(/user/info/name) ;

# 读取数组元素 /items[0]/id
first_id = read(/items[0]/id) ;
</code></pre>
<h2 id="表达式组合"><a class="header" href="#表达式组合">表达式组合</a></h2>
<h3 id="嵌套对象"><a class="header" href="#嵌套对象">嵌套对象</a></h3>
<pre><code class="language-oml">name : nested_objects
---
deployment : obj = object {
    app : obj = object {
        name = read(app_name) ;
        version = read(app_version) ;
    } ;
    env : obj = object {
        region = read(region) ;
        zone = read(zone) ;
    } ;
} ;
</code></pre>
<h3 id="管道链"><a class="header" href="#管道链">管道链</a></h3>
<pre><code class="language-oml">name : pipe_chain
---
# 多级转换
result = read(data) | to_json | base64_encode | html_escape ;

# 数组操作
first_user = read(users) | nth(0) | get(name) ;
</code></pre>
<h3 id="match-中的复杂表达式"><a class="header" href="#match-中的复杂表达式">match 中的复杂表达式</a></h3>
<pre><code class="language-oml">name : complex_match
---
status = match read(code) {
    in (digit(200), digit(299)) =&gt; collect read(keys:[a, b]) ;
    _ =&gt; read(default_value) ;
} ;
</code></pre>
<h2 id="作用域规则"><a class="header" href="#作用域规则">作用域规则</a></h2>
<h3 id="目标字段作用域"><a class="header" href="#目标字段作用域">目标字段作用域</a></h3>
<p>在 <code>object</code> 内部创建的字段，只在对象内可见：</p>
<pre><code class="language-oml">name : scope_example
---
info : obj = object {
    name = read(username) ;  # name 只在 info 对象内
} ;

# 这里无法访问 name
other = read(name) ;  # 失败！name 不在外部作用域
</code></pre>
<h3 id="全局目标字段"><a class="header" href="#全局目标字段">全局目标字段</a></h3>
<p>顶层定义的字段可以被后续读取：</p>
<pre><code class="language-oml">name : global_scope
---
# 定义全局字段
temp = read(data) ;

# 后续可以读取
result = read(temp) ;
</code></pre>
<h2 id="易错提醒"><a class="header" href="#易错提醒">易错提醒</a></h2>
<ol>
<li><strong>分号必需</strong>：每个顶层条目必须以 <code>;</code> 结束</li>
<li><strong>类型不匹配</strong>：显式类型声明与实际值不符会导致转换错误</li>
<li><strong>take 后再读</strong>：使用 <code>take</code> 后该字段被移除，无法再次读取</li>
<li><strong>@ref 限制</strong>：<code>@ref</code> 只能在特定位置使用，不支持默认值</li>
<li><strong>批量模式限制</strong>：目标名含 <code>*</code> 时，右值只能是 <code>read</code> 或 <code>take</code></li>
</ol>
<h2 id="最佳实践-7"><a class="header" href="#最佳实践-7">最佳实践</a></h2>
<h3 id="1-选择合适的读取模式"><a class="header" href="#1-选择合适的读取模式">1. 选择合适的读取模式</a></h3>
<pre><code class="language-oml"># 推荐：字段复用时用 read
temp = read(data) ;
result1 = pipe read(temp) | to_json ;
result2 = pipe read(temp) | base64_encode ;

# 推荐：一次性使用时用 take
final = take(data) | to_json ;
</code></pre>
<h3 id="2-显式类型声明"><a class="header" href="#2-显式类型声明">2. 显式类型声明</a></h3>
<pre><code class="language-oml"># 推荐：明确类型
port : digit = read(port) ;
ip_addr : ip = read(src_ip) ;

# 可接受：简单场景自动推断
name = read(name) ;
</code></pre>
<h3 id="3-提供默认值"><a class="header" href="#3-提供默认值">3. 提供默认值</a></h3>
<pre><code class="language-oml"># 推荐：关键字段提供默认值
version = read(version) { _ : chars(1.0.0) } ;
timeout = read(timeout) { _ : digit(30) } ;
</code></pre>
<h3 id="4-合理使用通配符"><a class="header" href="#4-合理使用通配符">4. 合理使用通配符</a></h3>
<pre><code class="language-oml"># 推荐：明确的通配符模式
cpu_metrics = collect read(keys:[cpu_*]) ;

# 避免：过于宽泛的通配符
all = collect read(keys:[*]) ;  # 可能包含不需要的字段
</code></pre>
<h2 id="下一步-5"><a class="header" href="#下一步-5">下一步</a></h2>
<ul>
<li><a href="#oml-实战指南">实战指南</a> - 按任务查找解决方案</li>
<li><a href="#oml-函数参考">函数参考</a> - 查阅所有可用函数</li>
<li><a href="#oml-快速入门">快速入门</a> - 回顾基础用法</li>
<li><a href="#oml-语法参考">语法参考</a> - 查看完整语法定义</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-实战指南"><a class="header" href="#oml-实战指南">OML 实战指南</a></h1>
<p>按任务导向组织的实用指南，帮助你快速找到解决方案。</p>
<hr>
<h2 id="-任务导航-1"><a class="header" href="#-任务导航-1">📚 任务导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>任务类型</th><th>跳转</th></tr>
</thead>
<tbody>
<tr><td><a href="#wpl-与-oml-关联-1">WPL 与 OML 关联</a></td><td>理解关联机制、一对一/一对多关联</td></tr>
<tr><td><a href="#数据提取">数据提取</a></td><td>字段提取的各种方式</td></tr>
<tr><td><a href="#数据转换">数据转换</a></td><td>类型转换、时间、URL、Base64 等</td></tr>
<tr><td><a href="#数据聚合-1">数据聚合</a></td><td>创建对象、数组</td></tr>
<tr><td><a href="#条件处理-1">条件处理</a></td><td>状态码分类、端口识别、IP 范围等</td></tr>
<tr><td><a href="#数据富化-sql-查询">数据富化</a></td><td>SQL 查询、多表关联</td></tr>
<tr><td><a href="#复杂场景">复杂场景</a></td><td>Web 日志、系统监控完整处理</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="wpl-与-oml-关联-1"><a class="header" href="#wpl-与-oml-关联-1">WPL 与 OML 关联</a></h2>
<h3 id="任务理解关联机制"><a class="header" href="#任务理解关联机制">任务：理解关联机制</a></h3>
<p><strong>核心概念</strong>：OML 通过 <code>rule</code> 字段匹配 WPL 的 <code>package/rule</code> 路径来建立关联。</p>
<p><strong>WPL 规则</strong>：</p>
<pre><code class="language-wpl">package nginx {
  rule access_log {
    (ip:client_ip, time:timestamp, chars:request_uri, digit:status)
  }
}
</code></pre>
<p><strong>完整路径</strong>：<code>/nginx/access_log</code>（格式：<code>/package/rule</code>）</p>
<p><strong>OML 配置</strong>：</p>
<pre><code class="language-oml">name : nginx_processor
rule : /nginx/access_log    # 匹配 WPL 的 package/rule
---
client : ip = read(client_ip) ;
time : time = read(timestamp) ;
uri = read(request_uri) ;
status : digit = read(status) ;
</code></pre>
<p><strong>说明</strong>：只有 WPL rule 为 <code>/nginx/access_log</code> 的数据会被这个 OML 处理。</p>
<hr>
<h3 id="任务一对多关联通配符匹配"><a class="header" href="#任务一对多关联通配符匹配">任务：一对多关联（通配符匹配）</a></h3>
<p><strong>场景</strong>：一个 WPL 规则可以被多个 OML 配置处理</p>
<p><strong>WPL 规则</strong>：</p>
<pre><code>package : nginx
rule : access_log
# 完整路径：/nginx/access_log
</code></pre>
<p><strong>OML 配置 1</strong>（基础处理）：</p>
<pre><code class="language-oml">name : nginx_basic
rule : /nginx/*    # 匹配所有 nginx 相关规则
---
timestamp : time = Now::time() ;
source = chars(nginx) ;
</code></pre>
<p><strong>OML 配置 2</strong>（访问日志专用）：</p>
<pre><code class="language-oml">name : nginx_access_detail
rule : /nginx/access_log    # 精确匹配访问日志
---
user_id = read(user_id) ;
uri = read(request_uri) ;
status : digit = read(status) ;
</code></pre>
<p><strong>说明</strong>：同一条数据可以被多个 OML 配置处理（如果在不同的 Sink Group 中）。</p>
<hr>
<h3 id="任务通配符模式匹配"><a class="header" href="#任务通配符模式匹配">任务：通配符模式匹配</a></h3>
<p><strong>场景</strong>：使用通配符处理多种类型的数据</p>
<p><strong>支持的通配符模式</strong>：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>OML rule</th><th>匹配的 WPL rule</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>/nginx/*</code></td><td><code>/nginx/access_log</code><br /><code>/nginx/error_log</code></td><td>前缀匹配</td></tr>
<tr><td><code>*/access_log</code></td><td><code>/nginx/access_log</code><br /><code>/apache/access_log</code></td><td>后缀匹配</td></tr>
<tr><td><code>/nginx/access*</code></td><td><code>/nginx/access_log</code><br /><code>/nginx/access_v2</code></td><td>部分匹配</td></tr>
<tr><td><code>*</code></td><td>任意规则</td><td>全匹配</td></tr>
</tbody>
</table>
</div>
<p><strong>示例</strong>：处理所有访问日志</p>
<pre><code class="language-oml">name : all_access_logs
rule : */access_log    # 匹配所有 access_log
---
timestamp : time = Now::time() ;
uri = read(request_uri) ;
status : digit = read(status) ;
</code></pre>
<hr>
<h3 id="任务多个-wpl-规则共享一个-oml"><a class="header" href="#任务多个-wpl-规则共享一个-oml">任务：多个 WPL 规则共享一个 OML</a></h3>
<p><strong>场景</strong>：不同来源的数据使用相同的转换逻辑</p>
<p><strong>WPL 规则 1</strong>：</p>
<pre><code>package : nginx
rule : access_log
# 路径：/nginx/access_log
</code></pre>
<p><strong>WPL 规则 2</strong>：</p>
<pre><code>package : apache
rule : access_log
# 路径：/apache/access_log
</code></pre>
<p><strong>共享的 OML 配置</strong>：</p>
<pre><code class="language-oml">name : web_access_handler
rule : */access_log    # 匹配所有 access_log
---
# 统一的字段映射
timestamp : time = read(time) ;
client_ip : ip = read(option:[remote_addr, client_ip]) ;
uri = read(option:[request_uri, request]) ;
status : digit = read(option:[status, status_code]) ;

# 统一的输出格式
access : obj = object {
    time : time = read(timestamp) ;
    ip : ip = read(client_ip) ;
    uri : chars = read(uri) ;
    status : digit = read(status) ;
} ;
</code></pre>
<p><strong>说明</strong>：使用 <code>option</code> 参数处理不同来源的字段名差异。</p>
<hr>
<h2 id="数据提取"><a class="header" href="#数据提取">数据提取</a></h2>
<h3 id="综合示例字段提取的各种方式"><a class="header" href="#综合示例字段提取的各种方式">综合示例：字段提取的各种方式</a></h3>
<pre><code class="language-oml">name : data_extraction
rule : /app/data
---
# 1. 简单提取
user_id = read(user_id) ;

# 2. 提供默认值
country = read(country) { _ : chars(CN) } ;

# 3. 按优先级尝试多个字段
user_id = read(option:[id, user_id, uid]) ;

# 4. 提取嵌套数据
username = read(/user/info/name) ;

# 5. 批量提取匹配模式
cpu_metrics = collect read(keys:[cpu_*]) ;
</code></pre>
<hr>
<h2 id="数据转换"><a class="header" href="#数据转换">数据转换</a></h2>
<h3 id="综合示例常用类型转换"><a class="header" href="#综合示例常用类型转换">综合示例：常用类型转换</a></h3>
<pre><code class="language-oml">name : type_conversion
rule : /app/data
---
# 字符串转各种类型
port : digit = read(port) ;                    # 转整数
ip : ip = read(ip_addr) ;                      # 转 IP
cpu : float = read(cpu_usage) ;                # 转浮点数
active : bool = read(is_active) ;              # 转布尔值

# 时间转时间戳
ts_sec = read(event_time) | Time::to_ts_zone(0, s) ;    # 秒
ts_ms = read(event_time) | Time::to_ts_zone(8, ms) ;    # 毫秒（UTC+8）

# URL 解析
domain = read(url) | url(domain) ;
path = read(url) | url(path) ;
params = read(url) | url(params) ;

# Base64 编解码
decoded = read(encoded) | base64_decode(Utf8) ;
encoded = read(message) | base64_encode ;

# IP 转整数
ip_int = read(src_ip) | ip4_to_int ;
</code></pre>
<hr>
<h2 id="数据聚合-1"><a class="header" href="#数据聚合-1">数据聚合</a></h2>
<h3 id="任务创建对象"><a class="header" href="#任务创建对象">任务：创建对象</a></h3>
<pre><code class="language-oml">name : create_object
rule : /system/metrics
---
system_info : obj = object {
    host : chars = read(hostname) ;
    cpu : float = read(cpu_usage) ;
    memory : float = read(mem_usage) ;
} ;
</code></pre>
<hr>
<h3 id="任务创建嵌套对象"><a class="header" href="#任务创建嵌套对象">任务：创建嵌套对象</a></h3>
<pre><code class="language-oml">name : nested_object
rule : /app/deployment
---
deployment : obj = object {
    application : obj = object {
        name : chars = read(app_name) ;
        version : chars = read(version) ;
    } ;
    infrastructure : obj = object {
        region : chars = read(region) ;
        instance_id : chars = read(instance_id) ;
    } ;
} ;
</code></pre>
<hr>
<h3 id="任务创建数组"><a class="header" href="#任务创建数组">任务：创建数组</a></h3>
<pre><code class="language-oml">name : create_array
rule : /network/ports
---
# 收集多个端口
ports : array = collect read(keys:[sport, dport]) ;

# 转换为 JSON 字符串
ports_json = read(ports) | to_json ;

# 获取数组元素
first_port = read(ports) | nth(0) ;
</code></pre>
<hr>
<h2 id="条件处理-1"><a class="header" href="#条件处理-1">条件处理</a></h2>
<h3 id="任务状态码分类"><a class="header" href="#任务状态码分类">任务：状态码分类</a></h3>
<pre><code class="language-oml">name : status_classification
rule : /http/response
---
status_level = match read(status_code) {
    in (digit(200), digit(299)) =&gt; chars(success) ;
    in (digit(400), digit(499)) =&gt; chars(client_error) ;
    in (digit(500), digit(599)) =&gt; chars(server_error) ;
    _ =&gt; chars(unknown) ;
} ;
</code></pre>
<hr>
<h3 id="任务端口服务识别"><a class="header" href="#任务端口服务识别">任务：端口服务识别</a></h3>
<pre><code class="language-oml">name : port_service
rule : /network/traffic
---
service = match read(port) {
    digit(22) =&gt; chars(SSH) ;
    digit(80) =&gt; chars(HTTP) ;
    digit(443) =&gt; chars(HTTPS) ;
    digit(3306) =&gt; chars(MySQL) ;
    _ =&gt; chars(Unknown) ;
} ;
</code></pre>
<hr>
<h3 id="任务ip-地址范围匹配"><a class="header" href="#任务ip-地址范围匹配">任务：IP 地址范围匹配</a></h3>
<pre><code class="language-oml">name : ip_zone_match
rule : /network/connection
---
zone = match read(src_ip) {
    in (ip(10.0.0.0), ip(10.255.255.255)) =&gt; chars(Private) ;
    in (ip(172.16.0.0), ip(172.31.255.255)) =&gt; chars(Private) ;
    in (ip(192.168.0.0), ip(192.168.255.255)) =&gt; chars(Private) ;
    _ =&gt; chars(Public) ;
} ;
</code></pre>
<hr>
<h3 id="任务多条件组合判断"><a class="header" href="#任务多条件组合判断">任务：多条件组合判断</a></h3>
<pre><code class="language-oml">name : multi_condition
rule : /firewall/rule
---
traffic_type = match (read(protocol), read(port)) {
    (chars(tcp), digit(22)) =&gt; chars(SSH) ;
    (chars(tcp), digit(443)) =&gt; chars(HTTPS) ;
    (chars(udp), digit(53)) =&gt; chars(DNS) ;
    _ =&gt; chars(Other) ;
} ;
</code></pre>
<hr>
<h2 id="数据富化sql-查询"><a class="header" href="#数据富化sql-查询">数据富化（SQL 查询）</a></h2>
<h3 id="任务用户信息查询"><a class="header" href="#任务用户信息查询">任务：用户信息查询</a></h3>
<p><strong>场景</strong>：根据 user_id 查询用户详细信息</p>
<p><strong>输入</strong>：</p>
<pre><code>user_id = "1001"
</code></pre>
<p><strong>数据库表 (users)</strong>：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>id</th><th>name</th><th>email</th><th>department</th></tr>
</thead>
<tbody>
<tr><td>1001</td><td>张三</td><td>zhangsan@example.com</td><td>研发部</td></tr>
</tbody>
</table>
</div>
<p><strong>OML</strong>：</p>
<pre><code class="language-oml">name : user_lookup
---
user_name, user_email, user_dept =
    select name, email, department
    from users
    where id = read(user_id) ;
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>user_name = "张三"
user_email = "zhangsan@example.com"
user_dept = "研发部"
</code></pre>
<hr>
<h3 id="任务ip-地理位置查询"><a class="header" href="#任务ip-地理位置查询">任务：IP 地理位置查询</a></h3>
<p><strong>场景</strong>：查询 IP 地址的地理位置信息</p>
<p><strong>输入</strong>：</p>
<pre><code>src_ip = "203.0.113.1"
</code></pre>
<p><strong>数据库表 (ip_geo)</strong>：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ip_start_int</th><th>ip_end_int</th><th>country</th><th>city</th></tr>
</thead>
<tbody>
<tr><td>3405803776</td><td>3405804031</td><td>US</td><td>Los Angeles</td></tr>
</tbody>
</table>
</div>
<p><strong>OML</strong>：</p>
<pre><code class="language-oml">name : ip_geolocation
---
# 先将 IP 转为整数
ip_int = pipe read(src_ip) | ip4_to_int ;

# 查询地理位置
country, city =
    select country, city
    from ip_geo
    where ip_start_int &lt;= read(ip_int)
      and ip_end_int &gt;= read(ip_int) ;
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>ip_int = 3405803777
country = "US"
city = "Los Angeles"
</code></pre>
<hr>
<h3 id="任务多表关联查询"><a class="header" href="#任务多表关联查询">任务：多表关联查询</a></h3>
<p><strong>场景</strong>：通过多次查询关联多个表的数据</p>
<p><strong>输入</strong>：</p>
<pre><code>order_id = "ORD-2024-001"
</code></pre>
<p><strong>OML</strong>：</p>
<pre><code class="language-oml">name : multi_table_lookup
---
# 第一步：查询订单信息
user_id, amount =
    select user_id, amount
    from orders
    where id = read(order_id) ;

# 第二步：查询用户信息
user_name, level =
    select name, level
    from users
    where id = read(user_id) ;

# 第三步：查询折扣信息
discount =
    select discount
    from user_levels
    where level = read(level) ;
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>user_id = "U1001"
amount = "199.99"
user_name = "王五"
level = "VIP"
discount = "0.9"
</code></pre>
<hr>
<h2 id="复杂场景"><a class="header" href="#复杂场景">复杂场景</a></h2>
<h3 id="场景web-访问日志完整处理"><a class="header" href="#场景web-访问日志完整处理">场景：Web 访问日志完整处理</a></h3>
<p><strong>任务</strong>：处理 Web 访问日志，包含字段提取、类型转换、条件判断、数据聚合</p>
<p><strong>输入</strong>：</p>
<pre><code>timestamp = "15/Jan/2024:14:30:00 +0800"
src_ip = "203.0.113.1"
method = "GET"
url = "/api/users?page=1"
status = "200"
size = "1234"
</code></pre>
<p><strong>OML</strong>：</p>
<pre><code class="language-oml">name : web_log_processing
---
# 时间处理
event_ts = pipe read(timestamp) | Time::to_ts_zone(0, s) ;

# 字段提取
source_ip : ip = read(src_ip) ;
http_method = read(method) ;
status_code : digit = read(status) ;
response_size : digit = read(size) ;

# URL 解析
request_path = pipe read(url) | url(path) ;
query_params = pipe read(url) | url(params) ;

# 状态码分类
status_category = match read(status_code) {
    in (digit(200), digit(299)) =&gt; chars(Success) ;
    in (digit(400), digit(499)) =&gt; chars(Client_Error) ;
    in (digit(500), digit(599)) =&gt; chars(Server_Error) ;
    _ =&gt; chars(Unknown) ;
} ;

# 数据聚合
access_log : obj = object {
    timestamp : digit = read(event_ts) ;
    client : obj = object {
        ip : ip = read(source_ip) ;
    } ;
    request : obj = object {
        method : chars = read(http_method) ;
        path : chars = read(request_path) ;
        query : chars = read(query_params) ;
    } ;
    response : obj = object {
        status : digit = read(status_code) ;
        category : chars = read(status_category) ;
        size : digit = read(response_size) ;
    } ;
} ;
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-json">{
    "access_log": {
        "timestamp": 1705318200,
        "client": {
            "ip": "203.0.113.1"
        },
        "request": {
            "method": "GET",
            "path": "/api/users",
            "query": "page=1"
        },
        "response": {
            "status": 200,
            "category": "Success",
            "size": 1234
        }
    }
}
</code></pre>
<hr>
<h3 id="场景系统监控数据处理"><a class="header" href="#场景系统监控数据处理">场景：系统监控数据处理</a></h3>
<p><strong>任务</strong>：处理系统监控数据，包含数据提取、告警判断、嵌套对象创建</p>
<p><strong>输入</strong>：</p>
<pre><code>hostname = "prod-web-01"
cpu_user = "65.5"
cpu_system = "15.2"
mem_used = "6144"
mem_total = "8192"
</code></pre>
<p><strong>OML</strong>：</p>
<pre><code class="language-oml">name : system_monitoring
---
# 时间戳
event_time = Now::time() ;

# 告警判断
cpu_alert = match read(cpu_user) {
    in (digit(0), digit(60)) =&gt; chars(Normal) ;
    in (digit(60), digit(80)) =&gt; chars(Warning) ;
    _ =&gt; chars(Critical) ;
} ;

mem_alert = match read(mem_used) {
    in (digit(0), digit(6000)) =&gt; chars(Normal) ;
    in (digit(6000), digit(7000)) =&gt; chars(Warning) ;
    _ =&gt; chars(Critical) ;
} ;

# 数据聚合
metrics : obj = object {
    host : obj = object {
        name : chars = read(hostname) ;
        timestamp : time = read(event_time) ;
    } ;
    cpu : obj = object {
        user : float = read(cpu_user) ;
        system : float = read(cpu_system) ;
        alert : chars = read(cpu_alert) ;
    } ;
    memory : obj = object {
        used : digit = read(mem_used) ;
        total : digit = read(mem_total) ;
        alert : chars = read(mem_alert) ;
    } ;
} ;
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-json">{
    "metrics": {
        "host": {
            "name": "prod-web-01",
            "timestamp": "2024-01-15 14:30:00"
        },
        "cpu": {
            "user": 65.5,
            "system": 15.2,
            "alert": "Warning"
        },
        "memory": {
            "used": 6144,
            "total": 8192,
            "alert": "Warning"
        }
    }
}
</code></pre>
<hr>
<hr>
<h2 id="下一步-6"><a class="header" href="#下一步-6">下一步</a></h2>
<ul>
<li><strong><a href="#oml-完整功能示例">🌟 完整功能示例</a></strong> - 查看所有 OML 功能的完整演示</li>
<li><a href="#oml-函数参考">函数参考</a> - 查阅所有可用函数</li>
<li><a href="#oml-核心概念">核心概念</a> - 深入理解 OML 设计</li>
<li><a href="#oml-集成指南">集成指南</a> - 将 OML 集成到数据流</li>
<li><a href="#oml-语法参考">语法参考</a> - 查看完整语法定义</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-函数参考"><a class="header" href="#oml-函数参考">OML 函数参考</a></h1>
<p>本文档提供所有内置函数和管道函数的完整参考，采用标准化格式便于查找。</p>
<hr>
<h2 id="-详细文档导航"><a class="header" href="#-详细文档导航">📚 详细文档导航</a></h2>
<ul>
<li><a href="#内置函数">内置函数</a> - 可直接使用的函数</li>
<li><a href="#管道函数">管道函数</a> - 通过管道操作符调用的函数
<ul>
<li><a href="#编码函数">编码函数</a> - Base64 编解码</li>
<li><a href="#转义函数">转义函数</a> - HTML/JSON/字符串转义</li>
<li><a href="#时间函数">时间函数</a> - 时间戳转换</li>
<li><a href="#数据访问函数">数据访问函数</a> - 数组/对象/URL/路径访问</li>
<li><a href="#转换函数-2">转换函数</a> - 类型转换</li>
<li><a href="#控制函数">控制函数</a> - 流程控制</li>
</ul>
</li>
<li><a href="#使用示例">使用示例</a> - 完整示例</li>
</ul>
<hr>
<h2 id="-oml-所有函数速查"><a class="header" href="#-oml-所有函数速查">📋 OML 所有函数速查</a></h2>
<h3 id="内置函数"><a class="header" href="#内置函数">内置函数</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><a href="#nowtime-1"><code>Now::time()</code></a></td><td>获取当前时间</td><td><code>event_time = Now::time() ;</code></td></tr>
<tr><td><a href="#nowdate-1"><code>Now::date()</code></a></td><td>获取当前日期（YYYYMMDD）</td><td><code>today = Now::date() ;</code></td></tr>
<tr><td><a href="#nowhour-1"><code>Now::hour()</code></a></td><td>获取当前小时（YYYYMMDDHH）</td><td><code>current_hour = Now::hour() ;</code></td></tr>
</tbody>
</table>
</div>
<h3 id="管道函数"><a class="header" href="#管道函数">管道函数</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>功能分类</th><th>函数</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><strong>编码</strong></td><td><a href="#base64_encode-1"><code>base64_encode</code></a></td><td>Base64 编码</td><td><code>read(data) | base64_encode</code></td></tr>
<tr><td></td><td><a href="#base64_decode-1"><code>base64_decode</code></a></td><td>Base64 解码（支持 Utf8/Gbk）</td><td><code>read(data) | base64_decode(Utf8)</code></td></tr>
<tr><td><strong>转义</strong></td><td><a href="#html_escape"><code>html_escape</code></a></td><td>HTML 转义</td><td><code>read(text) | html_escape</code></td></tr>
<tr><td></td><td><a href="#html_unescape"><code>html_unescape</code></a></td><td>HTML 反转义</td><td><code>read(html) | html_unescape</code></td></tr>
<tr><td></td><td><a href="#json_escape"><code>json_escape</code></a></td><td>JSON 转义</td><td><code>read(text) | json_escape</code></td></tr>
<tr><td></td><td><a href="#json_unescape-1"><code>json_unescape</code></a></td><td>JSON 反转义</td><td><code>read(json) | json_unescape</code></td></tr>
<tr><td></td><td><a href="#str_escape"><code>str_escape</code></a></td><td>字符串转义</td><td><code>read(str) | str_escape</code></td></tr>
<tr><td><strong>时间</strong></td><td><a href="#timeto_ts-1"><code>Time::to_ts</code></a></td><td>转时间戳（秒，UTC+8）</td><td><code>read(time) | Time::to_ts</code></td></tr>
<tr><td></td><td><a href="#timeto_ts_ms-1"><code>Time::to_ts_ms</code></a></td><td>转时间戳（毫秒，UTC+8）</td><td><code>read(time) | Time::to_ts_ms</code></td></tr>
<tr><td></td><td><a href="#timeto_ts_us-1"><code>Time::to_ts_us</code></a></td><td>转时间戳（微秒，UTC+8）</td><td><code>read(time) | Time::to_ts_us</code></td></tr>
<tr><td></td><td><a href="#timeto_ts_zone-1"><code>Time::to_ts_zone</code></a></td><td>转指定时区时间戳</td><td><code>read(time) | Time::to_ts_zone(0, ms)</code></td></tr>
<tr><td><strong>数据访问</strong></td><td><a href="#nth-1"><code>nth(index)</code></a></td><td>获取数组元素</td><td><code>read(arr) | nth(0)</code></td></tr>
<tr><td></td><td><a href="#get-1"><code>get(key)</code></a></td><td>获取对象字段</td><td><code>read(obj) | get(name)</code></td></tr>
<tr><td></td><td><a href="#path-1"><code>path(part)</code></a></td><td>提取文件路径（name/path）</td><td><code>read(path) | path(name)</code></td></tr>
<tr><td></td><td><a href="#url-1"><code>url(part)</code></a></td><td>提取 URL（domain/host/path/params/uri）</td><td><code>read(url) | url(domain)</code></td></tr>
<tr><td></td><td><a href="#sxf_get"><code>sxf_get(field)</code></a></td><td>提取特殊格式字段</td><td><code>read(log) | sxf_get(status)</code></td></tr>
<tr><td><strong>转换</strong></td><td><a href="#to_str-1"><code>to_str</code></a></td><td>转换为字符串</td><td><code>read(ip) | to_str</code></td></tr>
<tr><td></td><td><a href="#to_json-1"><code>to_json</code></a></td><td>转换为 JSON</td><td><code>read(arr) | to_json</code></td></tr>
<tr><td></td><td><a href="#ip4_to_int"><code>ip4_to_int</code></a></td><td>IPv4 转整数</td><td><code>read(ip) | ip4_to_int</code></td></tr>
<tr><td><strong>控制</strong></td><td><a href="#skip_empty-1"><code>skip_empty</code></a></td><td>跳过空值</td><td><code>read(field) | skip_empty</code></td></tr>
</tbody>
</table>
</div>
<h3 id="常用场景速查-1"><a class="header" href="#常用场景速查-1">常用场景速查</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>我想做什么</th><th>使用方法</th></tr>
</thead>
<tbody>
<tr><td><strong>获取当前时间</strong></td><td><code>event_time = Now::time() ;</code></td></tr>
<tr><td><strong>时间转时间戳</strong></td><td><code>ts = read(time) | Time::to_ts_zone(0, ms) ;</code></td></tr>
<tr><td><strong>Base64 解码</strong></td><td><code>decoded = read(data) | base64_decode(Utf8) ;</code></td></tr>
<tr><td><strong>HTML 转义</strong></td><td><code>escaped = read(text) | html_escape ;</code></td></tr>
<tr><td><strong>解析 URL</strong></td><td><code>domain = read(url) | url(domain) ;</code></td></tr>
<tr><td><strong>提取文件名</strong></td><td><code>filename = read(path) | path(name) ;</code></td></tr>
<tr><td><strong>获取数组第一个元素</strong></td><td><code>first = read(arr) | nth(0) ;</code></td></tr>
<tr><td><strong>获取对象字段</strong></td><td><code>name = read(obj) | get(name) ;</code></td></tr>
<tr><td><strong>IP 转整数</strong></td><td><code>ip_int = read(ip) | ip4_to_int ;</code></td></tr>
<tr><td><strong>跳过空值</strong></td><td><code>result = read(field) | skip_empty ;</code></td></tr>
<tr><td><strong>链式处理</strong></td><td><code>result = read(data) | to_json | base64_encode ;</code></td></tr>
<tr><td><strong>字符串格式化</strong></td><td><code>msg = fmt("{}:{}", @ip, @port) ;</code></td></tr>
<tr><td><strong>条件匹配</strong></td><td><code>level = match read(status) { ... } ;</code></td></tr>
<tr><td><strong>创建对象</strong></td><td><code>info : obj = object { ... } ;</code></td></tr>
<tr><td><strong>创建数组</strong></td><td><code>items : array = collect read(keys:[...]) ;</code></td></tr>
<tr><td><strong>提供默认值</strong></td><td><code>country = read(country) { _ : chars(CN) } ;</code></td></tr>
<tr><td><strong>选择性读取</strong></td><td><code>id = read(option:[id, uid, user_id]) ;</code></td></tr>
<tr><td><strong>批量收集</strong></td><td><code>metrics = collect read(keys:[cpu_*]) ;</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="内置函数-1"><a class="header" href="#内置函数-1">内置函数</a></h2>
<p>内置函数可以直接在赋值表达式中使用，无需 <code>pipe</code> 关键字。</p>
<h3 id="nowtime"><a class="header" href="#nowtime">Now::time()</a></h3>
<p>获取当前时间。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">Now::time()
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>返回类型</strong>：<code>time</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">event_time : time = Now::time() ;
# 输出：2024-01-15 14:30:45
</code></pre>
<hr>
<h3 id="nowdate"><a class="header" href="#nowdate">Now::date()</a></h3>
<p>获取当前日期，格式为 <code>YYYYMMDD</code> 的整数。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">Now::date()
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>返回类型</strong>：<code>digit</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">today : digit = Now::date() ;
# 输出：20240115
</code></pre>
<hr>
<h3 id="nowhour"><a class="header" href="#nowhour">Now::hour()</a></h3>
<p>获取当前时间精确到小时，格式为 <code>YYYYMMDDHH</code> 的整数。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">Now::hour()
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>返回类型</strong>：<code>digit</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">current_hour : digit = Now::hour() ;
# 输出：2024011514
</code></pre>
<hr>
<h2 id="管道函数-1"><a class="header" href="#管道函数-1">管道函数</a></h2>
<p>管道函数通过 <code>pipe</code> 关键字和 <code>|</code> 操作符链式调用（<code>pipe</code> 关键字可省略）。</p>
<p><strong>基本语法</strong>：</p>
<pre><code class="language-oml"># 使用 pipe 关键字
result = pipe read(field) | function1 | function2(param) ;

# 省略 pipe 关键字
result = read(field) | function1 | function2(param) ;
</code></pre>
<hr>
<h2 id="编码函数"><a class="header" href="#编码函数">编码函数</a></h2>
<h3 id="base64_encode"><a class="header" href="#base64_encode">base64_encode</a></h3>
<p>将字符串进行 Base64 编码。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| base64_encode
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">encoded = read(payload) | base64_encode ;
# 输入："Hello, OML!"
# 输出："SGVsbG8sIE9NTCE="
</code></pre>
<hr>
<h3 id="base64_decode-1"><a class="header" href="#base64_decode-1">base64_decode</a></h3>
<p>将 Base64 编码的字符串解码。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| base64_decode
| base64_decode(&lt;encoding&gt;)
</code></pre>
<p><strong>参数</strong>：</p>
<ul>
<li><code>encoding</code>（可选）：字符编码类型，默认为 <code>Utf8</code></li>
</ul>
<p><strong>支持的编码</strong>：</p>
<ul>
<li><code>Utf8</code> - UTF-8 编码（默认）</li>
<li><code>Gbk</code> - GBK 中文编码</li>
<li><code>Imap</code> - IMAP Base64 变体（将非 ASCII 字节转义为 <code>\xNN</code> 格式）</li>
<li>更多编码请参阅源码文档</li>
</ul>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 标准 UTF-8 解码
decoded = read(data) | base64_decode ;
# 输入："SGVsbG8sIE9NTCE="
# 输出："Hello, OML!"

# GBK 中文解码
gbk_text = read(gbk_data) | base64_decode(Gbk) ;

# IMAP 变体解码（处理二进制数据）
raw = read(binary_data) | base64_decode(Imap) ;
</code></pre>
<hr>
<h2 id="转义函数"><a class="header" href="#转义函数">转义函数</a></h2>
<h3 id="html_escape"><a class="header" href="#html_escape">html_escape</a></h3>
<p>对 HTML 特殊字符进行转义。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| html_escape
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>转义规则</strong>：</p>
<ul>
<li><code>&lt;</code> → <code>&amp;lt;</code></li>
<li><code>&gt;</code> → <code>&amp;gt;</code></li>
<li><code>&amp;</code> → <code>&amp;amp;</code></li>
<li><code>"</code> → <code>&amp;quot;</code></li>
<li><code>'</code> → <code>&amp;#x27;</code></li>
</ul>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">safe_html = read(user_input) | html_escape ;
# 输入："&lt;script&gt;alert('xss')&lt;/script&gt;"
# 输出："&amp;lt;script&amp;gt;alert(&amp;#x27;xss&amp;#x27;)&amp;lt;/script&amp;gt;"
</code></pre>
<hr>
<h3 id="html_unescape"><a class="header" href="#html_unescape">html_unescape</a></h3>
<p>将 HTML 实体还原为原始字符。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| html_unescape
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">original = read(escaped_html) | html_unescape ;
# 输入："&amp;lt;div&amp;gt;Hello&amp;lt;/div&amp;gt;"
# 输出："&lt;div&gt;Hello&lt;/div&gt;"
</code></pre>
<hr>
<h3 id="json_escape"><a class="header" href="#json_escape">json_escape</a></h3>
<p>对 JSON 字符串中的特殊字符进行转义。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| json_escape
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">json_safe = read(text) | json_escape ;
# 转义引号、反斜杠、换行符等 JSON 特殊字符
</code></pre>
<hr>
<h3 id="json_unescape-1"><a class="header" href="#json_unescape-1">json_unescape</a></h3>
<p>将 JSON 转义序列还原为原始字符。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| json_unescape
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">original = read(escaped_json) | json_unescape ;
# 还原 \n、\t、\"等转义序列
</code></pre>
<hr>
<h3 id="str_escape"><a class="header" href="#str_escape">str_escape</a></h3>
<p>对字符串中的特殊字符进行转义（主要是引号和反斜杠）。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| str_escape
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">escaped = read(raw_string) | str_escape ;
# 输入：'hello"world'
# 输出：'hello\"world'
</code></pre>
<hr>
<h2 id="时间函数"><a class="header" href="#时间函数">时间函数</a></h2>
<h3 id="timeto_ts"><a class="header" href="#timeto_ts">Time::to_ts</a></h3>
<p>将时间转换为 Unix 时间戳（秒），使用 UTC+8 时区。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| Time::to_ts
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：<code>time</code>
<strong>输出类型</strong>：<code>digit</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">timestamp = read(occur_time) | Time::to_ts ;
# 输入：2024-01-15 14:30:00
# 输出：1705304400（UTC+8）
</code></pre>
<hr>
<h3 id="timeto_ts_ms"><a class="header" href="#timeto_ts_ms">Time::to_ts_ms</a></h3>
<p>将时间转换为 Unix 时间戳（毫秒），使用 UTC+8 时区。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| Time::to_ts_ms
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：<code>time</code>
<strong>输出类型</strong>：<code>digit</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">timestamp_ms = read(occur_time) | Time::to_ts_ms ;
# 输入：2024-01-15 14:30:00
# 输出：1705304400000
</code></pre>
<hr>
<h3 id="timeto_ts_us"><a class="header" href="#timeto_ts_us">Time::to_ts_us</a></h3>
<p>将时间转换为 Unix 时间戳（微秒），使用 UTC+8 时区。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| Time::to_ts_us
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：<code>time</code>
<strong>输出类型</strong>：<code>digit</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">timestamp_us = read(occur_time) | Time::to_ts_us ;
# 输入：2024-01-15 14:30:00
# 输出：1705304400000000
</code></pre>
<hr>
<h3 id="timeto_ts_zone"><a class="header" href="#timeto_ts_zone">Time::to_ts_zone</a></h3>
<p>将时间转换为指定时区的 Unix 时间戳。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| Time::to_ts_zone(&lt;timezone_offset&gt;, &lt;unit&gt;)
</code></pre>
<p><strong>参数</strong>：</p>
<ul>
<li><code>timezone_offset</code>：时区偏移（小时）
<ul>
<li><code>0</code>：UTC</li>
<li><code>8</code>：UTC+8（北京时间）</li>
<li><code>-5</code>：UTC-5（美东时间）</li>
</ul>
</li>
<li><code>unit</code>：时间戳单位
<ul>
<li><code>s</code> 或 <code>ss</code>：秒</li>
<li><code>ms</code>：毫秒</li>
<li><code>us</code>：微秒</li>
</ul>
</li>
</ul>
<p><strong>输入类型</strong>：<code>time</code>
<strong>输出类型</strong>：<code>digit</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># UTC 时间戳（秒）
utc_ts = read(occur_time) | Time::to_ts_zone(0, s) ;

# UTC+8 时间戳（毫秒）
beijing_ts_ms = read(occur_time) | Time::to_ts_zone(8, ms) ;

# UTC-5 时间戳（秒）
eastern_ts = read(occur_time) | Time::to_ts_zone(-5, ss) ;

# UTC 时间戳（微秒）
utc_ts_us = read(occur_time) | Time::to_ts_zone(0, us) ;
</code></pre>
<hr>
<h2 id="数据访问函数"><a class="header" href="#数据访问函数">数据访问函数</a></h2>
<h3 id="nth"><a class="header" href="#nth">nth</a></h3>
<p>获取数组中指定索引的元素。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| nth(&lt;index&gt;)
</code></pre>
<p><strong>参数</strong>：</p>
<ul>
<li><code>index</code>：数组索引（从 0 开始）</li>
</ul>
<p><strong>输入类型</strong>：<code>array</code>
<strong>输出类型</strong>：元素类型</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">first_item = read(items) | nth(0) ;
second_item = read(items) | nth(1) ;
# 输入：[10, 20, 30]
# nth(0) 输出：10
# nth(1) 输出：20
</code></pre>
<hr>
<h3 id="get"><a class="header" href="#get">get</a></h3>
<p>获取对象中指定键的值。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| get(&lt;key&gt;)
</code></pre>
<p><strong>参数</strong>：</p>
<ul>
<li><code>key</code>：对象的字段名</li>
</ul>
<p><strong>输入类型</strong>：<code>obj</code>
<strong>输出类型</strong>：字段值类型</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 获取对象的字段
name = read(user) | get(name) ;

# 链式调用
first_name = read(users) | nth(0) | get(name) ;
# 输入：[{"name": "John", "age": 30}, {"name": "Jane", "age": 25}]
# 输出："John"
</code></pre>
<hr>
<h3 id="path"><a class="header" href="#path">path</a></h3>
<p>从文件路径中提取指定部分。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| path(&lt;part&gt;)
</code></pre>
<p><strong>参数</strong>：</p>
<ul>
<li><code>part</code>：要提取的部分
<ul>
<li><code>name</code>：文件名（含扩展名）</li>
<li><code>path</code>：目录路径</li>
</ul>
</li>
</ul>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 输入："C:\Users\test\file.txt"
filename = read(file_path) | path(name) ;
# 输出："file.txt"

parent = read(file_path) | path(path) ;
# 输出："C:/Users/test"
</code></pre>
<hr>
<h3 id="url"><a class="header" href="#url">url</a></h3>
<p>从 URL 中提取指定部分。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| url(&lt;part&gt;)
</code></pre>
<p><strong>参数</strong>：</p>
<ul>
<li><code>part</code>：要提取的部分
<ul>
<li><code>domain</code>：域名（不含端口）</li>
<li><code>host</code>：主机（含端口）</li>
<li><code>path</code>：路径</li>
<li><code>uri</code>：完整 URI（路径 + 查询 + 片段）</li>
<li><code>params</code>：查询参数</li>
</ul>
</li>
</ul>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 输入："https://api.example.com:8080/v1/users?id=1&amp;type=admin#section"

domain = read(http_url) | url(domain) ;
# 输出："api.example.com"

host = read(http_url) | url(host) ;
# 输出："api.example.com:8080"

path = read(http_url) | url(path) ;
# 输出："/v1/users"

uri = read(http_url) | url(uri) ;
# 输出："/v1/users?id=1&amp;type=admin#section"

params = read(http_url) | url(params) ;
# 输出："id=1&amp;type=admin"
</code></pre>
<hr>
<h3 id="sxf_get"><a class="header" href="#sxf_get">sxf_get</a></h3>
<p>从特殊格式的文本中提取字段值。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| sxf_get(&lt;field_name&gt;)
</code></pre>
<p><strong>参数</strong>：</p>
<ul>
<li><code>field_name</code>：要提取的字段名</li>
</ul>
<p><strong>输入类型</strong>：<code>chars</code>
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 从格式化文本中提取字段
status = read(log_line) | sxf_get(statusCode) ;
username = read(log_line) | sxf_get(username) ;
</code></pre>
<hr>
<h2 id="转换函数-2"><a class="header" href="#转换函数-2">转换函数</a></h2>
<h3 id="to_str"><a class="header" href="#to_str">to_str</a></h3>
<p>将值转换为字符串。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| to_str
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：任意类型
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">ip_str = read(src_ip) | to_str ;
# 输入：192.168.1.100（IP 类型）
# 输出："192.168.1.100"

num_str = read(count) | to_str ;
# 输入：42（digit 类型）
# 输出："42"
</code></pre>
<hr>
<h3 id="to_json"><a class="header" href="#to_json">to_json</a></h3>
<p>将值转换为 JSON 字符串。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| to_json
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：任意类型
<strong>输出类型</strong>：<code>chars</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 数组转 JSON
ports_json = read(ports) | to_json ;
# 输入：[80, 443]
# 输出："[80,443]"

# 对象转 JSON
user_json = read(user) | to_json ;
# 输入：{name: "John", age: 30}
# 输出：'{"name":"John","age":30}'
</code></pre>
<hr>
<h3 id="ip4_to_int"><a class="header" href="#ip4_to_int">ip4_to_int</a></h3>
<p>将 IPv4 地址转换为整数。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| ip4_to_int
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：<code>ip</code> 或 <code>chars</code>
<strong>输出类型</strong>：<code>digit</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">ip_int = read(src_ip) | ip4_to_int ;
# 输入：192.168.1.100
# 输出：3232235876

# 用于 IP 范围比较
ip_int = read(src_ip) | ip4_to_int ;
in_range = match read(ip_int) {
    in (digit(3232235776), digit(3232236031)) =&gt; chars(True) ;
    _ =&gt; chars(False) ;
} ;
</code></pre>
<hr>
<h2 id="控制函数"><a class="header" href="#控制函数">控制函数</a></h2>
<h3 id="skip_empty"><a class="header" href="#skip_empty">skip_empty</a></h3>
<p>如果输入值为空，则跳过该字段的输出。</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-oml">| skip_empty
</code></pre>
<p><strong>参数</strong>：无</p>
<p><strong>输入类型</strong>：任意类型
<strong>输出类型</strong>：原类型或跳过</p>
<p><strong>何时被视为“空“</strong>：</p>
<ul>
<li>空字符串 <code>""</code></li>
<li>空数组 <code>[]</code></li>
<li>数值 <code>0</code></li>
<li>空对象 <code>{}</code></li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 如果 optional_field 为空，则不输出 result 字段
result = read(optional_field) | skip_empty ;

# 常用于过滤空数组
items = read(items_array) | skip_empty ;
</code></pre>
<hr>
<hr>
<h2 id="下一步-7"><a class="header" href="#下一步-7">下一步</a></h2>
<ul>
<li><strong><a href="#oml-完整功能示例">🌟 完整功能示例</a></strong> - 查看所有功能的完整演示</li>
<li><a href="#oml-实战指南">实战指南</a> - 查看实际应用场景</li>
<li><a href="#oml-核心概念">核心概念</a> - 深入理解函数工作原理</li>
<li><a href="#oml-快速入门">快速入门</a> - 回顾基础用法</li>
<li><a href="#oml-语法参考">语法参考</a> - 查看完整语法定义</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-集成指南"><a class="header" href="#oml-集成指南">OML 集成指南</a></h1>
<p>本文档介绍如何将 OML 集成到数据处理流水线中，包括配置关联、数据流向和路由规则。</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="#数据流概览">数据流概览</a></li>
<li><a href="#oml-在数据流中的位置">OML 在数据流中的位置</a></li>
<li><a href="#配置文件结构">配置文件结构</a></li>
<li><a href="#oml-与-sink-关联">OML 与 Sink 关联</a></li>
<li><a href="#路由规则">路由规则</a></li>
<li><a href="#配置示例-3">配置示例</a></li>
<li><a href="#工作流程">工作流程</a></li>
<li><a href="#最佳实践-8">最佳实践</a></li>
<li><a href="#故障排查-1">故障排查</a></li>
</ul>
<hr>
<h2 id="数据流概览"><a class="header" href="#数据流概览">数据流概览</a></h2>
<p>在 WP Engine 数据处理流水线中，数据的完整流向如下：</p>
<pre><code>原始日志/数据
    ↓
[WPL 解析]
    ↓
结构化数据（携带 Rule 标识）
    ↓
[OML 转换]（可选）
    ↓
目标格式数据
    ↓
[Sink 输出]
    ↓
目标存储（文件/数据库/消息队列等）
</code></pre>
<h3 id="关键概念"><a class="header" href="#关键概念">关键概念</a></h3>
<ul>
<li><strong>WPL Rule</strong>：标识数据来源和类型的路径，如 <code>/nginx/access_log</code></li>
<li><strong>OML Model</strong>：定义数据转换逻辑的 OML 配置文件</li>
<li><strong>Sink Group</strong>：输出组，定义数据的输出目标集合</li>
<li><strong>Connector</strong>：连接器，定义具体的输出方式（文件、Kafka、数据库等）</li>
</ul>
<hr>
<h2 id="oml-在数据流中的位置"><a class="header" href="#oml-在数据流中的位置">OML 在数据流中的位置</a></h2>
<p>OML 作为<strong>数据转换引擎</strong>，位于 WPL 解析和 Sink 输出之间：</p>
<pre class="mermaid">graph LR
    A[原始数据] --&gt; B[WPL 解析]
    B --&gt; C[结构化数据&lt;br/&gt;rule: /nginx/access_log]
    C --&gt; D{查找匹配的&lt;br/&gt;OML 模型}
    D --&gt;|找到匹配| E[OML 转换]
    D --&gt;|未找到| F[数据透传]
    E --&gt; G[转换后的数据]
    F --&gt; G
    G --&gt; H[Sink 输出]

    style C fill:#e1f5ff
    style E fill:#fff4e1
    style G fill:#e8f5e9
</pre>

<p><strong>工作原理</strong>：</p>
<ol>
<li>WPL 解析器处理原始数据，生成结构化数据并附带 Rule 标识</li>
<li>系统根据 Sink Group 配置查找匹配的 OML 模型</li>
<li>如果找到匹配的 OML 模型，执行转换；否则数据透传</li>
<li>转换后的数据发送到 Sink 进行输出</li>
</ol>
<hr>
<h2 id="配置文件结构"><a class="header" href="#配置文件结构">配置文件结构</a></h2>
<h3 id="项目目录结构-1"><a class="header" href="#项目目录结构-1">项目目录结构</a></h3>
<pre><code>project/
├── oml/                        # OML 模型目录
│   ├── nginx_access.oml        # Nginx 访问日志转换
│   ├── nginx_error.oml         # Nginx 错误日志转换
│   └── system_metrics.oml      # 系统监控数据转换
├── topology/
│   └── sinks/                  # Sink 配置目录
│       ├── web_logs.toml       # Web 日志输出组
│       └── metrics.toml        # 监控数据输出组
└── connectors/                 # 连接器定义
    ├── file_sink.toml
    ├── kafka_sink.toml
    └── mysql_sink.toml
</code></pre>
<h3 id="oml-模型文件"><a class="header" href="#oml-模型文件">OML 模型文件</a></h3>
<p>OML 模型文件位于 <code>oml/</code> 目录，使用 <code>.oml</code> 扩展名。</p>
<p><strong>文件格式</strong>：</p>
<pre><code class="language-oml">name : &lt;模型名称&gt;
rule : &lt;WPL 规则模式&gt;
---
&lt;字段转换定义&gt;
</code></pre>
<p><strong>示例</strong>：<code>oml/nginx_access.oml</code></p>
<pre><code class="language-oml">name : nginx_access
rule : /nginx/access*
---
user_id = read(user_id) ;
timestamp : time = read(time) ;
status : digit = read(status_code) ;
uri = read(request_uri) ;

# 创建结构化输出
log : obj = object {
    user : chars = read(user_id) ;
    time : time = read(timestamp) ;
    status : digit = read(status) ;
    uri : chars = read(uri) ;
} ;
</code></pre>
<h3 id="sink-group-配置文件"><a class="header" href="#sink-group-配置文件">Sink Group 配置文件</a></h3>
<p>Sink Group 配置文件位于 <code>topology/sinks/</code> 目录，使用 TOML 格式。</p>
<p><strong>文件格式</strong>：</p>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "输出组名称"
oml = ["&lt;OML 模型名称&gt;", ...]  # 关联的 OML 模型
rule = ["&lt;WPL 规则模式&gt;", ...]  # 可选：限定处理的规则
parallel = 1                     # 可选：并行度
tags = ["key:value", ...]        # 可选：标签

[[sink_group.sinks]]
name = "输出目标名称"
connect = "&lt;连接器 ID&gt;"
tags = ["key:value", ...]

[sink_group.sinks.params]
# 连接器特定的参数
</code></pre>
<p><strong>示例</strong>：<code>topology/sinks/web_logs.toml</code></p>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "web_logs"
oml = ["*"]           # 使用所有匹配的 OML 模型
rule = []             # 不限定规则
parallel = 1

[[sink_group.sinks]]
name = "access_logs"
connect = "file_json_sink"

[sink_group.sinks.params]
file = "access.json"

[[sink_group.sinks]]
name = "error_logs"
connect = "file_json_sink"

[sink_group.sinks.params]
file = "error.json"
</code></pre>
<hr>
<h2 id="oml-与-sink-关联"><a class="header" href="#oml-与-sink-关联">OML 与 Sink 关联</a></h2>
<h3 id="关联方式"><a class="header" href="#关联方式">关联方式</a></h3>
<p>Sink Group 通过 <code>oml</code> 字段与 OML 模型建立关联，支持三种模式：</p>
<h4 id="1-通配符模式推荐"><a class="header" href="#1-通配符模式推荐">1. 通配符模式（推荐）</a></h4>
<p>使用 <code>["*"]</code> 自动匹配所有符合条件的 OML 模型。</p>
<pre><code class="language-toml">[sink_group]
name = "all_logs"
oml = ["*"]  # 自动匹配所有 OML 模型
</code></pre>
<p><strong>工作原理</strong>：</p>
<ol>
<li>数据携带 WPL Rule（如 <code>/nginx/access_log</code>）</li>
<li>系统遍历所有 OML 模型</li>
<li>找到 <code>rule</code> 字段匹配的 OML 模型</li>
<li>执行转换</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要处理多种类型的数据</li>
<li>OML 模型经常变动</li>
<li>希望自动发现新的 OML 模型</li>
</ul>
<h4 id="2-指定模型名称"><a class="header" href="#2-指定模型名称">2. 指定模型名称</a></h4>
<p>明确列出需要使用的 OML 模型。</p>
<pre><code class="language-toml">[sink_group]
name = "nginx_logs"
oml = ["nginx_access", "nginx_error"]
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>只在指定的 OML 模型列表中查找匹配</li>
<li>其他 OML 模型会被忽略</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>明确知道需要哪些 OML 模型</li>
<li>需要精确控制转换逻辑</li>
<li>避免意外使用其他 OML 模型</li>
</ul>
<h4 id="3-空列表数据透传"><a class="header" href="#3-空列表数据透传">3. 空列表（数据透传）</a></h4>
<p>不使用任何 OML 转换，数据直接输出。</p>
<pre><code class="language-toml">[sink_group]
name = "raw_logs"
oml = []  # 不使用 OML 转换
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>不需要数据转换</li>
<li>直接输出 WPL 解析后的原始数据</li>
</ul>
<hr>
<h2 id="路由规则"><a class="header" href="#路由规则">路由规则</a></h2>
<h3 id="oml-模型匹配规则"><a class="header" href="#oml-模型匹配规则">OML 模型匹配规则</a></h3>
<p>OML 模型通过 <code>rule</code> 字段定义匹配的 WPL Rule 模式，支持通配符。</p>
<p><strong>匹配逻辑</strong>：</p>
<pre><code>数据的 WPL Rule 是否匹配 OML 模型的 rule 字段
</code></pre>
<p><strong>通配符规则</strong>：</p>
<ul>
<li><code>*</code> 匹配任意字符（包括 <code>/</code>）</li>
<li>支持前缀匹配、后缀匹配、完全匹配</li>
</ul>
<p><strong>示例</strong>：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>OML rule 字段</th><th>数据 WPL Rule</th><th>是否匹配</th></tr>
</thead>
<tbody>
<tr><td><code>/nginx/*</code></td><td><code>/nginx/access_log</code></td><td>✅ 匹配</td></tr>
<tr><td><code>/nginx/*</code></td><td><code>/nginx/error_log</code></td><td>✅ 匹配</td></tr>
<tr><td><code>/nginx/access*</code></td><td><code>/nginx/access_log</code></td><td>✅ 匹配</td></tr>
<tr><td><code>/nginx/access*</code></td><td><code>/nginx/error_log</code></td><td>❌ 不匹配</td></tr>
<tr><td><code>*</code></td><td>任意规则</td><td>✅ 匹配</td></tr>
<tr><td><code>/apache/*</code></td><td><code>/nginx/access_log</code></td><td>❌ 不匹配</td></tr>
</tbody>
</table>
</div>
<h3 id="sink-group-规则过滤"><a class="header" href="#sink-group-规则过滤">Sink Group 规则过滤</a></h3>
<p>Sink Group 可以通过 <code>rule</code> 字段进一步限定处理的数据。</p>
<pre><code class="language-toml">[sink_group]
name = "filtered_logs"
oml = ["*"]
rule = ["/nginx/*", "/apache/*"]  # 只处理 Nginx 和 Apache 日志
</code></pre>
<p><strong>工作流程</strong>：</p>
<pre><code>1. 数据的 WPL Rule 是否匹配 Sink Group 的 rule？
   ├─ 是 → 继续
   └─ 否 → 跳过此 Sink Group

2. 查找匹配的 OML 模型
   ├─ 找到 → 执行转换
   └─ 未找到 → 数据透传（如果 oml=["*"] 或 oml=[]）

3. 输出到 Sink
</code></pre>
<hr>
<h2 id="配置示例-3"><a class="header" href="#配置示例-3">配置示例</a></h2>
<h3 id="示例-1基础配置"><a class="header" href="#示例-1基础配置">示例 1：基础配置</a></h3>
<p>处理 Nginx 访问日志并输出到文件。</p>
<p><strong>OML 模型</strong>：<code>oml/nginx_access.oml</code></p>
<pre><code class="language-oml">name : nginx_access
rule : /nginx/access_log
---
user_id = read(user_id) ;
timestamp : time = read(time) ;
status : digit = read(status_code) ;
uri = read(request_uri) ;

access_log : obj = object {
    user : chars = read(user_id) ;
    time : time = read(timestamp) ;
    status : digit = read(status) ;
    uri : chars = read(uri) ;
} ;
</code></pre>
<p><strong>Sink Group 配置</strong>：<code>topology/sinks/nginx_logs.toml</code></p>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "nginx_access_logs"
oml = ["nginx_access"]

[[sink_group.sinks]]
name = "file_output"
connect = "file_json_sink"

[sink_group.sinks.params]
file = "nginx_access.json"
</code></pre>
<hr>
<h3 id="示例-2多-oml-模型配置"><a class="header" href="#示例-2多-oml-模型配置">示例 2：多 OML 模型配置</a></h3>
<p>处理多种类型的日志。</p>
<p><strong>OML 模型 1</strong>：<code>oml/nginx_access.oml</code></p>
<pre><code class="language-oml">name : nginx_access
rule : /nginx/access*
---
user_id = read(user_id) ;
uri = read(request_uri) ;
status : digit = read(status_code) ;
</code></pre>
<p><strong>OML 模型 2</strong>：<code>oml/apache_access.oml</code></p>
<pre><code class="language-oml">name : apache_access
rule : /apache/access*
---
user = read(remote_user) ;
path = read(request) ;
code : digit = read(status) ;
</code></pre>
<p><strong>Sink Group 配置</strong>：<code>topology/sinks/web_logs.toml</code></p>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "all_web_logs"
oml = ["*"]  # 自动匹配所有 OML 模型

[[sink_group.sinks]]
name = "unified_output"
connect = "file_json_sink"

[sink_group.sinks.params]
file = "web_logs.json"
</code></pre>
<hr>
<h3 id="示例-3条件路由"><a class="header" href="#示例-3条件路由">示例 3：条件路由</a></h3>
<p>根据数据类型输出到不同目标。</p>
<p><strong>Sink Group 1</strong>：<code>topology/sinks/error_logs.toml</code></p>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "error_logs"
oml = ["*"]
rule = ["*/error*"]  # 只处理错误日志

[[sink_group.sinks]]
name = "error_file"
connect = "file_json_sink"

[sink_group.sinks.params]
file = "errors.json"
</code></pre>
<p><strong>Sink Group 2</strong>：<code>topology/sinks/access_logs.toml</code></p>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "access_logs"
oml = ["*"]
rule = ["*/access*"]  # 只处理访问日志

[[sink_group.sinks]]
name = "access_file"
connect = "file_json_sink"

[sink_group.sinks.params]
file = "access.json"
</code></pre>
<hr>
<h3 id="示例-4数据富化sql-集成"><a class="header" href="#示例-4数据富化sql-集成">示例 4：数据富化（SQL 集成）</a></h3>
<p>从数据库查询额外信息。</p>
<p><strong>OML 模型</strong>：<code>oml/user_activity.oml</code></p>
<pre><code class="language-oml">name : user_activity
rule : /app/user_activity
---
user_id = read(user_id) ;
action = read(action) ;
timestamp : time = Now::time() ;

# 从数据库查询用户信息
user_name, user_level =
    select name, level
    from users
    where id = read(user_id) ;

# 聚合输出
activity : obj = object {
    user : obj = object {
        id : chars = read(user_id) ;
        name : chars = read(user_name) ;
        level : chars = read(user_level) ;
    } ;
    action : chars = read(action) ;
    time : time = read(timestamp) ;
} ;
</code></pre>
<p><strong>Sink Group 配置</strong>：<code>topology/sinks/user_activities.toml</code></p>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "user_activities"
oml = ["user_activity"]

[[sink_group.sinks]]
name = "kafka_output"
connect = "kafka_sink"

[sink_group.sinks.params]
topic = "user-activities"
brokers = ["localhost:9092"]
</code></pre>
<hr>
<h2 id="工作流程"><a class="header" href="#工作流程">工作流程</a></h2>
<h3 id="完整处理流程"><a class="header" href="#完整处理流程">完整处理流程</a></h3>
<pre><code>1. 数据到达
   ↓
2. WPL 解析
   ├─ 生成结构化数据
   └─ 附加 Rule 标识（如 /nginx/access_log）
   ↓
3. Sink Group 匹配
   ├─ 检查 Sink Group 的 rule 字段
   └─ 匹配 → 继续；不匹配 → 跳过
   ↓
4. OML 模型查找
   ├─ 根据 Sink Group 的 oml 字段
   ├─ 查找匹配的 OML 模型
   └─ 找到 → 转换；未找到 → 透传
   ↓
5. 数据转换（如果有 OML）
   ├─ 执行 OML 转换逻辑
   └─ 生成目标格式数据
   ↓
6. Sink 输出
   ├─ 根据 Connector 配置
   └─ 输出到目标存储
</code></pre>
<h3 id="多-sink-group-并行处理"><a class="header" href="#多-sink-group-并行处理">多 Sink Group 并行处理</a></h3>
<p>一条数据可以被多个 Sink Group 同时处理：</p>
<pre><code>                数据（rule: /nginx/access_log）
                        |
        +---------------+---------------+
        |                               |
    Sink Group 1                   Sink Group 2
    (rule: ["/nginx/*"])          (rule: ["/nginx/access*"])
        |                               |
    OML 转换 A                      OML 转换 B
        |                               |
    输出到文件                       输出到 Kafka
</code></pre>
<hr>
<h2 id="最佳实践-8"><a class="header" href="#最佳实践-8">最佳实践</a></h2>
<h3 id="1-oml-模型命名"><a class="header" href="#1-oml-模型命名">1. OML 模型命名</a></h3>
<p>使用清晰的命名规则：</p>
<pre><code>&lt;数据源&gt;_&lt;数据类型&gt;.oml

示例：
- nginx_access.oml
- apache_error.oml
- system_metrics.oml
</code></pre>
<h3 id="2-rule-模式设计"><a class="header" href="#2-rule-模式设计">2. Rule 模式设计</a></h3>
<p>使用有意义的层次结构：</p>
<pre><code class="language-oml"># 好的示例
rule : /nginx/access_log
rule : /apache/access_log
rule : /system/cpu_metrics

# 避免过于宽泛
rule : *  # 会匹配所有数据
</code></pre>
<h3 id="3-sink-group-组织"><a class="header" href="#3-sink-group-组织">3. Sink Group 组织</a></h3>
<p>按业务逻辑组织 Sink Group：</p>
<pre><code>topology/sinks/
├── web_logs.toml           # Web 日志
├── system_metrics.toml     # 系统监控
├── application_logs.toml   # 应用日志
└── security_events.toml    # 安全事件
</code></pre>
<h3 id="4-使用通配符模式"><a class="header" href="#4-使用通配符模式">4. 使用通配符模式</a></h3>
<p>对于灵活的配置，推荐使用通配符：</p>
<pre><code class="language-toml">[sink_group]
oml = ["*"]  # 自动发现所有 OML 模型
</code></pre>
<h3 id="5-数据透传场景"><a class="header" href="#5-数据透传场景">5. 数据透传场景</a></h3>
<p>不需要转换时，明确使用空列表：</p>
<pre><code class="language-toml">[sink_group]
oml = []  # 明确表示不使用 OML
</code></pre>
<h3 id="6-测试配置"><a class="header" href="#6-测试配置">6. 测试配置</a></h3>
<p>在部署前测试配置：</p>
<ol>
<li>验证 OML 语法</li>
<li>检查 Rule 匹配逻辑</li>
<li>确认 Sink 连接</li>
<li>测试数据流向</li>
</ol>
<hr>
<h2 id="故障排查-1"><a class="header" href="#故障排查-1">故障排查</a></h2>
<h3 id="问题-1数据未经过-oml-转换"><a class="header" href="#问题-1数据未经过-oml-转换">问题 1：数据未经过 OML 转换</a></h3>
<p><strong>可能原因</strong>：</p>
<ul>
<li>OML 模型的 <code>rule</code> 不匹配数据的 WPL Rule</li>
<li>Sink Group 的 <code>oml</code> 配置错误</li>
</ul>
<p><strong>排查步骤</strong>：</p>
<ol>
<li>检查数据的 WPL Rule</li>
<li>检查 OML 模型的 <code>rule</code> 字段</li>
<li>验证通配符匹配逻辑</li>
<li>检查 Sink Group 的 <code>oml</code> 配置</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># OML 模型
rule : /nginx/access_log

# 数据 Rule
/nginx/access  # ❌ 不匹配（缺少 _log）

# 修正
rule : /nginx/access*  # ✅ 匹配
</code></pre>
<hr>
<h3 id="问题-2数据被重复处理"><a class="header" href="#问题-2数据被重复处理">问题 2：数据被重复处理</a></h3>
<p><strong>可能原因</strong>：</p>
<ul>
<li>多个 Sink Group 匹配同一数据</li>
<li>多个 OML 模型匹配同一 Rule</li>
</ul>
<p><strong>排查步骤</strong>：</p>
<ol>
<li>检查所有 Sink Group 的 <code>rule</code> 配置</li>
<li>确认是否需要并行处理</li>
<li>调整 Rule 模式避免重复</li>
</ol>
<hr>
<h3 id="问题-3oml-转换失败"><a class="header" href="#问题-3oml-转换失败">问题 3：OML 转换失败</a></h3>
<p><strong>可能原因</strong>：</p>
<ul>
<li>OML 语法错误</li>
<li>字段不存在</li>
<li>类型转换失败</li>
</ul>
<p><strong>排查步骤</strong>：</p>
<ol>
<li>检查 OML 语法</li>
<li>验证输入数据结构</li>
<li>使用默认值处理缺失字段</li>
<li>检查类型转换逻辑</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 容错处理
port : digit = read(port) { _ : digit(80) } ;
user_id = read(user_id) { _ : chars(unknown) } ;
</code></pre>
<hr>
<h3 id="问题-4sink-输出失败"><a class="header" href="#问题-4sink-输出失败">问题 4：Sink 输出失败</a></h3>
<p><strong>可能原因</strong>：</p>
<ul>
<li>Connector 配置错误</li>
<li>目标存储不可用</li>
<li>权限问题</li>
</ul>
<p><strong>排查步骤</strong>：</p>
<ol>
<li>检查 Connector 配置</li>
<li>验证目标存储连接</li>
<li>检查权限和凭证</li>
<li>查看错误日志</li>
</ol>
<hr>
<h2 id="下一步-8"><a class="header" href="#下一步-8">下一步</a></h2>
<ul>
<li><a href="#oml-实战指南">实战指南</a> - 查看 OML 转换示例</li>
<li><a href="#oml-函数参考">函数参考</a> - 查阅可用函数</li>
<li><a href="#oml-语法参考">语法参考</a> - 查看完整语法</li>
<li><a href="#oml-快速入门">快速入门</a> - 回顾基础用法</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-语法参考"><a class="header" href="#oml-语法参考">OML 语法参考</a></h1>
<p>本文档提供 OML 的完整语法定义（EBNF 格式），用于精确理解语法规则。</p>
<blockquote>
<p>基于源码 <code>crates/wp-oml</code> 的解析实现，词法细节复用 <code>wp_parser</code> 与 <code>wpl</code> 的既有解析能力。</p>
</blockquote>
<hr>
<h2 id="-文档导航-7"><a class="header" href="#-文档导航-7">📚 文档导航</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>章节</th><th>内容</th></tr>
</thead>
<tbody>
<tr><td><a href="#ebnf-符号说明">EBNF 符号说明</a></td><td>语法符号含义</td></tr>
<tr><td><a href="#顶层结构">顶层结构</a></td><td>OML 文件结构</td></tr>
<tr><td><a href="#求值表达式">求值表达式</a></td><td>表达式类型、值表达式、函数调用等</td></tr>
<tr><td><a href="#高级表达式">高级表达式</a></td><td>格式化字符串、管道、match、聚合</td></tr>
<tr><td><a href="#sql-表达式">SQL 表达式</a></td><td>SQL 查询语法</td></tr>
<tr><td><a href="#隐私段">隐私段</a></td><td>数据脱敏语法</td></tr>
<tr><td><a href="#词法与约定">词法与约定</a></td><td>标识符、字面量、注释</td></tr>
<tr><td><a href="#数据类型">数据类型</a></td><td>8 种数据类型</td></tr>
<tr><td><a href="#完整示例-3">完整示例</a></td><td>综合示例</td></tr>
<tr><td><a href="#管道函数速查">管道函数速查</a></td><td>常用管道函数</td></tr>
<tr><td><a href="#语法要点">语法要点</a></td><td>必需元素、可选元素、注意事项</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="ebnf-符号说明"><a class="header" href="#ebnf-符号说明">EBNF 符号说明</a></h2>
<ul>
<li><code>=</code> : 定义</li>
<li><code>,</code> : 连接（序列）</li>
<li><code>|</code> : 或（选择）</li>
<li><code>[ ]</code> : 可选（0 或 1 次）</li>
<li><code>{ }</code> : 重复（0 或多次）</li>
<li><code>( )</code> : 分组</li>
<li><code>"text"</code> : 字面量</li>
<li><code>(* ... *)</code> : 注释</li>
</ul>
<hr>
<h2 id="顶层结构"><a class="header" href="#顶层结构">顶层结构</a></h2>
<pre><code class="language-ebnf">oml              = header, sep_line, aggregate_items, [ sep_line, privacy_items ] ;

header           = "name", ":", name, eol,
                   [ "rule", ":", rule_path, { rule_path }, eol ] ;

sep_line         = "---" ;

name             = path ;                       (* 例如: test *)
rule_path        = wild_path ;                  (* 例如: wpx/abc, wpx/efg *)

aggregate_items  = aggregate_item, { aggregate_item } ;
aggregate_item   = target_list, "=", eval, ";" ;

target_list      = target, { ",", target } ;
target           = target_name, [ ":", data_type ] ;
target_name      = wild_key | "_" ;            (* 允许带通配符 '*'；'_' 表示匿名/丢弃 *)
data_type        = type_ident ;                (* auto|ip|chars|digit|float|time|bool|obj|array *)
</code></pre>
<p><strong>说明</strong>：</p>
<ul>
<li><code>name : &lt;配置名称&gt;</code> - 必需的配置名称声明</li>
<li><code>rule : &lt;规则路径&gt;</code> - 可选的规则关联</li>
<li><code>---</code> - 分隔符，区分声明区和配置区</li>
<li>每个配置条目必须以 <code>;</code> 结束</li>
</ul>
<hr>
<h2 id="求值表达式"><a class="header" href="#求值表达式">求值表达式</a></h2>
<h3 id="表达式类型-1"><a class="header" href="#表达式类型-1">表达式类型</a></h3>
<pre><code class="language-ebnf">eval             = take_expr
                 | read_expr
                 | fmt_expr
                 | pipe_expr
                 | map_expr
                 | collect_expr
                 | match_expr
                 | sql_expr
                 | value_expr
                 | fun_call ;
</code></pre>
<h3 id="读取表达式"><a class="header" href="#读取表达式">读取表达式</a></h3>
<pre><code class="language-ebnf">(* 变量获取：take/read 支持统一参数形态；可跟缺省体 *)
take_expr        = "take", "(", [ arg_list ], ")", [ default_body ] ;
read_expr        = "read", "(", [ arg_list ], ")", [ default_body ] ;

arg_list         = arg, { ",", arg } ;
arg              = "option", ":", "[", key, { ",", key }, "]"
                 | ("in"|"keys"), ":", "[", key, { ",", key }, "]"
                 | "get",    ":", simple
                 | json_path ;                 (* 见 wp_parser::atom::take_json_path *)

default_body     = "{", "_", ":", gen_acq, [ ";" ], "}" ;
gen_acq          = take_expr | read_expr | value_expr | fun_call ;
</code></pre>
<p><strong>说明</strong>：</p>
<ul>
<li><code>@</code> 仅作为变量获取语法糖用于 fmt/pipe/collect 的 var_get 位置</li>
<li><code>@ref</code> 等价于 <code>read(ref)</code>，但不支持缺省体</li>
<li>不作为独立求值表达式</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 基本读取
value = read(field) ;

# 带默认值
value = read(field) { _ : chars(default) } ;

# option 参数
value = read(option:[id, uid, user_id]) ;

# keys 参数
values = collect read(keys:[field1, field2]) ;

# JSON 路径
name = read(/user/info/name) ;
</code></pre>
<h3 id="值表达式-1"><a class="header" href="#值表达式-1">值表达式</a></h3>
<pre><code class="language-ebnf">(* 常量值：类型名+括号包裹的字面量 *)
value_expr       = data_type, "(", literal, ")" ;
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">text = chars(hello) ;
count = digit(42) ;
address = ip(192.168.1.1) ;
flag = bool(true) ;
</code></pre>
<h3 id="函数调用-1"><a class="header" href="#函数调用-1">函数调用</a></h3>
<pre><code class="language-ebnf">(* 内置函数（零参占位）：Now::* 家族 *)
fun_call         = ("Now::time"
                   |"Now::date"
                   |"Now::hour"), "(", ")" ;
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">now = Now::time() ;
today = Now::date() ;
hour = Now::hour() ;
</code></pre>
<hr>
<h2 id="高级表达式"><a class="header" href="#高级表达式">高级表达式</a></h2>
<h3 id="格式化字符串"><a class="header" href="#格式化字符串">格式化字符串</a></h3>
<pre><code class="language-ebnf">(* 字符串格式化，至少 1 个参数 *)
fmt_expr         = "fmt", "(", string, ",", var_get, { ",", var_get }, ")" ;
var_get          = ("read" | "take"), "(", [ arg_list ], ")"
                 | "@", ident ;                  (* '@ref' 等价 read(ref)，不支持缺省体 *)
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">message = fmt("{}-{}", @user, read(city)) ;
id = fmt("{}:{}", read(host), read(port)) ;
</code></pre>
<h3 id="管道表达式-1"><a class="header" href="#管道表达式-1">管道表达式</a></h3>
<pre><code class="language-ebnf">(* 管道：可省略 pipe 关键字 *)
pipe_expr        = ["pipe"], var_get, "|", pipe_fun, { "|", pipe_fun } ;

pipe_fun         = "nth",           "(", unsigned, ")"
                 | "get",           "(", ident,   ")"
                 | "base64_decode", "(", [ encode_type ], ")"
                 | "sxf_get",       "(", alnum*,  ")"
                 | "path",          "(", ("name"|"path"), ")"
                 | "url",           "(", ("domain"|"host"|"uri"|"path"|"params"), ")"
                 | "Time::to_ts_zone", "(", [ "-" ], unsigned, ",", ("ms"|"us"|"ss"|"s"), ")"
                 | "base64_encode" | "html_escape" | "html_unescape"
                 | "str_escape" | "json_escape" | "json_unescape"
                 | "Time::to_ts" | "Time::to_ts_ms" | "Time::to_ts_us"
                 | "to_json" | "to_str" | "skip_empty" | "ip4_to_int" ;

encode_type      = ident ;                     (* 例如: Utf8/Gbk/Imap/... *)
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 使用 pipe 关键字
result = pipe read(data) | to_json | base64_encode ;

# 省略 pipe 关键字
result = read(data) | to_json | base64_encode ;

# 时间转换
ts = read(time) | Time::to_ts_zone(0, ms) ;

# URL 解析
host = read(url) | url(host) ;
</code></pre>
<h3 id="对象聚合"><a class="header" href="#对象聚合">对象聚合</a></h3>
<pre><code class="language-ebnf">(* 聚合到对象：object 内部为子赋值序列；分号可选但推荐 *)
map_expr         = "object", "{", map_item, { map_item }, "}" ;
map_item         = map_targets, "=", sub_acq, [ ";" ] ;
map_targets      = ident, { ",", ident }, [ ":", data_type ] ;
sub_acq          = take_expr | read_expr | value_expr | fun_call ;
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">info : obj = object {
    name : chars = read(name) ;
    age : digit = read(age) ;
    city : chars = read(city) ;
} ;
</code></pre>
<h3 id="数组聚合"><a class="header" href="#数组聚合">数组聚合</a></h3>
<pre><code class="language-ebnf">(* 聚合到数组：从 VarGet 收集（支持 keys/option 通配） *)
collect_expr     = "collect", var_get ;
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 收集多个字段
ports = collect read(keys:[sport, dport]) ;

# 使用通配符
metrics = collect read(keys:[cpu_*]) ;
</code></pre>
<h3 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h3>
<pre><code class="language-ebnf">(* 模式匹配：单源/双源两种形态，支持 in/!= 与缺省分支 *)
match_expr       = "match", match_source, "{", case1, { case1 }, [ default_case ], "}"
                 | "match", "(", var_get, ",", var_get, ")", "{", case2, { case2 }, [ default_case ], "}" ;

match_source     = var_get ;
case1            = cond1, "=&gt;", calc, [ "," ], [ ";" ] ;
case2            = "(", cond1, ",", cond1, ")", "=&gt;", calc, [ "," ], [ ";" ] ;
default_case     = "_", "=&gt;", calc, [ "," ], [ ";" ] ;
calc             = read_expr | take_expr | value_expr | collect_expr ;

cond1            = "in", "(", value_expr, ",", value_expr, ")"
                 | "!", value_expr
                 | value_expr ;                 (* 省略运算符表示等于 *)
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 单源匹配
level = match read(status) {
    in (digit(200), digit(299)) =&gt; chars(success) ;
    in (digit(400), digit(499)) =&gt; chars(error) ;
    _ =&gt; chars(other) ;
} ;

# 双源匹配
result = match (read(a), read(b)) {
    (digit(1), digit(2)) =&gt; chars(case1) ;
    _ =&gt; chars(default) ;
} ;
</code></pre>
<hr>
<h2 id="sql-表达式"><a class="header" href="#sql-表达式">SQL 表达式</a></h2>
<pre><code class="language-ebnf">sql_expr        = "select", sql_body, "where", sql_cond, ";" ;
sql_body        = sql_safe_body ;              (* 源码对白名单化：仅 [A-Za-z0-9_.] 与 '*' *)
sql_cond        = cond_expr ;

cond_expr       = cmp, { ("and" | "or"), cmp }
                 | "not", cond_expr
                 | "(", cond_expr, ")" ;

cmp             = ident, sql_op, cond_rhs ;
sql_op          = sql_cmp_op ;                 (* 见 wp_parser::sql_symbol::symbol_sql_cmp *)
cond_rhs        = read_expr | take_expr | fun_call | sql_literal ;
sql_literal     = number | string ;
</code></pre>
<h3 id="严格模式说明"><a class="header" href="#严格模式说明">严格模式说明</a></h3>
<ul>
<li><strong>严格模式（默认开启）</strong>：当主体 <code>&lt;cols from table&gt;</code> 不满足白名单规则时，解析报错</li>
<li><strong>兼容模式</strong>：设置环境变量 <code>OML_SQL_STRICT=0</code>，若主体非法则回退原文（不推荐）</li>
<li><strong>白名单规则</strong>：
<ul>
<li>列清单：<code>*</code> 或由 <code>[A-Za-z0-9_.]+</code> 组成的列名（允许点号作限定）</li>
<li>表名：<code>[A-Za-z0-9_.]+</code>（单表，不支持 join/子查询）</li>
<li><code>from</code> 大小写不敏感；多余空白允许</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml"># 正确示例
name, email = select name, email from users where id = read(user_id) ;

# 使用字符串常量
data = select * from table where type = 'admin' ;

# IP 范围查询
zone = select zone from ip_geo
    where ip_start_int &lt;= ip4_int(read(src_ip))
      and ip_end_int &gt;= ip4_int(read(src_ip)) ;
</code></pre>
<p><strong>错误示例（严格模式）</strong>：</p>
<pre><code class="language-oml"># ❌ 表名含非法字符
data = select a, b from table-1 where ... ;

# ❌ 列清单含函数
data = select sum(a) from t where ... ;

# ❌ 不支持 join
data = select a from t1 join t2 ... ;
</code></pre>
<hr>
<h2 id="隐私段"><a class="header" href="#隐私段">隐私段</a></h2>
<blockquote>
<p>注：引擎默认不启用运行期隐私/脱敏处理；以下为 DSL 语法能力说明，供需要的场景参考。</p>
</blockquote>
<pre><code class="language-ebnf">privacy_items   = privacy_item, { privacy_item } ;
privacy_item    = ident, ":", privacy_type ;

privacy_type    = "privacy_ip"
                 | "privacy_specify_ip"
                 | "privacy_id_card"
                 | "privacy_mobile"
                 | "privacy_mail"
                 | "privacy_domain"
                 | "privacy_specify_name"
                 | "privacy_specify_domain"
                 | "privacy_specify_address"
                 | "privacy_specify_company"
                 | "privacy_keymsg" ;
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="language-oml">name : privacy_example
---
field = read() ;
---
src_ip : privacy_ip
pos_sn : privacy_keymsg
</code></pre>
<hr>
<h2 id="词法与约定"><a class="header" href="#词法与约定">词法与约定</a></h2>
<pre><code class="language-ebnf">path            = ident, { ("/" | "."), ident } ;
wild_path       = path | path, "*" ;          (* 允许通配 *)
wild_key        = ident, { ident | "*" } ;    (* 允许 '*' 出现在键名中 *)
type_ident      = ident ;                      (* 如 auto/ip/chars/digit/float/time/bool/obj/array *)
ident           = letter, { letter | digit | "_" } ;
key             = ident ;

string          = "\"", { any-but-quote }, "\""
                | "'", { any-but-quote }, "'" ;

literal         = string | number | ip | bool | datetime | ... ;
json_path       = "/" , ... ;                 (* 如 /a/b/[0]/1 *)
simple          = ident | number | string ;
unsigned        = digit, { digit } ;
eol             = { " " | "\t" | "\r" | "\n" } ;

letter          = "A" | ... | "Z" | "a" | ... | "z" ;
digit           = "0" | ... | "9" ;
alnum           = letter | digit ;
</code></pre>
<hr>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<p>OML 支持以下数据类型：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类型</th><th>说明</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td><code>auto</code></td><td>自动推断（默认）</td><td><code>field = read() ;</code></td></tr>
<tr><td><code>chars</code></td><td>字符串</td><td><code>name : chars = read() ;</code></td></tr>
<tr><td><code>digit</code></td><td>整数</td><td><code>count : digit = read() ;</code></td></tr>
<tr><td><code>float</code></td><td>浮点数</td><td><code>ratio : float = read() ;</code></td></tr>
<tr><td><code>ip</code></td><td>IP 地址</td><td><code>addr : ip = read() ;</code></td></tr>
<tr><td><code>time</code></td><td>时间</td><td><code>timestamp : time = Now::time() ;</code></td></tr>
<tr><td><code>bool</code></td><td>布尔值</td><td><code>flag : bool = read() ;</code></td></tr>
<tr><td><code>obj</code></td><td>对象</td><td><code>info : obj = object { ... } ;</code></td></tr>
<tr><td><code>array</code></td><td>数组</td><td><code>items : array = collect read(...) ;</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="完整示例-3"><a class="header" href="#完整示例-3">完整示例</a></h2>
<pre><code class="language-oml">name : csv_example
rule : /csv/data
---
# 基本取值与缺省
version : chars = Now::time() ;
pos_sn = read() { _ : chars(FALLBACK) } ;

# object 聚合
values : obj = object {
    cpu_free, memory_free : digit = read() ;
} ;

# collect 数组聚合 + 管道
ports : array = collect read(keys:[sport, dport]) ;
ports_json = pipe read(ports) | to_json ;
first_port = pipe read(ports) | nth(0) ;

# 省略 pipe 关键字的管道写法
url_host = read(http_url) | url(host) ;

# match
quarter : chars = match read(month) {
    in (digit(1), digit(3))   =&gt; chars(Q1) ;
    in (digit(4), digit(6))   =&gt; chars(Q2) ;
    in (digit(7), digit(9))   =&gt; chars(Q3) ;
    in (digit(10), digit(12)) =&gt; chars(Q4) ;
    _ =&gt; chars(QX) ;
} ;

# 双源 match
X : chars = match (read(city1), read(city2)) {
    (ip(127.0.0.1), ip(127.0.0.100)) =&gt; chars(bj) ;
    _ =&gt; chars(sz) ;
} ;

# SQL（where 中可混用 read/take/Now::time/常量）
name, pinying = select name, pinying from example where pinying = read(py) ;
_, _ = select name, pinying from example where pinying = 'xiaolongnu' ;

---
# 隐私配置（按键绑定处理器枚举）
src_ip : privacy_ip
pos_sn : privacy_keymsg
</code></pre>
<hr>
<h2 id="管道函数速查"><a class="header" href="#管道函数速查">管道函数速查</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>base64_encode</code></td><td><code>base64_encode</code></td><td>Base64 编码</td></tr>
<tr><td><code>base64_decode</code></td><td><code>base64_decode</code> / <code>base64_decode(编码)</code></td><td>Base64 解码</td></tr>
<tr><td><code>html_escape</code></td><td><code>html_escape</code></td><td>HTML 转义</td></tr>
<tr><td><code>html_unescape</code></td><td><code>html_unescape</code></td><td>HTML 反转义</td></tr>
<tr><td><code>json_escape</code></td><td><code>json_escape</code></td><td>JSON 转义</td></tr>
<tr><td><code>json_unescape</code></td><td><code>json_unescape</code></td><td>JSON 反转义</td></tr>
<tr><td><code>str_escape</code></td><td><code>str_escape</code></td><td>字符串转义</td></tr>
<tr><td><code>Time::to_ts</code></td><td><code>Time::to_ts</code></td><td>时间转时间戳（秒，UTC+8）</td></tr>
<tr><td><code>Time::to_ts_ms</code></td><td><code>Time::to_ts_ms</code></td><td>时间转时间戳（毫秒，UTC+8）</td></tr>
<tr><td><code>Time::to_ts_us</code></td><td><code>Time::to_ts_us</code></td><td>时间转时间戳（微秒，UTC+8）</td></tr>
<tr><td><code>Time::to_ts_zone</code></td><td><code>Time::to_ts_zone(时区,单位)</code></td><td>时间转指定时区时间戳</td></tr>
<tr><td><code>nth</code></td><td><code>nth(索引)</code></td><td>获取数组元素</td></tr>
<tr><td><code>get</code></td><td><code>get(字段名)</code></td><td>获取对象字段</td></tr>
<tr><td><code>path</code></td><td><code>path(name|path)</code></td><td>提取文件路径部分</td></tr>
<tr><td><code>url</code></td><td><code>url(domain|host|uri|path|params)</code></td><td>提取 URL 部分</td></tr>
<tr><td><code>sxf_get</code></td><td><code>sxf_get(字段名)</code></td><td>提取特殊格式字段</td></tr>
<tr><td><code>to_str</code></td><td><code>to_str</code></td><td>转换为字符串</td></tr>
<tr><td><code>to_json</code></td><td><code>to_json</code></td><td>转换为 JSON</td></tr>
<tr><td><code>ip4_to_int</code></td><td><code>ip4_to_int</code></td><td>IPv4 转整数</td></tr>
<tr><td><code>skip_empty</code></td><td><code>skip_empty</code></td><td>跳过空值</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="语法要点"><a class="header" href="#语法要点">语法要点</a></h2>
<h3 id="必需元素"><a class="header" href="#必需元素">必需元素</a></h3>
<ol>
<li><strong>配置名称</strong>：<code>name : &lt;名称&gt;</code></li>
<li><strong>分隔符</strong>：<code>---</code></li>
<li><strong>分号</strong>：每个顶层条目必须以 <code>;</code> 结束</li>
</ol>
<h3 id="可选元素"><a class="header" href="#可选元素">可选元素</a></h3>
<ol>
<li><strong>类型声明</strong>：<code>field : &lt;type&gt; = ...</code>（默认为 <code>auto</code>）</li>
<li><strong>rule 字段</strong>：<code>rule : &lt;规则路径&gt;</code></li>
<li><strong>默认值</strong>：<code>read() { _ : &lt;默认值&gt; }</code></li>
<li><strong>pipe 关键字</strong>：<code>pipe read() | func</code> 可简写为 <code>read() | func</code></li>
</ol>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<pre><code class="language-oml"># 单行注释（使用 # 或 //）
// 也支持 C++ 风格注释
</code></pre>
<h3 id="目标通配"><a class="header" href="#目标通配">目标通配</a></h3>
<pre><code class="language-oml">* = take() ;           # 取走所有字段
alert* = take() ;      # 取走所有以 alert 开头的字段
*_log = take() ;       # 取走所有以 _log 结尾的字段
</code></pre>
<h3 id="读取语义"><a class="header" href="#读取语义">读取语义</a></h3>
<ul>
<li><strong>read</strong>：非破坏性（可反复读取，不从 src 移除）</li>
<li><strong>take</strong>：破坏性（取走后从 src 移除，后续不可再取）</li>
</ul>
<hr>
<h2 id="下一步-9"><a class="header" href="#下一步-9">下一步</a></h2>
<ul>
<li><a href="#oml-核心概念">核心概念</a> - 理解语法设计理念</li>
<li><a href="#oml-实战指南">实战指南</a> - 查看实际应用示例</li>
<li><a href="#oml-函数参考">函数参考</a> - 查阅所有可用函数</li>
<li><a href="#oml-快速入门">快速入门</a> - 快速上手 OML</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-pipe-functions-函数索引"><a class="header" href="#oml-pipe-functions-函数索引">OML Pipe Functions 函数索引</a></h1>
<p>本文档列出了 WP-Motor OML 语言中所有可用的 pipe function（管道函数）。</p>
<h2 id="字段访问函数-field-accessors"><a class="header" href="#字段访问函数-field-accessors">字段访问函数 (Field Accessors)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>take</code></td><td><code>take(field_name)</code></td><td>从输入数据中提取指定字段</td><td>-</td></tr>
<tr><td><code>get</code></td><td><code>get(key)</code></td><td>从嵌套结构中获取指定键的值</td><td>-</td></tr>
<tr><td><code>nth</code></td><td><code>nth(index)</code></td><td>从数组中获取指定索引的元素</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="字符串匹配函数-string-matching-1"><a class="header" href="#字符串匹配函数-string-matching-1">字符串匹配函数 (String Matching)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>starts_with</code></td><td><code>starts_with('prefix')</code></td><td>检查字符串是否以指定前缀开始，否则转为 ignore</td><td><a href="#starts_with-函数使用指南-1">📖 详细文档</a></td></tr>
</tbody>
</table>
</div>
<h2 id="值转换函数-value-transformation"><a class="header" href="#值转换函数-value-transformation">值转换函数 (Value Transformation)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>map_to</code></td><td><code>map_to(value)</code></td><td>将非 ignore 字段映射到指定值（支持多种类型）</td><td><a href="#map_to-函数使用指南">📖 详细文档</a></td></tr>
<tr><td><code>to_str</code></td><td><code>to_str</code></td><td>将字段值转换为字符串</td><td>-</td></tr>
<tr><td><code>to_json</code></td><td><code>to_json</code></td><td>将字段值转换为 JSON 字符串</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="编码解码函数-encodingdecoding"><a class="header" href="#编码解码函数-encodingdecoding">编码/解码函数 (Encoding/Decoding)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>base64_encode</code></td><td><code>base64_encode</code></td><td>Base64 编码字符串</td><td>-</td></tr>
<tr><td><code>base64_decode</code></td><td><code>base64_decode(encoding)</code></td><td>Base64 解码字符串（可指定编码）</td><td>-</td></tr>
<tr><td><code>html_escape</code></td><td><code>html_escape</code></td><td>HTML 转义字符串</td><td>-</td></tr>
<tr><td><code>html_unescape</code></td><td><code>html_unescape</code></td><td>HTML 反转义字符串</td><td>-</td></tr>
<tr><td><code>json_escape</code></td><td><code>json_escape</code></td><td>JSON 转义字符串</td><td>-</td></tr>
<tr><td><code>json_unescape</code></td><td><code>json_unescape</code></td><td>JSON 反转义字符串</td><td>-</td></tr>
<tr><td><code>str_escape</code></td><td><code>str_escape</code></td><td>通用字符串转义</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="时间转换函数-time-conversion"><a class="header" href="#时间转换函数-time-conversion">时间转换函数 (Time Conversion)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>Time::to_ts</code></td><td><code>Time::to_ts</code></td><td>将时间转换为秒级时间戳</td><td>-</td></tr>
<tr><td><code>Time::to_ts_ms</code></td><td><code>Time::to_ts_ms</code></td><td>将时间转换为毫秒级时间戳</td><td>-</td></tr>
<tr><td><code>Time::to_ts_us</code></td><td><code>Time::to_ts_us</code></td><td>将时间转换为微秒级时间戳</td><td>-</td></tr>
<tr><td><code>Time::to_ts_zone</code></td><td><code>Time::to_ts_zone(zone, unit)</code></td><td>将时间转换为指定时区的时间戳</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="网络函数-network"><a class="header" href="#网络函数-network">网络函数 (Network)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>ip4_to_int</code></td><td><code>ip4_to_int</code></td><td>将 IPv4 地址转换为整数</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="url路径解析函数-urlpath-parsing"><a class="header" href="#url路径解析函数-urlpath-parsing">URL/路径解析函数 (URL/Path Parsing)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>path(type)</code></td><td>从路径字符串中提取指定部分</td><td>-</td></tr>
<tr><td><code>url</code></td><td><code>url(type)</code></td><td>从 URL 字符串中提取指定部分</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="控制流函数-control-flow"><a class="header" href="#控制流函数-control-flow">控制流函数 (Control Flow)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>语法</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>skip_empty</code></td><td><code>skip_empty</code></td><td>跳过空值字段</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="函数分类总览-1"><a class="header" href="#函数分类总览-1">函数分类总览</a></h2>
<h3 id="按功能分类-1"><a class="header" href="#按功能分类-1">按功能分类</a></h3>
<h4 id="1-数据提取函数"><a class="header" href="#1-数据提取函数">1. 数据提取函数</a></h4>
<p>从输入数据或嵌套结构中提取字段。</p>
<ul>
<li><code>take(field)</code>: 提取顶层字段</li>
<li><code>get(key)</code>: 提取嵌套字段</li>
<li><code>nth(index)</code>: 提取数组元素</li>
</ul>
<h4 id="2-条件过滤函数"><a class="header" href="#2-条件过滤函数">2. 条件过滤函数</a></h4>
<p>检查条件，不满足时转换为 ignore。</p>
<ul>
<li><code>starts_with(prefix)</code>: 前缀匹配</li>
</ul>
<h4 id="3-值映射函数"><a class="header" href="#3-值映射函数">3. 值映射函数</a></h4>
<p>修改字段值或类型。</p>
<ul>
<li><code>map_to(value)</code>: 通用值映射</li>
<li><code>to_str</code>: 转字符串</li>
<li><code>to_json</code>: 转 JSON</li>
</ul>
<h4 id="4-编码转换函数"><a class="header" href="#4-编码转换函数">4. 编码转换函数</a></h4>
<p>在不同编码格式之间转换。</p>
<ul>
<li>Base64: <code>base64_encode</code>, <code>base64_decode</code></li>
<li>HTML: <code>html_escape</code>, <code>html_unescape</code></li>
<li>JSON: <code>json_escape</code>, <code>json_unescape</code></li>
</ul>
<h4 id="5-时间处理函数"><a class="header" href="#5-时间处理函数">5. 时间处理函数</a></h4>
<p>处理时间相关的转换。</p>
<ul>
<li>时间戳转换: <code>Time::to_ts*</code></li>
<li>时区转换: <code>Time::to_ts_zone</code></li>
</ul>
<h4 id="6-网络处理函数"><a class="header" href="#6-网络处理函数">6. 网络处理函数</a></h4>
<p>处理网络相关数据。</p>
<ul>
<li>IP 地址: <code>ip4_to_int</code></li>
<li>URL 解析: <code>url(type)</code></li>
<li>路径解析: <code>path(type)</code></li>
</ul>
<h2 id="使用示例-4"><a class="header" href="#使用示例-4">使用示例</a></h2>
<h3 id="基本管道"><a class="header" href="#基本管道">基本管道</a></h3>
<pre><code class="language-oml">name : basic_pipeline
---
# 1. 提取字段
result = pipe take(message)
    # 2. 过滤条件
    | starts_with('ERROR')
    # 3. 值映射
    | map_to('error_type');
</code></pre>
<h3 id="复杂转换"><a class="header" href="#复杂转换">复杂转换</a></h3>
<pre><code class="language-oml">name : complex_transformation
---
# 提取并转换时间
timestamp_ms = pipe take(time_str)
    | Time::to_ts_ms;

# Base64 编码
encoded = pipe take(message)
    | base64_encode;

# URL 解析
host = pipe take(url)
    | url(host);
</code></pre>
<h3 id="条件分类"><a class="header" href="#条件分类">条件分类</a></h3>
<pre><code class="language-oml">name : conditional_classification
---
# 根据 URL 前缀分类安全级别
high_security = pipe take(url)
    | starts_with('https://')
    | map_to(3);

low_security = pipe take(url)
    | starts_with('http://')
    | map_to(1);
</code></pre>
<h3 id="数据清洗"><a class="header" href="#数据清洗">数据清洗</a></h3>
<pre><code class="language-oml">name : data_cleaning
---
# 提取并清理数据
clean_message = pipe take(raw_message)
    | html_unescape
    | json_unescape
    | skip_empty;
</code></pre>
<h2 id="性能参考-1"><a class="header" href="#性能参考-1">性能参考</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数类型</th><th>典型性能</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>字段访问</td><td>&lt; 100ns</td><td>基于哈希表查找</td></tr>
<tr><td>字符串匹配</td><td>&lt; 1μs</td><td>简单前缀比较</td></tr>
<tr><td>值映射</td><td>&lt; 100ns</td><td>直接值替换</td></tr>
<tr><td>Base64 编码</td><td>1-10μs</td><td>取决于字符串长度</td></tr>
<tr><td>时间转换</td><td>1-5μs</td><td>时间解析和转换</td></tr>
<tr><td>URL 解析</td><td>1-10μs</td><td>URL 结构解析</td></tr>
</tbody>
</table>
</div>
<h2 id="最佳实践-9"><a class="header" href="#最佳实践-9">最佳实践</a></h2>
<h3 id="1-合理使用管道链"><a class="header" href="#1-合理使用管道链">1. 合理使用管道链</a></h3>
<pre><code class="language-oml"># ✅ 推荐：按逻辑顺序组织管道
result = pipe take(field)
    | starts_with('prefix')  # 先过滤
    | map_to('value');      # 再映射

# ⚠️ 避免：不必要的长管道
result = pipe take(field)
    | to_str
    | to_json
    | to_str  # 冗余操作
</code></pre>
<h3 id="2-利用-ignore-传播"><a class="header" href="#2-利用-ignore-传播">2. 利用 ignore 传播</a></h3>
<pre><code class="language-oml"># ✅ 推荐：利用 ignore 跳过后续处理
secure_flag = pipe take(url)
    | starts_with('https://')  # 失败返回 ignore
    | map_to(true);           # ignore 会跳过此步

# 这样可以安全地处理条件逻辑
</code></pre>
<h3 id="3-选择合适的函数"><a class="header" href="#3-选择合适的函数">3. 选择合适的函数</a></h3>
<pre><code class="language-oml"># ✅ 推荐：使用专用函数
result = pipe take(field) | map_to(123);  # 自动推断为整数

# ⚠️ 不推荐：手动转换
result = pipe take(field) | to_str | map_to('123');  # 额外开销
</code></pre>
<h3 id="4-避免重复提取"><a class="header" href="#4-避免重复提取">4. 避免重复提取</a></h3>
<pre><code class="language-oml"># ✅ 推荐：一次提取，多次使用
url_field = pipe take(url);
host = pipe take(url) | url(host);
path = pipe take(url) | url(path);

# ⚠️ 避免：每次都提取同一字段（性能影响小但不够清晰）
</code></pre>
<h2 id="函数对比-1"><a class="header" href="#函数对比-1">函数对比</a></h2>
<h3 id="starts_with-vs-正则表达式"><a class="header" href="#starts_with-vs-正则表达式">starts_with vs 正则表达式</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>starts_with</th><th>正则表达式</th></tr>
</thead>
<tbody>
<tr><td>性能</td><td>极快</td><td>较慢</td></tr>
<tr><td>功能</td><td>前缀匹配</td><td>复杂模式</td></tr>
<tr><td>使用难度</td><td>简单</td><td>需要学习</td></tr>
<tr><td>失败行为</td><td>转为 ignore</td><td>-</td></tr>
</tbody>
</table>
</div>
<h3 id="map_to-vs-to_str"><a class="header" href="#map_to-vs-to_str">map_to vs to_str</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>map_to</th><th>to_str</th></tr>
</thead>
<tbody>
<tr><td>功能</td><td>值替换</td><td>类型转换</td></tr>
<tr><td>类型支持</td><td>多种</td><td>仅字符串</td></tr>
<tr><td>ignore 保留</td><td>是</td><td>否</td></tr>
<tr><td>用途</td><td>条件赋值</td><td>类型转换</td></tr>
</tbody>
</table>
</div>
<h2 id="相关文档-6"><a class="header" href="#相关文档-6">相关文档</a></h2>
<ul>
<li><strong>开发指南</strong>: <a href="10-user/guide/oml_pipefun_development_guide.html">OML Pipe Function 开发指南</a></li>
<li><strong>语法参考</strong>: <a href="10-user/syntax/oml_syntax.html">OML 语法指南</a></li>
</ul>
<h2 id="版本历史-7"><a class="header" href="#版本历史-7">版本历史</a></h2>
<ul>
<li>
<p><strong>1.13.4</strong> (2026-02-03)</p>
<ul>
<li>新增 <code>starts_with</code> 函数</li>
<li>新增 <code>map_to</code> 函数，支持多种类型自动推断</li>
<li>完善文档体系</li>
</ul>
</li>
<li>
<p><strong>1.13.3</strong> (2026-02-03)</p>
<ul>
<li>修复编译错误</li>
</ul>
</li>
<li>
<p><strong>1.13.2</strong> (2026-02-03)</p>
<ul>
<li>完善 pipe 函数支持</li>
</ul>
</li>
</ul>
<hr>
<p><strong>提示</strong>: OML pipe 函数设计用于数据转换和映射。合理使用 ignore 机制可以实现灵活的条件逻辑。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oml-match-表达式函数匹配"><a class="header" href="#oml-match-表达式函数匹配">OML Match 表达式函数匹配</a></h1>
<p>本文档介绍 OML <code>match</code> 表达式中的函数匹配功能。</p>
<h2 id="概述-6"><a class="header" href="#概述-6">概述</a></h2>
<p>从版本 1.13.4 开始，OML 的 <code>match</code> 表达式支持使用函数进行模式匹配，提供比简单值比较更灵活的匹配方式。</p>
<h3 id="基本语法-8"><a class="header" href="#基本语法-8">基本语法</a></h3>
<pre><code class="language-oml">field_name = match read(source_field) {
    function_name(arguments) =&gt; result_value,
    _ =&gt; default_value,
};
</code></pre>
<h3 id="与-pipe-function-的区别"><a class="header" href="#与-pipe-function-的区别">与 Pipe Function 的区别</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>Match 函数</th><th>Pipe 函数</th></tr>
</thead>
<tbody>
<tr><td><strong>用途</strong></td><td>多分支条件判断</td><td>二元过滤（保留/忽略）</td></tr>
<tr><td><strong>返回</strong></td><td>根据条件返回不同的值</td><td>匹配返回原值，不匹配返回 ignore</td></tr>
<tr><td><strong>场景</strong></td><td>分类、路由、决策</td><td>过滤、清洗</td></tr>
</tbody>
</table>
</div>
<p><strong>示例对比</strong>:</p>
<pre><code class="language-oml"># Match: 根据前缀分类到不同结果
EventType = match read(log) {
    starts_with('[ERROR]') =&gt; chars(error),
    starts_with('[WARN]') =&gt; chars(warning),
    starts_with('[INFO]') =&gt; chars(info),
    _ =&gt; chars(other),
};

# Pipe: 过滤出 ERROR 日志，其他变为 ignore
ErrorLog = pipe take(log) | starts_with('[ERROR]');
</code></pre>
<h2 id="支持的函数"><a class="header" href="#支持的函数">支持的函数</a></h2>
<h3 id="字符串匹配函数"><a class="header" href="#字符串匹配函数">字符串匹配函数</a></h3>
<h4 id="starts_withprefix"><a class="header" href="#starts_withprefix">starts_with(prefix)</a></h4>
<p>检查字段值是否以指定前缀开始。</p>
<p><strong>语法</strong>: <code>starts_with('prefix')</code></p>
<p><strong>参数</strong>:</p>
<ul>
<li><code>prefix</code>: 字符串，要匹配的前缀（必须使用引号）</li>
</ul>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>字段值以指定前缀开始 → 匹配成功</li>
<li>字段值不以指定前缀开始 → 匹配失败</li>
<li>字段不是字符串类型 → 匹配失败</li>
<li>大小写敏感</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">EventType = match read(log_line) {
    starts_with('[ERROR]') =&gt; chars(error),
    starts_with('[WARN]') =&gt; chars(warning),
    _ =&gt; chars(info),
};
</code></pre>
<h4 id="ends_withsuffix"><a class="header" href="#ends_withsuffix">ends_with(suffix)</a></h4>
<p>检查字段值是否以指定后缀结束。</p>
<p><strong>语法</strong>: <code>ends_with('suffix')</code></p>
<p><strong>参数</strong>:</p>
<ul>
<li><code>suffix</code>: 字符串，要匹配的后缀（必须使用引号）</li>
</ul>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>字段值以指定后缀结束 → 匹配成功</li>
<li>字段值不以指定后缀结束 → 匹配失败</li>
<li>字段不是字符串类型 → 匹配失败</li>
<li>大小写敏感</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">FileType = match read(filename) {
    ends_with('.json') =&gt; chars(json),
    ends_with('.xml') =&gt; chars(xml),
    ends_with('.log') =&gt; chars(log),
    _ =&gt; chars(unknown),
};
</code></pre>
<h4 id="containssubstring"><a class="header" href="#containssubstring">contains(substring)</a></h4>
<p>检查字段值是否包含指定子串。</p>
<p><strong>语法</strong>: <code>contains('substring')</code></p>
<p><strong>参数</strong>:</p>
<ul>
<li><code>substring</code>: 字符串，要匹配的子串（必须使用引号）</li>
</ul>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>字段值包含指定子串 → 匹配成功</li>
<li>字段值不包含指定子串 → 匹配失败</li>
<li>字段不是字符串类型 → 匹配失败</li>
<li>大小写敏感</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">ErrorType = match read(message) {
    contains('exception') =&gt; chars(exception),
    contains('timeout') =&gt; chars(timeout),
    contains('failed') =&gt; chars(failure),
    _ =&gt; chars(normal),
};
</code></pre>
<h4 id="regex_matchpattern"><a class="header" href="#regex_matchpattern">regex_match(pattern)</a></h4>
<p>使用正则表达式匹配字段值。</p>
<p><strong>语法</strong>: <code>regex_match('pattern')</code></p>
<p><strong>参数</strong>:</p>
<ul>
<li><code>pattern</code>: 字符串，正则表达式模式（必须使用引号）</li>
</ul>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>字段值匹配正则表达式 → 匹配成功</li>
<li>字段值不匹配正则表达式 → 匹配失败</li>
<li>正则表达式语法错误 → 匹配失败并记录警告</li>
<li>字段不是字符串类型 → 匹配失败</li>
</ul>
<p><strong>注意</strong>: 使用标准 Rust regex 语法</p>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">EventPattern = match read(log_message) {
    regex_match('^\[\d{4}-\d{2}-\d{2}') =&gt; chars(timestamped),
    regex_match('^ERROR:.*timeout') =&gt; chars(error_timeout),
    regex_match('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}') =&gt; chars(ip_address),
    _ =&gt; chars(unmatched),
};
</code></pre>
<h4 id="is_empty"><a class="header" href="#is_empty">is_empty()</a></h4>
<p>检查字段值是否为空字符串。</p>
<p><strong>语法</strong>: <code>is_empty()</code></p>
<p><strong>参数</strong>: 无</p>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>字段值为空字符串 → 匹配成功</li>
<li>字段值非空 → 匹配失败</li>
<li>字段不是字符串类型 → 匹配失败</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">Status = match read(field_value) {
    is_empty() =&gt; chars(missing),
    _ =&gt; chars(present),
};
</code></pre>
<h4 id="iequalsvalue"><a class="header" href="#iequalsvalue">iequals(value)</a></h4>
<p>忽略大小写比较字段值。</p>
<p><strong>语法</strong>: <code>iequals('value')</code></p>
<p><strong>参数</strong>:</p>
<ul>
<li><code>value</code>: 字符串，要比较的值（必须使用引号）</li>
</ul>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>字段值与参数值在忽略大小写的情况下相等 → 匹配成功</li>
<li>字段值与参数值不相等 → 匹配失败</li>
<li>字段不是字符串类型 → 匹配失败</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">NormalizedStatus = match read(status) {
    iequals('success') =&gt; chars(ok),
    iequals('error') =&gt; chars(fail),
    iequals('warning') =&gt; chars(warn),
    _ =&gt; chars(unknown),
};
</code></pre>
<h3 id="数值比较函数"><a class="header" href="#数值比较函数">数值比较函数</a></h3>
<h4 id="gtvalue"><a class="header" href="#gtvalue">gt(value)</a></h4>
<p>检查字段值是否大于指定值。</p>
<p><strong>语法</strong>: <code>gt(100)</code> （数值参数不需要引号）</p>
<p><strong>参数</strong>:</p>
<ul>
<li><code>value</code>: 数值，要比较的阈值</li>
</ul>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>字段值 &gt; 参数值 → 匹配成功</li>
<li>字段值 ≤ 参数值 → 匹配失败</li>
<li>字段不是数值类型 → 匹配失败</li>
<li>支持整数 (digit) 和浮点数 (float)</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">Level = match read(count) {
    gt(1000) =&gt; chars(critical),
    gt(500) =&gt; chars(high),
    gt(100) =&gt; chars(medium),
    _ =&gt; chars(low),
};
</code></pre>
<h4 id="ltvalue"><a class="header" href="#ltvalue">lt(value)</a></h4>
<p>检查字段值是否小于指定值。</p>
<p><strong>语法</strong>: <code>lt(60)</code> （数值参数不需要引号）</p>
<p><strong>参数</strong>:</p>
<ul>
<li><code>value</code>: 数值，要比较的阈值</li>
</ul>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>字段值 &lt; 参数值 → 匹配成功</li>
<li>字段值 ≥ 参数值 → 匹配失败</li>
<li>字段不是数值类型 → 匹配失败</li>
<li>支持整数和浮点数</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">Grade = match read(score) {
    lt(60) =&gt; chars(fail),
    lt(70) =&gt; chars(pass),
    lt(85) =&gt; chars(good),
    _ =&gt; chars(excellent),
};
</code></pre>
<h4 id="eqvalue"><a class="header" href="#eqvalue">eq(value)</a></h4>
<p>检查字段值是否等于指定数值。</p>
<p><strong>语法</strong>: <code>eq(5)</code> （数值参数不需要引号）</p>
<p><strong>参数</strong>:</p>
<ul>
<li><code>value</code>: 数值，要比较的目标值</li>
</ul>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>字段值等于参数值 → 匹配成功（浮点数比较容差 1e-10）</li>
<li>字段值不等于参数值 → 匹配失败</li>
<li>字段不是数值类型 → 匹配失败</li>
<li>支持整数和浮点数</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">Status = match read(level) {
    eq(0) =&gt; chars(disabled),
    eq(5) =&gt; chars(max_level),
    eq(1) =&gt; chars(minimum),
    _ =&gt; chars(normal),
};
</code></pre>
<h4 id="in_rangemin-max"><a class="header" href="#in_rangemin-max">in_range(min, max)</a></h4>
<p>检查字段值是否在指定范围内。</p>
<p><strong>语法</strong>: <code>in_range(20, 30)</code> （数值参数不需要引号）</p>
<p><strong>参数</strong>:</p>
<ul>
<li><code>min</code>: 数值，范围最小值</li>
<li><code>max</code>: 数值，范围最大值</li>
</ul>
<p><strong>匹配规则</strong>:</p>
<ul>
<li>min ≤ 字段值 ≤ max → 匹配成功</li>
<li>字段值 &lt; min 或 字段值 &gt; max → 匹配失败</li>
<li>字段不是数值类型 → 匹配失败</li>
<li>支持整数和浮点数</li>
<li>区间为闭区间 [min, max]</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-oml">TempZone = match read(temperature) {
    lt(0) =&gt; chars(freezing),
    in_range(0, 10) =&gt; chars(cold),
    in_range(10, 20) =&gt; chars(cool),
    in_range(20, 30) =&gt; chars(comfortable),
    gt(30) =&gt; chars(warm),
    _ =&gt; chars(unknown),
};
</code></pre>
<h2 id="使用示例-5"><a class="header" href="#使用示例-5">使用示例</a></h2>
<h3 id="示例-1-日志级别分类"><a class="header" href="#示例-1-日志级别分类">示例 1: 日志级别分类</a></h3>
<pre><code class="language-oml">name : classify_log_event
---
EventType = match read(Content) {
    starts_with('[ERROR]') =&gt; chars(error),
    starts_with('[WARN]') =&gt; chars(warning),
    starts_with('[INFO]') =&gt; chars(info),
    _ =&gt; chars(debug),
};
</code></pre>
<h3 id="示例-2-文件类型识别"><a class="header" href="#示例-2-文件类型识别">示例 2: 文件类型识别</a></h3>
<pre><code class="language-oml">name : file_type_detection
---
FileType = match read(filename) {
    ends_with('.json') =&gt; chars(json),
    ends_with('.xml') =&gt; chars(xml),
    ends_with('.log') =&gt; chars(log),
    ends_with('.txt') =&gt; chars(text),
    _ =&gt; chars(unknown),
};
</code></pre>
<h3 id="示例-3-错误类型检测"><a class="header" href="#示例-3-错误类型检测">示例 3: 错误类型检测</a></h3>
<pre><code class="language-oml">name : error_type_detection
---
ErrorType = match read(message) {
    contains('exception') =&gt; chars(exception),
    contains('timeout') =&gt; chars(timeout),
    contains('failed') =&gt; chars(failure),
    _ =&gt; chars(normal),
};
</code></pre>
<h3 id="示例-4-分数等级映射"><a class="header" href="#示例-4-分数等级映射">示例 4: 分数等级映射</a></h3>
<pre><code class="language-oml">name : score_grade_mapping
---
Grade = match read(score) {
    gt(90) =&gt; chars(A),
    in_range(80, 90) =&gt; chars(B),
    in_range(70, 80) =&gt; chars(C),
    in_range(60, 70) =&gt; chars(D),
    _ =&gt; chars(F),
};
</code></pre>
<h3 id="示例-5-温度区间分类"><a class="header" href="#示例-5-温度区间分类">示例 5: 温度区间分类</a></h3>
<pre><code class="language-oml">name : temperature_classification
---
TempZone = match read(temperature) {
    lt(0) =&gt; chars(freezing),
    in_range(0, 10) =&gt; chars(cold),
    in_range(10, 20) =&gt; chars(cool),
    in_range(20, 30) =&gt; chars(comfortable),
    in_range(30, 40) =&gt; chars(warm),
    gt(40) =&gt; chars(hot),
    _ =&gt; chars(unknown),
};
</code></pre>
<h3 id="示例-6-混合使用多种函数"><a class="header" href="#示例-6-混合使用多种函数">示例 6: 混合使用多种函数</a></h3>
<pre><code class="language-oml">name : log_classification
---
EventType = match read(log_line) {
    starts_with('[ERROR]') =&gt; chars(error),
    starts_with('[WARN]') =&gt; chars(warning),
    contains('exception') =&gt; chars(exception),
    ends_with('failed') =&gt; chars(failure),
    is_empty() =&gt; chars(empty),
    _ =&gt; chars(other),
};
</code></pre>
<h3 id="示例-7-正则表达式匹配"><a class="header" href="#示例-7-正则表达式匹配">示例 7: 正则表达式匹配</a></h3>
<pre><code class="language-oml">name : regex_pattern_match
---
EventPattern = match read(log_message) {
    regex_match('^\[\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\]') =&gt; chars(timestamped),
    regex_match('^ERROR:.*timeout') =&gt; chars(error_timeout),
    regex_match('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}') =&gt; chars(ip_address),
    _ =&gt; chars(unmatched),
};
</code></pre>
<h3 id="示例-8-大小写不敏感状态匹配"><a class="header" href="#示例-8-大小写不敏感状态匹配">示例 8: 大小写不敏感状态匹配</a></h3>
<pre><code class="language-oml">name : case_insensitive_status
---
NormalizedStatus = match read(status) {
    iequals('success') =&gt; chars(ok),
    iequals('error') =&gt; chars(fail),
    iequals('warning') =&gt; chars(warn),
    iequals('pending') =&gt; chars(wait),
    _ =&gt; chars(unknown),
};
</code></pre>
<h2 id="注意事项-2"><a class="header" href="#注意事项-2">注意事项</a></h2>
<h3 id="1-参数引号规则"><a class="header" href="#1-参数引号规则">1. 参数引号规则</a></h3>
<pre><code class="language-oml"># ✅ 字符串参数必须加引号
starts_with('prefix')
iequals('value')

# ✅ 数值参数不需要引号
gt(100)
eq(5)
in_range(20, 30)

# ❌ 错误示例
starts_with(prefix)   # 缺少引号
gt('100')             # 不应该加引号
</code></pre>
<h3 id="2-大小写敏感性"><a class="header" href="#2-大小写敏感性">2. 大小写敏感性</a></h3>
<pre><code class="language-oml"># 大多数字符串函数都是大小写敏感的
starts_with('ERROR')  # 不会匹配 'error:'

# 使用 iequals 进行大小写不敏感匹配
iequals('success')    # 匹配 'SUCCESS', 'Success', 'success'
</code></pre>
<h3 id="3-匹配顺序"><a class="header" href="#3-匹配顺序">3. 匹配顺序</a></h3>
<pre><code class="language-oml"># match 按从上到下的顺序匹配，第一个匹配成功的分支会被执行
Grade = match read(score) {
    gt(90) =&gt; chars(A),        # 先检查 &gt; 90
    gt(80) =&gt; chars(B),        # 再检查 &gt; 80
    gt(70) =&gt; chars(C),        # 然后检查 &gt; 70
    _ =&gt; chars(F),
};

# 如果 score = 95，只会匹配到第一个分支 (A)
</code></pre>
<h3 id="4-数值类型支持"><a class="header" href="#4-数值类型支持">4. 数值类型支持</a></h3>
<pre><code class="language-oml"># 支持多种数值类型
- digit(100)     # 整数
- float(3.14)    # 浮点数
- chars("123")   # 可解析的字符串

# 所有这些都可以用于数值比较函数
count = digit(150);
Level = match read(count) {
    gt(100) =&gt; chars(high),  # 匹配成功
    _ =&gt; chars(low),
};
</code></pre>
<h3 id="5-范围区间"><a class="header" href="#5-范围区间">5. 范围区间</a></h3>
<pre><code class="language-oml"># in_range 使用闭区间 [min, max]
in_range(10, 20)   # 包含 10 和 20

# 示例：score = 20 会匹配成功
Grade = match read(score) {
    in_range(10, 20) =&gt; chars(pass),  # 匹配！
    _ =&gt; chars(fail),
};
</code></pre>
<h2 id="性能参考-2"><a class="header" href="#性能参考-2">性能参考</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数类型</th><th>典型性能</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>前缀/后缀匹配</td><td>&lt; 1μs</td><td>简单字符串比较</td></tr>
<tr><td>子串匹配</td><td>1-5μs</td><td>取决于字符串长度</td></tr>
<tr><td>正则表达式</td><td>5-50μs</td><td>取决于模式复杂度</td></tr>
<tr><td>数值比较</td><td>&lt; 100ns</td><td>直接数值比较</td></tr>
<tr><td>大小写转换</td><td>1-2μs</td><td>需要字符串复制</td></tr>
</tbody>
</table>
</div>
<h2 id="函数对比-2"><a class="header" href="#函数对比-2">函数对比</a></h2>
<h3 id="match-函数-vs-pipe-函数"><a class="header" href="#match-函数-vs-pipe-函数">Match 函数 vs Pipe 函数</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>Match starts_with</th><th>Pipe starts_with</th></tr>
</thead>
<tbody>
<tr><td><strong>返回值</strong></td><td>根据条件返回不同值</td><td>匹配返回原值，不匹配返回 ignore</td></tr>
<tr><td><strong>分支数</strong></td><td>支持多个分支</td><td>仅二元（匹配/不匹配）</td></tr>
<tr><td><strong>用途</strong></td><td>分类、决策树</td><td>过滤、数据清洗</td></tr>
<tr><td><strong>代码长度</strong></td><td>多条件时更简洁</td><td>简单过滤时更简洁</td></tr>
</tbody>
</table>
</div>
<p><strong>示例对比</strong>:</p>
<pre><code class="language-oml"># Match: 多分支分类
EventType = match read(log) {
    starts_with('[ERROR]') =&gt; chars(error),
    starts_with('[WARN]') =&gt; chars(warning),
    starts_with('[INFO]') =&gt; chars(info),
    _ =&gt; chars(debug),
};

# Pipe: 简单过滤
ErrorLog = pipe take(log) | starts_with('[ERROR]');
# 不匹配的变成 ignore，匹配的保留原值
</code></pre>
<h3 id="数值函数对比"><a class="header" href="#数值函数对比">数值函数对比</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>场景</th><th>推荐函数</th><th>示例</th></tr>
</thead>
<tbody>
<tr><td>阈值判断</td><td><code>gt</code> / <code>lt</code></td><td><code>gt(100)</code></td></tr>
<tr><td>精确匹配</td><td><code>eq</code></td><td><code>eq(5)</code></td></tr>
<tr><td>区间判断</td><td><code>in_range</code></td><td><code>in_range(10, 20)</code></td></tr>
<tr><td>分段分类</td><td>组合使用</td><td>见温度分类示例</td></tr>
</tbody>
</table>
</div>
<h2 id="最佳实践-10"><a class="header" href="#最佳实践-10">最佳实践</a></h2>
<h3 id="1-优先使用简单函数"><a class="header" href="#1-优先使用简单函数">1. 优先使用简单函数</a></h3>
<pre><code class="language-oml"># ✅ 推荐：使用简单的 starts_with
match read(url) {
    starts_with('https://') =&gt; chars(secure),
    _ =&gt; chars(insecure),
}

# ⚠️ 避免：不必要的正则表达式
match read(url) {
    regex_match('^https://') =&gt; chars(secure),  # 性能更差
    _ =&gt; chars(insecure),
}
</code></pre>
<h3 id="2-合理组织匹配顺序"><a class="header" href="#2-合理组织匹配顺序">2. 合理组织匹配顺序</a></h3>
<pre><code class="language-oml"># ✅ 推荐：从具体到一般
match read(log) {
    starts_with('[ERROR]') =&gt; chars(error),     # 最具体
    starts_with('[WARN]') =&gt; chars(warning),
    contains('exception') =&gt; chars(exception),   # 较宽泛
    _ =&gt; chars(other),                          # 默认
}
</code></pre>
<h3 id="3-利用数值范围"><a class="header" href="#3-利用数值范围">3. 利用数值范围</a></h3>
<pre><code class="language-oml"># ✅ 推荐：使用 in_range 简化多个条件
Grade = match read(score) {
    gt(90) =&gt; chars(A),
    in_range(80, 90) =&gt; chars(B),
    in_range(70, 80) =&gt; chars(C),
    _ =&gt; chars(D),
};

# ⚠️ 避免：重复的比较
Grade = match read(score) {
    gt(90) =&gt; chars(A),
    gt(80) =&gt; chars(B),  # 实际上是 80-90
    gt(70) =&gt; chars(C),  # 实际上是 70-80
    _ =&gt; chars(D),
};
</code></pre>
<h3 id="4-使用-iequals-处理用户输入"><a class="header" href="#4-使用-iequals-处理用户输入">4. 使用 iequals 处理用户输入</a></h3>
<pre><code class="language-oml"># ✅ 推荐：使用 iequals 处理大小写不确定的输入
Status = match read(user_input) {
    iequals('yes') =&gt; chars(confirmed),
    iequals('no') =&gt; chars(rejected),
    _ =&gt; chars(invalid),
};
</code></pre>
<h2 id="与传统匹配的对比"><a class="header" href="#与传统匹配的对比">与传统匹配的对比</a></h2>
<h3 id="传统值匹配"><a class="header" href="#传统值匹配">传统值匹配</a></h3>
<pre><code class="language-oml">Status = match read(status_code) {
    digit(200) =&gt; chars(success),
    digit(404) =&gt; chars(not_found),
    digit(500) =&gt; chars(error),
    _ =&gt; chars(unknown),
};
</code></pre>
<p><strong>特点</strong>: 精确匹配固定值</p>
<h3 id="函数匹配"><a class="header" href="#函数匹配">函数匹配</a></h3>
<pre><code class="language-oml">EventType = match read(log_line) {
    starts_with('ERROR:') =&gt; chars(error),
    starts_with('WARN:') =&gt; chars(warning),
    starts_with('INFO:') =&gt; chars(info),
    _ =&gt; chars(debug),
};
</code></pre>
<p><strong>特点</strong>: 基于模式或条件匹配</p>
<h2 id="相关文档-7"><a class="header" href="#相关文档-7">相关文档</a></h2>
<ul>
<li><a href="#oml-pipe-functions-函数索引">OML Pipe Functions 索引</a> - Pipe 函数完整列表</li>
<li><a href="#starts_with-函数使用指南-1">starts_with Pipe 函数</a> - Pipe 版本的 starts_with 详细说明</li>
<li><a href="#map_to-函数使用指南">map_to 函数</a> - 值映射函数</li>
<li><a href="10-user/04-oml/README.html">OML 语法参考</a> - OML 基础语法</li>
</ul>
<h2 id="版本历史-8"><a class="header" href="#版本历史-8">版本历史</a></h2>
<ul>
<li><strong>1.13.4</strong> (2026-02-04)
<ul>
<li>新增 match 表达式函数匹配支持</li>
<li>字符串匹配：<code>starts_with</code>, <code>ends_with</code>, <code>contains</code>, <code>regex_match</code>, <code>is_empty</code>, <code>iequals</code></li>
<li>数值比较：<code>gt</code>, <code>lt</code>, <code>eq</code>, <code>in_range</code></li>
<li>完善函数文档</li>
</ul>
</li>
</ul>
<hr>
<p><strong>提示</strong>: Match 函数用于多分支条件判断，Pipe 函数用于二元过滤。根据实际场景选择合适的函数类型可以让代码更简洁清晰。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="starts_with-函数使用指南-1"><a class="header" href="#starts_with-函数使用指南-1">starts_with 函数使用指南</a></h1>
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<p><code>starts_with</code> 是一个 OML pipe 函数，用于检查字符串字段是否以指定的前缀开始。</p>
<h2 id="语法-1"><a class="header" href="#语法-1">语法</a></h2>
<pre><code class="language-oml">field_name = pipe take(source_field) | starts_with('prefix');
</code></pre>
<h2 id="参数-1"><a class="header" href="#参数-1">参数</a></h2>
<ul>
<li><code>prefix</code>: 字符串类型，要检查的前缀（需使用引号）</li>
</ul>
<h2 id="行为-1"><a class="header" href="#行为-1">行为</a></h2>
<ul>
<li>如果字段值以指定前缀开始，字段保持不变并继续传递</li>
<li>如果字段值不以指定前缀开始，字段转换为 <strong>ignore 类型</strong></li>
<li>如果字段不是字符串类型，字段转换为 <strong>ignore 类型</strong></li>
<li>前缀匹配是大小写敏感的</li>
</ul>
<h2 id="使用场景-2"><a class="header" href="#使用场景-2">使用场景</a></h2>
<h3 id="场景-1-过滤-https-url"><a class="header" href="#场景-1-过滤-https-url">场景 1: 过滤 HTTPS URL</a></h3>
<pre><code class="language-oml">name : filter_secure_urls
---
secure_url = pipe take(url) | starts_with('https://');
</code></pre>
<p><strong>输入:</strong> <code>url = "https://example.com"</code>
<strong>输出:</strong> <code>secure_url = "https://example.com"</code> (Chars类型)</p>
<p><strong>输入:</strong> <code>url = "http://example.com"</code>
<strong>输出:</strong> <code>secure_url = (ignore)</code></p>
<h3 id="场景-2-提取-api-路径"><a class="header" href="#场景-2-提取-api-路径">场景 2: 提取 API 路径</a></h3>
<pre><code class="language-oml">name : extract_api_path
---
api_path = pipe take(request_path) | starts_with('/api/v1/');
</code></pre>
<p><strong>输入:</strong> <code>request_path = "/api/v1/users"</code>
<strong>输出:</strong> <code>api_path = "/api/v1/users"</code> (Chars类型)</p>
<p><strong>输入:</strong> <code>request_path = "/admin/users"</code>
<strong>输出:</strong> <code>api_path = (ignore)</code></p>
<h3 id="场景-3-分类日志级别"><a class="header" href="#场景-3-分类日志级别">场景 3: 分类日志级别</a></h3>
<pre><code class="language-oml">name : classify_error_logs
---
error_message = pipe take(log_message) | starts_with('ERROR');
warning_message = pipe take(log_message) | starts_with('WARN');
</code></pre>
<p><strong>输入:</strong> <code>log_message = "ERROR: Connection failed"</code>
<strong>输出:</strong></p>
<ul>
<li><code>error_message = "ERROR: Connection failed"</code> (Chars类型)</li>
<li><code>warning_message = (ignore)</code></li>
</ul>
<h3 id="场景-4-与-map_to-组合使用"><a class="header" href="#场景-4-与-map_to-组合使用">场景 4: 与 map_to 组合使用</a></h3>
<pre><code class="language-oml">name : classify_secure_requests
---
# 如果是 HTTPS，标记为安全
is_secure = pipe take(url) | starts_with('https://') | map_to(true);

# 如果是 HTTPS，设置安全级别
security_level = pipe take(url) | starts_with('https://') | map_to(3);
</code></pre>
<p><strong>输入:</strong> <code>url = "https://api.example.com"</code>
<strong>输出:</strong></p>
<ul>
<li><code>is_secure = true</code> (Bool类型)</li>
<li><code>security_level = 3</code> (Digit类型)</li>
</ul>
<p><strong>输入:</strong> <code>url = "http://api.example.com"</code>
<strong>输出:</strong></p>
<ul>
<li><code>is_secure = (ignore)</code></li>
<li><code>security_level = (ignore)</code></li>
</ul>
<h3 id="场景-5-多条件过滤"><a class="header" href="#场景-5-多条件过滤">场景 5: 多条件过滤</a></h3>
<pre><code class="language-oml">name : extract_specific_prefix
---
# 提取特定前缀的字段
https_url = pipe take(url) | starts_with('https://');
ftp_url = pipe take(url) | starts_with('ftp://');
websocket_url = pipe take(url) | starts_with('wss://');
</code></pre>
<p>根据不同的协议前缀，将 URL 分类到不同的字段中。</p>
<h3 id="场景-6-路径规范化"><a class="header" href="#场景-6-路径规范化">场景 6: 路径规范化</a></h3>
<pre><code class="language-oml">name : normalize_paths
---
# 只接受绝对路径
absolute_path = pipe take(file_path) | starts_with('/');

# 只接受相对路径
relative_path = pipe take(file_path) | starts_with('./');
</code></pre>
<h2 id="与其他函数的对比"><a class="header" href="#与其他函数的对比">与其他函数的对比</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>检查位置</th><th>性能</th><th>用途</th></tr>
</thead>
<tbody>
<tr><td><code>starts_with(prefix)</code></td><td>字符串开头</td><td>极快</td><td>前缀匹配</td></tr>
<tr><td><code>regex_match(pattern)</code></td><td>任意位置</td><td>较慢</td><td>复杂模式匹配</td></tr>
<tr><td><code>to_str</code></td><td>-</td><td>快</td><td>类型转换</td></tr>
</tbody>
</table>
</div>
<h2 id="常见用例"><a class="header" href="#常见用例">常见用例</a></h2>
<h3 id="1-url-协议过滤"><a class="header" href="#1-url-协议过滤">1. URL 协议过滤</a></h3>
<pre><code class="language-oml">name : url_protocol_filter
---
https_only = pipe take(url) | starts_with('https://');
</code></pre>
<h3 id="2-路径前缀提取"><a class="header" href="#2-路径前缀提取">2. 路径前缀提取</a></h3>
<pre><code class="language-oml">name : api_path_extract
---
v1_api = pipe take(path) | starts_with('/api/v1/');
v2_api = pipe take(path) | starts_with('/api/v2/');
</code></pre>
<h3 id="3-日志级别分类"><a class="header" href="#3-日志级别分类">3. 日志级别分类</a></h3>
<pre><code class="language-oml">name : log_level_classify
---
errors = pipe take(message) | starts_with('[ERROR]');
warnings = pipe take(message) | starts_with('[WARN]');
info = pipe take(message) | starts_with('[INFO]');
</code></pre>
<h3 id="4-文件扩展名检查配合其他字段"><a class="header" href="#4-文件扩展名检查配合其他字段">4. 文件扩展名检查（配合其他字段）</a></h3>
<pre><code class="language-oml">name : file_type_check
---
# 注意：这个示例假设 filename 已经被规范化
json_file = pipe take(filename) | starts_with('data_') | map_to('json');
</code></pre>
<h2 id="实现细节-1"><a class="header" href="#实现细节-1">实现细节</a></h2>
<ul>
<li>定义位置: <code>crates/wp-oml/src/language/syntax/functions/pipe/other.rs</code></li>
<li>实现位置: <code>crates/wp-oml/src/core/evaluator/transform/pipe/other.rs</code></li>
<li>解析器: <code>crates/wp-oml/src/parser/pipe_prm.rs</code></li>
<li>测试: <code>crates/wp-oml/src/core/evaluator/transform/pipe/other.rs</code> (tests 模块)</li>
</ul>
<h2 id="注意事项-3"><a class="header" href="#注意事项-3">注意事项</a></h2>
<ol>
<li><strong>字符串必须加引号</strong>: <code>starts_with('https://')</code> 而非 <code>starts_with(https://)</code></li>
<li><strong>大小写敏感</strong>: <code>starts_with('HTTP')</code> 不会匹配 <code>http://example.com</code></li>
<li><strong>ignore 字段传播</strong>: 转换为 ignore 的字段在后续管道函数中会保持 ignore 状态</li>
<li><strong>与 map_to 配合</strong>: 常见模式是先用 <code>starts_with</code> 过滤，再用 <code>map_to</code> 赋值</li>
</ol>
<h2 id="性能特性"><a class="header" href="#性能特性">性能特性</a></h2>
<ul>
<li><strong>O(n) 时间复杂度</strong>: n 为前缀长度</li>
<li><strong>零拷贝</strong>: 不修改原始字符串</li>
<li><strong>短路优化</strong>: 发现不匹配立即返回</li>
</ul>
<h2 id="相关函数-1"><a class="header" href="#相关函数-1">相关函数</a></h2>
<ul>
<li><code>map_to(value)</code>: 条件赋值，支持多种类型</li>
<li><code>skip_empty</code>: 跳过空值</li>
<li><code>to_str</code>: 转换为字符串</li>
<li><code>get(name)</code>: 从嵌套结构获取字段</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="map_to-函数使用指南"><a class="header" href="#map_to-函数使用指南">map_to 函数使用指南</a></h1>
<h2 id="简介-2"><a class="header" href="#简介-2">简介</a></h2>
<p><code>map_to</code> 是一个 OML pipe 函数，用于在字段存在（非 ignore）时将字段值映射到指定的值。支持多种类型：字符串、整数、浮点数、布尔值。</p>
<h2 id="语法-2"><a class="header" href="#语法-2">语法</a></h2>
<pre><code class="language-oml">field_name = pipe take(source_field) | map_to(value);
</code></pre>
<h2 id="参数-2"><a class="header" href="#参数-2">参数</a></h2>
<p><code>map_to</code> 支持多种类型的参数，解析器会自动推断类型:</p>
<ul>
<li><strong>字符串</strong>: 使用引号包围，如 <code>'text'</code> 或 <code>"text"</code></li>
<li><strong>整数</strong>: 直接写数字，如 <code>123</code> 或 <code>-456</code></li>
<li><strong>浮点数</strong>: 带小数点的数字，如 <code>3.14</code> 或 <code>-2.5</code></li>
<li><strong>布尔值</strong>: <code>true</code> 或 <code>false</code></li>
</ul>
<h2 id="行为-2"><a class="header" href="#行为-2">行为</a></h2>
<ul>
<li>如果字段为<strong>非 ignore</strong> 类型，使用参数值替换字段值（并转换为相应类型）</li>
<li>如果字段为 <strong>ignore</strong> 类型，保持不变</li>
<li>自动进行类型转换</li>
</ul>
<h2 id="类型推断规则"><a class="header" href="#类型推断规则">类型推断规则</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>输入</th><th>推断类型</th><th>结果字段类型</th></tr>
</thead>
<tbody>
<tr><td><code>'text'</code> 或 <code>"text"</code></td><td>字符串</td><td>Chars</td></tr>
<tr><td><code>123</code></td><td>整数</td><td>Digit</td></tr>
<tr><td><code>3.14</code></td><td>浮点数</td><td>Float</td></tr>
<tr><td><code>true</code> / <code>false</code></td><td>布尔值</td><td>Bool</td></tr>
</tbody>
</table>
</div>
<h2 id="使用场景-3"><a class="header" href="#使用场景-3">使用场景</a></h2>
<h3 id="场景-1-映射到字符串标记"><a class="header" href="#场景-1-映射到字符串标记">场景 1: 映射到字符串标记</a></h3>
<pre><code class="language-oml">name : classify_status
---
status_label = pipe take(http_code) | map_to('success');
</code></pre>
<p><strong>输入:</strong> <code>http_code = 200</code>
<strong>输出:</strong> <code>status_label = "success"</code> (Chars类型)</p>
<h3 id="场景-2-映射到整数优先级"><a class="header" href="#场景-2-映射到整数优先级">场景 2: 映射到整数优先级</a></h3>
<pre><code class="language-oml">name : set_priority
---
priority = pipe take(log_level) | map_to(1);
</code></pre>
<p><strong>输入:</strong> <code>log_level = "ERROR"</code>
<strong>输出:</strong> <code>priority = 1</code> (Digit类型)</p>
<h3 id="场景-3-映射到浮点数阈值"><a class="header" href="#场景-3-映射到浮点数阈值">场景 3: 映射到浮点数阈值</a></h3>
<pre><code class="language-oml">name : set_threshold
---
threshold = pipe take(category) | map_to(0.95);
</code></pre>
<p><strong>输入:</strong> <code>category = "high"</code>
<strong>输出:</strong> <code>threshold = 0.95</code> (Float类型)</p>
<h3 id="场景-4-映射到布尔标记"><a class="header" href="#场景-4-映射到布尔标记">场景 4: 映射到布尔标记</a></h3>
<pre><code class="language-oml">name : mark_secure
---
is_secure = pipe take(protocol) | map_to(true);
</code></pre>
<p><strong>输入:</strong> <code>protocol = "https"</code>
<strong>输出:</strong> <code>is_secure = true</code> (Bool类型)</p>
<h3 id="场景-5-与过滤函数组合"><a class="header" href="#场景-5-与过滤函数组合">场景 5: 与过滤函数组合</a></h3>
<pre><code class="language-oml">name : classify_secure_requests
---
security_level = pipe take(url) | starts_with('https://') | map_to(3);
</code></pre>
<p><strong>输入:</strong> <code>url = "https://api.example.com"</code>
<strong>输出:</strong> <code>security_level = 3</code> (Digit类型)</p>
<p><strong>输入:</strong> <code>url = "http://api.example.com"</code>
<strong>输出:</strong> <code>security_level = (ignore)</code> (因为 starts_with 失败)</p>
<h3 id="场景-6-多级分类"><a class="header" href="#场景-6-多级分类">场景 6: 多级分类</a></h3>
<pre><code class="language-oml">name : multi_level_classification
---
# 检查 URL 是否为 HTTPS，如果是则设置安全级别为高优先级
priority = pipe take(url)
    | starts_with('https://')
    | map_to(10);

# 标记为已验证
verified = pipe take(url)
    | starts_with('https://')
    | map_to(true);
</code></pre>
<h3 id="场景-7-协议分类"><a class="header" href="#场景-7-协议分类">场景 7: 协议分类</a></h3>
<pre><code class="language-oml">name : protocol_classification
---
# HTTP 标记为 1
http_level = pipe take(protocol) | starts_with('http://') | map_to(1);

# HTTPS 标记为 3
https_level = pipe take(protocol) | starts_with('https://') | map_to(3);

# FTP 标记为 2
ftp_level = pipe take(protocol) | starts_with('ftp://') | map_to(2);
</code></pre>
<h3 id="场景-8-状态码分类"><a class="header" href="#场景-8-状态码分类">场景 8: 状态码分类</a></h3>
<pre><code class="language-oml">name : status_code_classification
---
# 2xx 成功
success_flag = pipe take(status_code) | digit_range(200, 299) | map_to('success');

# 4xx 客户端错误
client_error_flag = pipe take(status_code) | digit_range(400, 499) | map_to('client_error');

# 5xx 服务器错误
server_error_flag = pipe take(status_code) | digit_range(500, 599) | map_to('server_error');
</code></pre>
<h2 id="与其他函数的对比-1"><a class="header" href="#与其他函数的对比-1">与其他函数的对比</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>函数</th><th>支持类型</th><th>用途</th><th>条件保留</th></tr>
</thead>
<tbody>
<tr><td><code>map_to(value)</code></td><td>字符串、整数、浮点数、布尔值</td><td>通用映射，自动类型推断</td><td>保留 ignore</td></tr>
<tr><td><code>to_str</code></td><td>-</td><td>类型转换为字符串</td><td>不保留</td></tr>
<tr><td><code>to_json</code></td><td>-</td><td>转换为 JSON 字符串</td><td>不保留</td></tr>
</tbody>
</table>
</div>
<h2 id="典型使用模式"><a class="header" href="#典型使用模式">典型使用模式</a></h2>
<h3 id="1-条件标记模式"><a class="header" href="#1-条件标记模式">1. 条件标记模式</a></h3>
<pre><code class="language-oml">name : conditional_marking
---
# 如果某个条件满足，标记为 true
is_valid = pipe take(field) | some_condition() | map_to(true);
</code></pre>
<h3 id="2-分类映射模式"><a class="header" href="#2-分类映射模式">2. 分类映射模式</a></h3>
<pre><code class="language-oml">name : classification_mapping
---
# 根据不同条件映射到不同的分类
category_a = pipe take(value) | condition_a() | map_to('A');
category_b = pipe take(value) | condition_b() | map_to('B');
</code></pre>
<h3 id="3-优先级赋值模式"><a class="header" href="#3-优先级赋值模式">3. 优先级赋值模式</a></h3>
<pre><code class="language-oml">name : priority_assignment
---
# 根据条件赋予不同优先级
high_priority = pipe take(level) | check_high() | map_to(10);
medium_priority = pipe take(level) | check_medium() | map_to(5);
low_priority = pipe take(level) | check_low() | map_to(1);
</code></pre>
<h2 id="实现细节-2"><a class="header" href="#实现细节-2">实现细节</a></h2>
<ul>
<li>定义位置: <code>crates/wp-oml/src/language/syntax/functions/pipe/other.rs</code></li>
<li>实现位置: <code>crates/wp-oml/src/core/evaluator/transform/pipe/other.rs</code></li>
<li>解析器: <code>crates/wp-oml/src/parser/pipe_prm.rs</code></li>
<li>测试: <code>crates/wp-oml/src/core/evaluator/transform/pipe/other.rs</code> (tests 模块)</li>
</ul>
<h2 id="类型推断实现"><a class="header" href="#类型推断实现">类型推断实现</a></h2>
<p>解析器按以下顺序尝试解析参数:</p>
<ol>
<li><strong>布尔值</strong>: <code>true</code> 或 <code>false</code></li>
<li><strong>数字</strong>:
<ul>
<li>如果是整数形式（无小数部分），推断为 <code>Digit</code></li>
<li>如果有小数部分，推断为 <code>Float</code></li>
</ul>
</li>
<li><strong>字符串</strong>: 单引号或双引号包围的文本</li>
</ol>
<h2 id="注意事项-4"><a class="header" href="#注意事项-4">注意事项</a></h2>
<ol>
<li><strong>字符串必须加引号</strong>: <code>map_to(text)</code> 会报错，应使用 <code>map_to('text')</code></li>
<li><strong>整数自动识别</strong>: <code>map_to(100)</code> 自动识别为整数，<code>map_to(100.0)</code> 识别为浮点数</li>
<li><strong>布尔值不加引号</strong>: <code>map_to(true)</code> 而非 <code>map_to('true')</code></li>
<li><strong>ignore 字段保持不变</strong>: 如果输入字段是 ignore，输出也是 ignore</li>
<li><strong>类型转换</strong>: 无论输入字段的原始类型，输出字段类型由参数决定</li>
</ol>
<h2 id="性能特性-1"><a class="header" href="#性能特性-1">性能特性</a></h2>
<ul>
<li><strong>O(1) 时间复杂度</strong>: 简单的值替换操作</li>
<li><strong>类型安全</strong>: 编译时类型检查确保类型正确</li>
<li><strong>零开销</strong>: 直接值替换，无额外分配</li>
</ul>
<h2 id="调试技巧-4"><a class="header" href="#调试技巧-4">调试技巧</a></h2>
<h3 id="1-验证类型推断"><a class="header" href="#1-验证类型推断">1. 验证类型推断</a></h3>
<pre><code class="language-oml">name : debug_type_inference
---
# 测试不同类型
str_field = pipe take(input) | map_to('string');    # Chars
int_field = pipe take(input) | map_to(123);         # Digit
float_field = pipe take(input) | map_to(3.14);      # Float
bool_field = pipe take(input) | map_to(true);       # Bool
</code></pre>
<h3 id="2-检查-ignore-传播"><a class="header" href="#2-检查-ignore-传播">2. 检查 ignore 传播</a></h3>
<pre><code class="language-oml">name : debug_ignore_propagation
---
# 如果 starts_with 失败，result 应该是 ignore
result = pipe take(url) | starts_with('https://') | map_to('secure');
</code></pre>
<h2 id="相关函数-2"><a class="header" href="#相关函数-2">相关函数</a></h2>
<ul>
<li><code>starts_with(prefix)</code>: 检查字符串前缀，失败时返回 ignore</li>
<li><code>skip_empty</code>: 跳过空值</li>
<li><code>to_str</code>: 转换为字符串</li>
<li><code>to_json</code>: 转换为 JSON 字符串</li>
<li><code>get(name)</code>: 从嵌套结构获取字段</li>
<li><code>nth(index)</code>: 从数组获取指定索引的元素</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="static-块模型级常量与模板缓存"><a class="header" href="#static-块模型级常量与模板缓存"><code>static</code> 块：模型级常量与模板缓存</a></h1>
<p>OML 允许在 <code>---</code> 分隔线之后声明 <code>static { ... }</code> 区块，将“只初始化一次、在运行时复用”的结构写在这里。解析完成后，<code>static</code> 中的表达式会被执行一次，结果进入模型常量池；随后的所有数据转换都直接引用缓存对象，无需再生成临时字段。</p>
<h2 id="适用场景-1"><a class="header" href="#适用场景-1">适用场景</a></h2>
<ul>
<li>事件模板、常量字典等纯字面量对象</li>
<li>需要在多个转换步骤中复用的结构（例如 <code>match</code> 结果）</li>
</ul>
<h2 id="语法示例"><a class="header" href="#语法示例">语法示例</a></h2>
<pre><code class="language-oml">name : /oml/apache_error_e1
rule : apache/error/e1
---
static {
    e1_template = object {
        id = chars(E1);
        tpl = chars("jk2_init() Found child &lt;*&gt; in scoreboard slot &lt;*&gt;")
    };
    e2_template = object {
        id = chars(E2);
        tpl = chars("workerEnv.init() ok &lt;*&gt;")
    };
}

Content = read(Content);

target_template = match Content {
    starts_with("jk2_init() Found child") =&gt; e1_template;
    starts_with("workerEnv.init() ok") =&gt; e2_template;
    _ =&gt; e1_template;
};

EventId = target_template | get(id);
EventTemplate = target_template | get(tpl);
</code></pre>
<ul>
<li><code>static { ... }</code> 中的赋值可使用任意合法表达式，但不得调用 <code>read()</code>/<code>take()</code> 等依赖输入数据的函数。</li>
<li>非 <code>static</code> 区块中直接写静态符号名即可引用缓存值，无需 <code>read()</code>。</li>
</ul>
<h2 id="执行模型"><a class="header" href="#执行模型">执行模型</a></h2>
<ol>
<li><strong>解析阶段</strong>：
<ul>
<li>仅检查 <code>static</code> 语句和目标名称是否重复。</li>
<li>生成 <code>EvalExp</code> AST 并登记符号名。</li>
</ul>
</li>
<li><strong>构建阶段</strong>：
<ul>
<li><code>finalize_static_blocks</code> 统一执行所有静态表达式，构建常量池 <code>const_fields</code>。</li>
<li>将 DSL 中的 <code>StaticSymbol</code> 占位符（如 match 结果、管道参数）重写为真实 <code>DataField</code>。</li>
</ul>
</li>
<li><strong>运行阶段</strong>：
<ul>
<li>静态值来自常量池，不会再次执行 evaluator。</li>
</ul>
</li>
</ol>
<h2 id="使用建议"><a class="header" href="#使用建议">使用建议</a></h2>
<ul>
<li><strong>匹配/管道</strong>：<code>static</code> 变量可出现在 <code>match ... =&gt; symbol</code>、<code>read(symbol)</code>、管道起点等位置，解析器会自动识别。</li>
</ul>
<h2 id="限制-1"><a class="header" href="#限制-1">限制</a></h2>
<ul>
<li><code>static</code> 语句仅支持单目标赋值，不可批量定义多个字段。</li>
<li>不允许在 <code>static</code> 中调用依赖输入记录的数据访问函数（<code>read()</code>/<code>take()</code> 等），否则编译期会报错。</li>
<li>静态符号仅在定义所在模型内可见，不会跨模型共享。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="连接器管理"><a class="header" href="#连接器管理">连接器管理</a></h1>
<p>本文档介绍 Warp Parse 系统中连接器（Connectors）的定义、结构和使用方法。</p>
<h2 id="连接器概念"><a class="header" href="#连接器概念">连接器概念</a></h2>
<h3 id="什么是连接器"><a class="header" href="#什么是连接器">什么是连接器</a></h3>
<p>连接器是数据源和数据输出的配置模板，定义了特定类型连接器的默认参数和行为。通过将连接器定义与实例配置分离，实现了配置的复用和统一管理。</p>
<h3 id="连接器的作用"><a class="header" href="#连接器的作用">连接器的作用</a></h3>
<ol>
<li><strong>配置复用</strong>: 多个源可以引用同一个连接器</li>
<li><strong>参数标准化</strong>: 统一同类数据源的配置规范</li>
<li><strong>权限控制</strong>: 通过 <code>allow_override</code> 控制可覆盖的参数</li>
<li><strong>版本管理</strong>: 便于连接器配置的版本控制</li>
</ol>
<h2 id="连接器定义结构"><a class="header" href="#连接器定义结构">连接器定义结构</a></h2>
<h3 id="基础结构"><a class="header" href="#基础结构">基础结构</a></h3>
<pre><code class="language-toml"># connectors/source.d/{connector_name}.toml
[[connectors]]
id = "unique_connector_id"
type = "connector_type"
allow_override = ["param1", "param2", "param3"]

[connectors.params]
param1 = "default_value1"
param2 = "default_value2"
param3 = "default_value3"
</code></pre>
<h3 id="字段说明"><a class="header" href="#字段说明">字段说明</a></h3>
<h4 id="id-必需"><a class="header" href="#id-必需">id (必需)</a></h4>
<ul>
<li>连接器的唯一标识符</li>
<li>在源配置中通过 <code>connect</code> 字段引用</li>
<li>命名规范：sources 连接器以 <code>_src</code> 结尾（如 <code>file_src</code>），sinks 连接器以 <code>_sink</code> 结尾（如 <code>file_json_sink</code>）</li>
</ul>
<h4 id="type-必需"><a class="header" href="#type-必需">type (必需)</a></h4>
<ul>
<li>连接器类型，决定使用哪种数据源/输出实现</li>
<li>Sources 支持的类型：<code>file</code>, <code>syslog</code>, <code>tcp</code>（<code>kafka</code> 暂未实现）</li>
<li>Sinks 支持的类型：<code>file</code>, <code>syslog</code>, <code>tcp</code>, <code>blackhole</code>（<code>kafka</code>、<code>prometheus</code> 暂未实现）</li>
</ul>
<h4 id="allow_override-可选"><a class="header" href="#allow_override-可选">allow_override (可选)</a></h4>
<ul>
<li>允许源/sink 配置覆盖的参数列表</li>
<li>为空时表示不允许覆盖任何参数</li>
<li>提供配置灵活性，同时保证安全性</li>
</ul>
<h4 id="params-必需"><a class="header" href="#params-必需">params (必需)</a></h4>
<ul>
<li>连接器的默认参数配置</li>
<li>被 <code>allow_override</code> 包含的参数可以在实例配置中覆盖</li>
</ul>
<h2 id="目录结构"><a class="header" href="#目录结构">目录结构</a></h2>
<pre><code>connectors/
├── source.d/                  # 源连接器目录
│   ├── 00-file-default.toml   # 文件连接器
│   ├── 10-syslog-udp.toml     # UDP Syslog 连接器
│   ├── 11-syslog-tcp.toml     # TCP Syslog 连接器
│   ├── 12-tcp.toml            # TCP 连接器
│   └── 30-kafka.toml          # Kafka 连接器
└── sink.d/                    # 输出连接器目录
    ├── 00-blackhole-sink.toml # 黑洞连接器
    ├── 02-file-json.toml      # JSON 文件输出
    ├── 10-syslog-udp.toml     # UDP Syslog 输出
    ├── 11-syslog-tcp.toml     # TCP Syslog 输出
    ├── 12-tcp.toml            # TCP 输出
    ├── 30-kafka.toml          # Kafka 输出
    └── 30-prometheus.toml     # Prometheus 输出
</code></pre>
<h2 id="连接器类型"><a class="header" href="#连接器类型">连接器类型</a></h2>
<h3 id="source-连接器"><a class="header" href="#source-连接器">Source 连接器</a></h3>
<h4 id="file-连接器"><a class="header" href="#file-连接器">File 连接器</a></h4>
<pre><code class="language-toml"># connectors/source.d/00-file-default.toml
[[connectors]]
id = "file_src"
type = "file"
allow_override = ["base", "file", "encode"]

[connectors.params]
base = "data/in_dat"
file = "gen.dat"
encode = "text"
</code></pre>
<h4 id="kafka-连接器暂未实现"><a class="header" href="#kafka-连接器暂未实现">Kafka 连接器（暂未实现）</a></h4>
<pre><code class="language-toml"># connectors/source.d/30-kafka.toml
[[connectors]]
id = "kafka_src"
type = "kafka"
allow_override = ["topic", "group_id", "config"]

[connectors.params]
brokers = "localhost:9092"
topic = ["access_log"]
group_id = "wparse_default_group"
</code></pre>
<blockquote>
<p>⚠️ Kafka 连接器当前暂未实现，请勿使用。</p>
</blockquote>
<h4 id="syslog-连接器"><a class="header" href="#syslog-连接器">Syslog 连接器</a></h4>
<pre><code class="language-toml"># connectors/source.d/11-syslog-tcp.toml
[[connectors]]
id = "syslog_tcp_src"
type = "syslog"
allow_override = ["addr", "port", "protocol", "tcp_recv_bytes", "header_mode", "prefer_newline"]

[connectors.params]
addr = "127.0.0.1"
port = 1514
protocol = "tcp"
header_mode = "strip"
tcp_recv_bytes = 256000
</code></pre>
<h4 id="tcp-连接器"><a class="header" href="#tcp-连接器">TCP 连接器</a></h4>
<pre><code class="language-toml"># connectors/source.d/12-tcp.toml
[[connectors]]
id = "tcp_src"
type = "tcp"
allow_override = ["addr", "port", "framing", "tcp_recv_bytes", "instances"]

[connectors.params]
addr = "0.0.0.0"
port = 9000
framing = "auto"
tcp_recv_bytes = 256000
</code></pre>
<h3 id="sink-连接器"><a class="header" href="#sink-连接器">Sink 连接器</a></h3>
<h4 id="file-连接器-1"><a class="header" href="#file-连接器-1">File 连接器</a></h4>
<pre><code class="language-toml"># connectors/sink.d/02-file-json.toml
[[connectors]]
id = "file_json_sink"
type = "file"
allow_override = ["base", "file"]

[connectors.params]
fmt = "json"
base = "./data/out_dat"
file = "default.json"
</code></pre>
<h4 id="syslog-连接器-1"><a class="header" href="#syslog-连接器-1">Syslog 连接器</a></h4>
<pre><code class="language-toml"># connectors/sink.d/11-syslog-tcp.toml
[[connectors]]
id = "syslog_tcp_sink"
type = "syslog"
allow_override = ["addr", "port", "protocol", "app_name"]

[connectors.params]
addr = "127.0.0.1"
port = 1514
protocol = "tcp"
</code></pre>
<h4 id="tcp-连接器-1"><a class="header" href="#tcp-连接器-1">TCP 连接器</a></h4>
<pre><code class="language-toml"># connectors/sink.d/12-tcp.toml
[[connectors]]
id = "tcp_sink"
type = "tcp"
allow_override = ["addr", "port", "framing"]

[connectors.params]
addr = "127.0.0.1"
port = 9000
framing = "line"
</code></pre>
<h2 id="连接器最佳实践"><a class="header" href="#连接器最佳实践">连接器最佳实践</a></h2>
<h3 id="1-参数覆盖设计"><a class="header" href="#1-参数覆盖设计">1. 参数覆盖设计</a></h3>
<pre><code class="language-toml"># ✅ 好的设计：明确的覆盖权限
[[connectors]]
id = "file_main"
type = "file"
allow_override = ["base", "file", "encode"]

# ❌ 避免：过度开放覆盖权限
[[connectors]]
id = "file_too_open"
type = "file"
allow_override = ["*"]  # 不支持且不安全
</code></pre>
<h3 id="2-默认值设置"><a class="header" href="#2-默认值设置">2. 默认值设置</a></h3>
<pre><code class="language-toml"># ✅ 好的设计：合理的默认值
[[connectors]]
id = "syslog_secure"
type = "syslog"
allow_override = ["addr", "port", "protocol"]

[connectors.params]
addr = "127.0.0.1"    # 安全的默认地址
port = 1514           # 非特权端口
protocol = "tcp"      # 可靠的协议
</code></pre>
<h2 id="相关文档-8"><a class="header" href="#相关文档-8">相关文档</a></h2>
<ul>
<li><a href="#source-基础">源配置基础</a></li>
<li><a href="#file-source">文件源配置</a></li>
<li><a href="#kafka-源配置-1">Kafka 源配置</a> ⚠️ 暂未实现</li>
<li><a href="#syslog-源配置-1">Syslog 源配置</a></li>
<li><a href="#tcp-源配置">TCP 源配置</a></li>
<li><a href="#sink-基础">Sink 配置基础</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sources-配置指南"><a class="header" href="#sources-配置指南">Sources 配置指南</a></h1>
<p>本指南介绍如何配置和使用 Warp Parse 系统的各种数据源。</p>
<h2 id="内容概览"><a class="header" href="#内容概览">内容概览</a></h2>
<ul>
<li><a href="#source-基础">源配置基础</a></li>
<li><a href="#file-source">文件源配置</a></li>
<li><a href="#kafka-源配置-1">Kafka 源配置</a></li>
<li><a href="#syslog-源配置-1">Syslog 源配置</a></li>
<li><a href="#tcp-源配置">TCP 源配置</a></li>
<li><a href="#source-meta">DataRecord 机制数据字段</a></li>
</ul>
<h2 id="快速开始-5"><a class="header" href="#快速开始-5">快速开始</a></h2>
<ol>
<li>了解 <a href="#source-基础">源配置基础概念</a></li>
<li>根据你的数据源类型选择相应的配置指南</li>
<li>参考连接器管理文档了解连接器定义</li>
</ol>
<h2 id="支持的数据源类型"><a class="header" href="#支持的数据源类型">支持的数据源类型</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类型</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>file</code></td><td>从本地文件读取数据</td><td><a href="#file-source">文件源配置</a></td></tr>
<tr><td><code>kafka</code></td><td>从 Kafka 消费消息</td><td><a href="#kafka-源配置-1">Kafka 源配置</a></td></tr>
<tr><td><code>syslog</code></td><td>接收 Syslog 协议数据 (UDP/TCP)</td><td><a href="#syslog-源配置-1">Syslog 源配置</a></td></tr>
<tr><td><code>tcp</code></td><td>通过 TCP 接收数据</td><td><a href="#tcp-源配置">TCP 源配置</a></td></tr>
</tbody>
</table>
</div>
<h2 id="相关文档-9"><a class="header" href="#相关文档-9">相关文档</a></h2>
<ul>
<li><a href="10-user/05-connectors/README.html">连接器管理</a></li>
<li><a href="10-user/05-connectors/02-sinks/README.html">Sinks 配置指南</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="source-基础"><a class="header" href="#source-基础">Source 基础</a></h1>
<p>本文档介绍 Warp Parse 系统中数据源配置的基础概念和用法。</p>
<h2 id="概述-7"><a class="header" href="#概述-7">概述</a></h2>
<p>数据源（Source）是 Warp Parse 系统的数据输入端，负责从各种数据源接收数据并输入到处理流程中。</p>
<h2 id="核心概念-1"><a class="header" href="#核心概念-1">核心概念</a></h2>
<h3 id="1-连接器connectors"><a class="header" href="#1-连接器connectors">1. 连接器（Connectors）</a></h3>
<p>连接器定义了如何与特定类型的数据源建立连接和通信。系统内置了多种连接器类型：</p>
<ul>
<li><strong>File Connector</strong>: 从文件读取数据</li>
<li><strong>Kafka Connector</strong>: 从 Kafka 消息队列消费数据</li>
<li><strong>Syslog Connector</strong>: 接收 Syslog 协议数据</li>
<li><strong>TCP Connector</strong>: 通过 TCP 套接字接收数据</li>
</ul>
<h3 id="2-连接器定义"><a class="header" href="#2-连接器定义">2. 连接器定义</a></h3>
<p>连接器定义存储在 <code>connectors/source.d/</code> 目录下：</p>
<pre><code class="language-toml"># connectors/source.d/kafka_src.toml
[[connectors]]
id = "kafka_src"
type = "kafka"
allow_override = ["topic", "group_id", "config"]

[connectors.params]
brokers = "localhost:9092"
topic = ["access_log"]
group_id = "wparse_default_group"
</code></pre>
<h3 id="3-源配置结构"><a class="header" href="#3-源配置结构">3. 源配置结构</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
key = "main_source"
enable = true
connect = "kafka_src"
tags = ["env:production"]

[[sources.params]]
topic = "events"
# 或使用 params_override (别名)
</code></pre>
<h2 id="配置步骤"><a class="header" href="#配置步骤">配置步骤</a></h2>
<ol>
<li><strong>定义连接器</strong>: 在 <code>connectors/source.d/</code> 目录下创建连接器配置文件</li>
<li><strong>配置源</strong>: 在源配置文件中引用连接器并指定参数</li>
<li><strong>验证配置</strong>: 使用 CLI 工具验证配置正确性</li>
<li><strong>启动系统</strong>: 启动 Warp Parse 系统开始接收数据</li>
</ol>
<h2 id="配置字段说明"><a class="header" href="#配置字段说明">配置字段说明</a></h2>
<h3 id="通用字段"><a class="header" href="#通用字段">通用字段</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>key</code></td><td>String</td><td>是</td><td>源的唯一标识符</td></tr>
<tr><td><code>enable</code></td><td>Boolean</td><td>否</td><td>是否启用该源（默认 true）</td></tr>
<tr><td><code>connect</code></td><td>String</td><td>是</td><td>引用的连接器 ID</td></tr>
<tr><td><code>tags</code></td><td>Array</td><td>否</td><td>源的标签列表</td></tr>
<tr><td><code>params</code></td><td>Table</td><td>否</td><td>连接器参数（可覆盖连接器默认值）</td></tr>
</tbody>
</table>
</div>
<h3 id="参数覆盖规则"><a class="header" href="#参数覆盖规则">参数覆盖规则</a></h3>
<ul>
<li>只有在连接器的 <code>allow_override</code> 列表中的参数才能被覆盖</li>
<li>未在列表中的参数使用连接器定义中的默认值</li>
</ul>
<h2 id="配置示例-4"><a class="header" href="#配置示例-4">配置示例</a></h2>
<h3 id="基础文件源"><a class="header" href="#基础文件源">基础文件源</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
key = "file_access_log"
enable = true
connect = "file_src"

[sources.params]
base = "/var/log/nginx"
file = "access.log"
</code></pre>
<h3 id="kafka-源配置"><a class="header" href="#kafka-源配置">Kafka 源配置</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
key = "kafka_access_logs"
enable = true
connect = "kafka_src"
tags = ["env:production", "type:access_log"]

[sources.params]
topic = "nginx_access_log"
</code></pre>
<h3 id="syslog-源配置"><a class="header" href="#syslog-源配置">Syslog 源配置</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
key = "syslog_tcp_1"
enable = true
connect = "syslog_tcp_src"
tags = ["protocol:tcp", "env:production"]

[sources.params]
addr = "127.0.0.1"
port = 1514
protocol = "tcp"
</code></pre>
<h2 id="相关文档-10"><a class="header" href="#相关文档-10">相关文档</a></h2>
<ul>
<li><a href="10-user/05-connectors/README.html">连接器管理</a></li>
<li><a href="#file-source">文件源配置</a></li>
<li><a href="#kafka-源配置-1">Kafka 源配置</a></li>
<li><a href="#syslog-源配置-1">Syslog 源配置</a></li>
<li><a href="#tcp-源配置">TCP 源配置</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="file-source"><a class="header" href="#file-source">File Source</a></h1>
<p>本文档详细介绍如何配置和使用 Warp Parse 系统的文件数据源。</p>
<h2 id="概述-8"><a class="header" href="#概述-8">概述</a></h2>
<p>文件源用于从本地文件系统读取数据，支持多种编码格式和灵活的路径配置。</p>
<h2 id="连接器定义"><a class="header" href="#连接器定义">连接器定义</a></h2>
<h3 id="基础文件连接器"><a class="header" href="#基础文件连接器">基础文件连接器</a></h3>
<pre><code class="language-toml"># connectors/source.d/00-file-default.toml
[[connectors]]
id = "file_src"
type = "file"
allow_override = ["base", "file", "encode"]

[connectors.params]
base = "data/in_dat"
file = "gen.dat"
encode = "text"
</code></pre>
<h2 id="支持的参数"><a class="header" href="#支持的参数">支持的参数</a></h2>
<h3 id="路径配置"><a class="header" href="#路径配置">路径配置</a></h3>
<h4 id="base--file-组合推荐"><a class="header" href="#base--file-组合推荐">base + file 组合（推荐）</a></h4>
<pre><code class="language-toml">[[sources]]
key = "file_composed"
connect = "file_src"

[[sources.params]]
base = "/var/log"
file = "access.log"
</code></pre>
<h4 id="instances多实例并行读取"><a class="header" href="#instances多实例并行读取">instances（多实例并行读取）</a></h4>
<pre><code class="language-toml">[[sources.params]]
instances = 4   # 1-32，默认为 1
</code></pre>
<blockquote>
<p>当 <code>instances &gt; 1</code> 时，文件会被按行边界分割为多个范围，由多个实例并行读取。</p>
<p><strong>多实例命名规则</strong>：当 <code>instances &gt; 1</code> 时，每个实例的 key 会自动添加后缀，如 <code>file_src-1</code>、<code>file_src-2</code> 等。</p>
</blockquote>
<h3 id="编码格式"><a class="header" href="#编码格式">编码格式</a></h3>
<h4 id="text-编码默认"><a class="header" href="#text-编码默认">text 编码（默认）</a></h4>
<pre><code class="language-toml">[[sources.params]]
encode = "text"
</code></pre>
<h2 id="配置示例-5"><a class="header" href="#配置示例-5">配置示例</a></h2>
<h3 id="基础文件读取"><a class="header" href="#基础文件读取">基础文件读取</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
enable = true
key = "access_log"
connect = "file_src"

[[sources.params]]
base = "/var/log/nginx"
file = "access.log"
</code></pre>
<h3 id="多文件源配置"><a class="header" href="#多文件源配置">多文件源配置</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
enable = true
key = "nginx_access"
connect = "file_src"

[[sources.params]]
base = "/var/log/nginx"
file = "access.log"

[[sources]]
enable = true
key = "nginx_error"
connect = "file_src"

[[sources.params]]
base = "/var/log/nginx"
file = "error.log"
</code></pre>
<h3 id="不同编码格式"><a class="header" href="#不同编码格式">不同编码格式</a></h3>
<pre><code class="language-toml"># Base64 编码的文件
[[sources]]
key = "base64_data"
connect = "file_src"

[[sources.params]]
base = "./data"
file = "encoded.b64"
encode = "base64"

# 十六进制编码的文件
[[sources]]
key = "hex_data"
connect = "file_src"

[[sources.params]]
base = "./data"
file = "encoded.hex"
encode = "hex"
</code></pre>
<h2 id="数据处理特性"><a class="header" href="#数据处理特性">数据处理特性</a></h2>
<h3 id="1-逐行读取"><a class="header" href="#1-逐行读取">1. 逐行读取</a></h3>
<p>文件源采用逐行读取模式，每行作为独立的数据包处理。</p>
<h3 id="2-编码处理"><a class="header" href="#2-编码处理">2. 编码处理</a></h3>
<ul>
<li><strong>text</strong>: 直接读取文本内容</li>
</ul>
<p>示例：</p>
<pre><code class="language-json">{
  "data": "原始日志内容",
  "tags": {
    "access_source": "/var/log/nginx/access.log",
    "env": "production"
  }
}
</code></pre>
<h2 id="相关文档-11"><a class="header" href="#相关文档-11">相关文档</a></h2>
<ul>
<li><a href="#source-基础">源配置基础</a></li>
<li><a href="10-user/05-connectors/README.html">连接器管理</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kafka-源配置-1"><a class="header" href="#kafka-源配置-1">Kafka 源配置</a></h1>
<blockquote>
<p><strong>⚠️ 注意</strong>：Kafka 源当前<strong>暂未实现</strong>。本文档为计划功能的设计文档，实际使用时请以代码实现为准。</p>
</blockquote>
<p>本文档详细介绍如何配置和使用 Warp Parse 系统的 Kafka 数据源。</p>
<h2 id="概述-9"><a class="header" href="#概述-9">概述</a></h2>
<p>Kafka 源用于从 Apache Kafka 消息队列消费数据，支持消费单个主题和灵活的配置选项。</p>
<blockquote>
<p><strong>注意</strong>：系统会自动创建配置的主题（如果不存在），消费者组 ID 可以通过 <code>group_id</code> 参数配置，默认为 <code>wparse_default_group</code>。</p>
</blockquote>
<h2 id="连接器定义-1"><a class="header" href="#连接器定义-1">连接器定义</a></h2>
<h3 id="基础-kafka-连接器"><a class="header" href="#基础-kafka-连接器">基础 Kafka 连接器</a></h3>
<pre><code class="language-toml"># connectors/source.d/30-kafka.toml
[[connectors]]
id = "kafka_src"
type = "kafka"
allow_override = ["topic", "group_id", "config"]

[connectors.params]
brokers = "localhost:9092"
topic = ["access_log"]
group_id = "wparse_default_group"
</code></pre>
<h2 id="支持的参数-1"><a class="header" href="#支持的参数-1">支持的参数</a></h2>
<h3 id="基础连接参数"><a class="header" href="#基础连接参数">基础连接参数</a></h3>
<h4 id="brokers-必需"><a class="header" href="#brokers-必需">brokers (必需)</a></h4>
<p>Kafka 集群地址，支持字符串格式</p>
<pre><code class="language-toml">[[sources.params]]
brokers = "localhost:9092"
</code></pre>
<h4 id="topic-必需"><a class="header" href="#topic-必需">topic (必需)</a></h4>
<p>消费的主题名称（数组形式）</p>
<pre><code class="language-toml">[[sources.params]]
topic = ["access_log"]
</code></pre>
<h4 id="group_id-可选"><a class="header" href="#group_id-可选">group_id (可选)</a></h4>
<p>消费者组 ID</p>
<pre><code class="language-toml">[[sources.params]]
group_id = "my_consumer_group"
</code></pre>
<h3 id="安全配置"><a class="header" href="#安全配置">安全配置</a></h3>
<p>所有安全相关参数必须通过 <code>config</code> 数组配置，格式为 <code>key=value</code> 字符串。</p>
<h4 id="ssltls-配置"><a class="header" href="#ssltls-配置">SSL/TLS 配置</a></h4>
<pre><code class="language-toml">[[sources.params]]
config = [
    "security_protocol=SSL",
    "ssl_ca_location=/path/to/ca.pem",
    "ssl_certificate_location=/path/to/client.pem",
    "ssl_key_location=/path/to/client.key",
    "ssl_key_password=key_password"
]
</code></pre>
<h4 id="sasl-认证"><a class="header" href="#sasl-认证">SASL 认证</a></h4>
<pre><code class="language-toml">[[sources.params]]
config = [
    "security_protocol=SASL_PLAINTEXT",
    "sasl_mechanisms=PLAIN",
    "sasl_username=consumer_user",
    "sasl_password=consumer_pass"
]
</code></pre>
<h4 id="saslscram-认证"><a class="header" href="#saslscram-认证">SASL/SCRAM 认证</a></h4>
<pre><code class="language-toml">[[sources.params]]
config = [
    "security_protocol=SASL_SSL",
    "sasl_mechanisms=SCRAM-SHA-256",
    "sasl_username=consumer_user",
    "sasl_password=consumer_pass"
]
</code></pre>
<h3 id="高级配置"><a class="header" href="#高级配置">高级配置</a></h3>
<h4 id="消费策略"><a class="header" href="#消费策略">消费策略</a></h4>
<pre><code class="language-toml">[[sources.params]]
config = [
    "auto_offset_reset=earliest",
    "enable_auto_commit=false",
    "auto_commit_interval_ms=5000"
]
</code></pre>
<h4 id="会话和心跳配置"><a class="header" href="#会话和心跳配置">会话和心跳配置</a></h4>
<pre><code class="language-toml">[[sources.params]]
config = [
    "session_timeout_ms=30000",
    "heartbeat_interval_ms=3000",
    "max_poll_interval_ms=300000"
]
</code></pre>
<h4 id="批量消费配置"><a class="header" href="#批量消费配置">批量消费配置</a></h4>
<pre><code class="language-toml">[[sources.params]]
config = [
    "max_poll_records=500",
    "fetch_min_bytes=1",
    "fetch_max_wait_ms=500"
]
</code></pre>
<h2 id="配置示例-6"><a class="header" href="#配置示例-6">配置示例</a></h2>
<h3 id="基础配置-1"><a class="header" href="#基础配置-1">基础配置</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
enable = true
key = "kafka_access_logs"
connect = "kafka_src"

[[sources.params]]
topic = ["nginx_access_log"]
</code></pre>
<h3 id="高级配置-1"><a class="header" href="#高级配置-1">高级配置</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
enable = true
key = "kafka_advanced"
connect = "kafka_src"

[[sources.params]]
topic = ["access_log"]
config = [
    "auto_offset_reset=earliest",
    "enable_auto_commit=false"
]
</code></pre>
<h3 id="安全集群配置"><a class="header" href="#安全集群配置">安全集群配置</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
enable = true
key = "kafka_secure_logs"
connect = "kafka_src"
tags = ["env:production", "security:tls"]

[[sources.params]]
topic = ["secure_events"]
config = [
    "auto_offset_reset=latest",
    "enable_auto_commit=true",
    "auto_commit_interval_ms=1000"
]
</code></pre>
<h2 id="数据处理特性-1"><a class="header" href="#数据处理特性-1">数据处理特性</a></h2>
<h3 id="1-消息结构"><a class="header" href="#1-消息结构">1. 消息结构</a></h3>
<p>每个 Kafka 消息被转换为数据包，包含：</p>
<ul>
<li><strong>消息体</strong>: 消息的实际内容（payload）</li>
</ul>
<p>示例：</p>
<pre><code class="language-json">{
  "data": "原始消息内容",
  "tags": {
    "access_source": "access_log",
    "env": "production",
    "type": "access_log"
  }
}
</code></pre>
<h3 id="3-消费语义"><a class="header" href="#3-消费语义">3. 消费语义</a></h3>
<ul>
<li><strong>消费者组 ID</strong>: 通过 <code>group_id</code> 参数配置</li>
<li><strong>Topic 自动创建</strong>: 配置的主题不存在时会自动创建（1 个分区，复制因子为 1）</li>
<li><strong>偏移量提交</strong>: 由底层 rdkafka 库处理，可通过 config 参数配置</li>
</ul>
<h2 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h2>
<h3 id="1-批量消费"><a class="header" href="#1-批量消费">1. 批量消费</a></h3>
<pre><code class="language-toml">[[sources.params]]
config = [
    "max_poll_records=1000",
    "fetch_min_bytes=1024",
    "fetch_max_wait_ms=100"
]
</code></pre>
<h3 id="2-连接优化"><a class="header" href="#2-连接优化">2. 连接优化</a></h3>
<pre><code class="language-toml">[[sources.params]]
config = [
    "session_timeout_ms=60000",
    "heartbeat_interval_ms=5000",
    "max_poll_interval_ms=600000"
]
</code></pre>
<h2 id="相关文档-12"><a class="header" href="#相关文档-12">相关文档</a></h2>
<ul>
<li><a href="#source-基础">源配置基础</a></li>
<li><a href="10-user/05-connectors/README.html">连接器管理</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="syslog-源配置-1"><a class="header" href="#syslog-源配置-1">Syslog 源配置</a></h1>
<p>本文档详细介绍如何配置和使用 Warp Parse 系统的 Syslog 数据源。</p>
<h2 id="概述-10"><a class="header" href="#概述-10">概述</a></h2>
<p>Syslog 源用于接收和解析标准的 Syslog 协议消息，支持 UDP 和 TCP 两种传输协议，以及多种 Syslog 格式。</p>
<h2 id="连接器定义-2"><a class="header" href="#连接器定义-2">连接器定义</a></h2>
<h3 id="udp-syslog-连接器"><a class="header" href="#udp-syslog-连接器">UDP Syslog 连接器</a></h3>
<pre><code class="language-toml"># connectors/source.d/10-syslog-udp.toml
[[connectors]]
id = "syslog_udp_src"
type = "syslog"
allow_override = ["addr", "port", "protocol", "tcp_recv_bytes", "header_mode", "fast_strip"]

[connectors.params]
addr = "0.0.0.0"
port = 1514
protocol = "udp"
header_mode = "strip"
tcp_recv_bytes = 256000
</code></pre>
<h3 id="tcp-syslog-连接器"><a class="header" href="#tcp-syslog-连接器">TCP Syslog 连接器</a></h3>
<pre><code class="language-toml"># connectors/source.d/11-syslog-tcp.toml
[[connectors]]
id = "syslog_tcp_src"
type = "syslog"
allow_override = ["addr", "port", "protocol", "tcp_recv_bytes", "header_mode", "fast_strip"]

[connectors.params]
addr = "127.0.0.1"
port = 1514
protocol = "tcp"
header_mode = "strip"
tcp_recv_bytes = 256000
</code></pre>
<h2 id="支持的参数-2"><a class="header" href="#支持的参数-2">支持的参数</a></h2>
<h3 id="基础网络参数"><a class="header" href="#基础网络参数">基础网络参数</a></h3>
<h4 id="addr-必需"><a class="header" href="#addr-必需">addr (必需)</a></h4>
<p>监听地址</p>
<pre><code class="language-toml">[[sources.params]]
addr = "0.0.0.0"    # 监听所有接口
addr = "127.0.0.1"   # 仅本地接口
addr = "10.0.0.100"  # 特定接口
</code></pre>
<h4 id="port-必需"><a class="header" href="#port-必需">port (必需)</a></h4>
<p>监听端口</p>
<pre><code class="language-toml">[[sources.params]]
port = 514           # 标准 syslog 端口 (需要 root 权限)
</code></pre>
<h4 id="protocol-必需"><a class="header" href="#protocol-必需">protocol (必需)</a></h4>
<p>传输协议</p>
<pre><code class="language-toml">[[sources.params]]
protocol = "tcp"     # TCP 协议 (可靠传输)
</code></pre>
<h3 id="消息处理参数"><a class="header" href="#消息处理参数">消息处理参数</a></h3>
<h4 id="header_mode"><a class="header" href="#header_mode">header_mode</a></h4>
<p>头部处理模式</p>
<pre><code class="language-toml">[[sources.params]]
header_mode = "strip"   # 仅剥离头部，不注入标签
header_mode = "parse"   # 解析+注入标签+剥离头部（默认）
header_mode = "keep"    # 保留头部，原样透传
</code></pre>
<h4 id="fast_strip"><a class="header" href="#fast_strip">fast_strip</a></h4>
<p>快速剥离模式（性能优化）</p>
<pre><code class="language-toml">[[sources.params]]
fast_strip = true   # 启用快速剥离（性能更好）
</code></pre>
<h3 id="tcp-专用参数"><a class="header" href="#tcp-专用参数">TCP 专用参数</a></h3>
<h4 id="tcp_recv_bytes"><a class="header" href="#tcp_recv_bytes">tcp_recv_bytes</a></h4>
<p>TCP 接收缓冲区大小</p>
<pre><code class="language-toml">[[sources.params]]
tcp_recv_bytes = 256000      # 256KB (默认)
tcp_recv_bytes = 10485760    # 10MB
tcp_recv_bytes = 104857600   # 100MB (高性能)
</code></pre>
<h2 id="配置示例-7"><a class="header" href="#配置示例-7">配置示例</a></h2>
<h3 id="基础-udp-配置"><a class="header" href="#基础-udp-配置">基础 UDP 配置</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
enable = true
key = "syslog_udp_1"
connect = "syslog_udp_src"
tags = ["protocol:udp", "env:production"]

[[sources.params]]
addr = "0.0.0.0"
port = 1514
protocol = "udp"
</code></pre>
<h3 id="基础-tcp-配置"><a class="header" href="#基础-tcp-配置">基础 TCP 配置</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
enable = true
key = "syslog_tcp_1"
connect = "syslog_tcp_src"
tags = ["protocol:tcp", "env:production"]

[[sources.params]]
addr = "127.0.0.1"
port = 1514
protocol = "tcp"
</code></pre>
<h3 id="双协议配置"><a class="header" href="#双协议配置">双协议配置</a></h3>
<pre><code class="language-toml"># wpsrc.toml
[[sources]]
enable = true
key = "syslog_udp_collector"
connect = "syslog_udp_src"

[[sources.params]]
addr = "0.0.0.0"
port = 1514
protocol = "udp"
header_mode = "strip"

[[sources]]
enable = true
key = "syslog_tcp_aggregator"
connect = "syslog_tcp_src"

[[sources.params]]
addr = "127.0.0.1"
port = 1515
protocol = "tcp"
header_mode = "parse"
tcp_recv_bytes = 1048576
</code></pre>
<h2 id="数据处理特性-2"><a class="header" href="#数据处理特性-2">数据处理特性</a></h2>
<h3 id="1-syslog-格式支持"><a class="header" href="#1-syslog-格式支持">1. Syslog 格式支持</a></h3>
<h4 id="rfc3164-格式-传统-bsd-syslog"><a class="header" href="#rfc3164-格式-传统-bsd-syslog">RFC3164 格式 (传统 BSD Syslog)</a></h4>
<pre><code>&lt;34&gt;Oct 11 22:14:15 mymachine su: 'su root' failed for lonvick on /dev/pts/8
</code></pre>
<h4 id="rfc5424-格式-现代-syslog"><a class="header" href="#rfc5424-格式-现代-syslog">RFC5424 格式 (现代 Syslog)</a></h4>
<pre><code>&lt;165&gt;1 2003-10-11T22:14:15.003Z mymachine.example.com evntslog - ID47 [exampleSDID@32473 iut="3" eventSource="Application" eventID="1011"] BOMAn application event log entry
</code></pre>
<h3 id="2-解析字段"><a class="header" href="#2-解析字段">2. 解析字段</a></h3>
<p>当 <code>header_mode = "parse"</code> 时，系统会解析并添加以下标签：</p>
<pre><code class="language-json">{
  "data": "原始消息内容",
  "tags": {
    "source_type": "syslog",
    "syslog_priority": 34,        // 数值优先级
    "syslog_facility": 4,         // 设施代码
    "syslog_severity": 2,         // 严重性级别
    "syslog_hostname": "mymachine",
    "syslog_app_name": "su",
    "syslog_proc_id": "1234",     // 进程ID (RFC5424)
    "syslog_msg_id": "ID47",      // 消息ID (RFC5424)
    "syslog_timestamp": "Oct 11 22:14:15"
  }
}
</code></pre>
<h3 id="3-分帧头部处理优化"><a class="header" href="#3-分帧头部处理优化">3. 分帧/头部处理优化</a></h3>
<pre><code class="language-toml"># 高性能场景：
header_mode = "strip"         # 仅去头，减少解析与标签注入
fast_strip = true             # 启用快速剥离

# 分析场景：
header_mode = "parse"         # 解析并注入协议相关元信息
</code></pre>
<h2 id="相关文档-13"><a class="header" href="#相关文档-13">相关文档</a></h2>
<ul>
<li><a href="#source-基础">源配置基础</a></li>
<li><a href="10-user/05-connectors/README.html">连接器管理</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tcp-源配置"><a class="header" href="#tcp-源配置">TCP 源配置</a></h1>
<p>本文档介绍通用 TCP 源（kind=<code>tcp</code>）的使用方式、分帧模式与与 TCP Sink 的联动示例。</p>
<h2 id="功能概览"><a class="header" href="#功能概览">功能概览</a></h2>
<ul>
<li>支持三种分帧模式：
<ul>
<li><code>line</code>：按换行符分帧；行末的 CR/空格/Tab 会被去除</li>
<li><code>len</code>：长度前缀（RFC 6587 octet-counting）：<code>&lt;len&gt;&lt;SP&gt;&lt;payload&gt;</code></li>
<li><code>auto</code>（默认）：自动选择；默认优先 <code>len</code>，当 <code>prefer_newline=true</code> 时优先按行</li>
</ul>
</li>
</ul>
<h2 id="连接器定义sourced"><a class="header" href="#连接器定义sourced">连接器定义（source.d）</a></h2>
<pre><code class="language-toml"># connectors/source.d/12-tcp.toml
[[connectors]]
id = "tcp_src"
type = "tcp"
# 允许覆写的键，兼容 syslog 的常见命名
allow_override = ["addr", "port", "framing", "tcp_recv_bytes", "instances"]

[connectors.params]
addr = "0.0.0.0"
port = 9000
framing = "auto"          # auto|line|len
tcp_recv_bytes = 256000   # 256KB
# instances = 1             # 可选：多实例并行，默认 1，最大 16
</code></pre>
<h2 id="源配置wpsrctoml"><a class="header" href="#源配置wpsrctoml">源配置（wpsrc.toml）</a></h2>
<pre><code class="language-toml">[[sources]]
key = "tcp_in"
connect = "tcp_src"
enable = true
tags = ["source:tcp", "type:raw"]

[[sources.params]]
port = 19000
framing = "auto"
instances = 2
</code></pre>
<h2 id="分帧模式详解"><a class="header" href="#分帧模式详解">分帧模式详解</a></h2>
<h3 id="line换行"><a class="header" href="#line换行">line（换行）</a></h3>
<ul>
<li>适用：文本日志、人工/脚本推送、简单工具（nc/tail）链路</li>
<li>行尾会去掉 <code>\r</code>/空格/Tab；建议发送端每条以 <code>\n</code> 结尾</li>
</ul>
<h3 id="len长度前缀"><a class="header" href="#len长度前缀">len（长度前缀）</a></h3>
<ul>
<li>形如：<code>5 hello</code> → 表示下一条 payload 长度为 5 字节（不包含前缀中的空格）</li>
<li>适用：payload 可能包含换行/二进制的场景（例如多行日志、堆栈、压缩片段）</li>
<li>接收端约束：长度最大 10MB、前缀最多 10 位十进制，异常时丢弃当前尝试，避免内存膨胀</li>
</ul>
<h3 id="auto自动"><a class="header" href="#auto自动">auto（自动）</a></h3>
<ul>
<li>默认优先尝试 <code>len</code>，若解析失败则回退按行</li>
<li>若已检测到“长度前缀进行中“（读到 <code>&lt;digits&gt;&lt;SP&gt;</code> 但 payload 未到齐），会继续等待，而不会回退按行，避免误切分</li>
</ul>
<h2 id="与-tcp-sink-联动回环链路"><a class="header" href="#与-tcp-sink-联动回环链路">与 TCP Sink 联动（回环链路）</a></h2>
<p>为了便于端到端联调，本项目提供了通用 TCP Sink（kind=<code>tcp</code>）：</p>
<ul>
<li>sink connectors：<code>connectors/sink.d/12-tcp.toml</code></li>
<li>sink 参数：<code>addr</code>/<code>port</code>/<code>framing(line|len)</code></li>
<li>示例：<code>wpgen</code> 输出到 <code>tcp_sink</code>，<code>wparse</code> 以 <code>tcp_src</code> 监听同端口，实现本机回环</li>
</ul>
<h3 id="示例-wpgenconfwpgentoml"><a class="header" href="#示例-wpgenconfwpgentoml">示例 wpgen（conf/wpgen.toml）</a></h3>
<pre><code class="language-toml">[generator]
mode = "sample"
count = 10000

[output]
connect = "tcp_sink"

[output.params]
addr = "127.0.0.1"
port = 19000
framing = "line"  # 或 "len"
</code></pre>
<h2 id="完整用例usecasecoretcp_roundtrip"><a class="header" href="#完整用例usecasecoretcp_roundtrip">完整用例（usecase/core/tcp_roundtrip）</a></h2>
<p>目录：<code>usecase/core/tcp_roundtrip</code></p>
<ul>
<li>启动：<code>./case_verify.sh</code></li>
<li>步骤：启动 wparse（tcp 源）→ wpgen 推送（tcp sink）→ 校验文件输出</li>
</ul>
<h2 id="常见问题faq"><a class="header" href="#常见问题faq">常见问题（FAQ）</a></h2>
<ul>
<li>问：文本以“数字+空格“开头会不会被误判为长度前缀？
<ul>
<li>答：在 <code>auto</code> 模式下，确有可能；可通过 <code>framing="line"</code> 避免</li>
</ul>
</li>
<li>问：为什么推荐生产中用 <code>len</code>？
<ul>
<li>答：边界明确、对二进制/多行更稳健；很多 syslog/TCP 等生产链路推荐/默认使用 octet‑counting</li>
</ul>
</li>
</ul>
<h2 id="最佳实践-11"><a class="header" href="#最佳实践-11">最佳实践</a></h2>
<ul>
<li>仅文本：<code>framing="line"</code></li>
<li>多行/二进制：<code>framing="len"</code>（或 <code>auto</code> 默认）</li>
<li>快速联调：<code>framing="line"</code>，配合 <code>nc -lk &lt;port&gt;</code></li>
</ul>
<h2 id="相关文档-14"><a class="header" href="#相关文档-14">相关文档</a></h2>
<ul>
<li><a href="#source-基础">源配置基础</a></li>
<li><a href="#tcp-sink">TCP Sink 配置</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="source-meta"><a class="header" href="#source-meta">Source Meta</a></h1>
<h2 id="概述-11"><a class="header" href="#概述-11">概述</a></h2>
<p>Warp Parse 系统在解析数据时，会自动向 DataRecord 追加一些机制数据字段，用于追踪数据的来源和处理路径。这些机制数据字段以 <code>wp_</code> 前缀标识，为系统提供了数据溯源和调试能力。</p>
<h2 id="机制数据字段列表"><a class="header" href="#机制数据字段列表">机制数据字段列表</a></h2>
<h3 id="1-wp_event_id"><a class="header" href="#1-wp_event_id">1. wp_event_id</a></h3>
<ul>
<li><strong>字段类型</strong>: 字符串 (String)</li>
<li><strong>描述</strong>: 事件的唯一标识符</li>
<li><strong>来源</strong>: 从 SourceEvent.event_id 获取
-<strong>用途</strong>: 追踪单个事件在系统中的完整处理流程</li>
</ul>
<h3 id="2-wp_src_key"><a class="header" href="#2-wp_src_key">2. wp_src_key</a></h3>
<ul>
<li><strong>字段类型</strong>: 字符串 (String)</li>
<li><strong>描述</strong>: 数据源的标识符</li>
<li><strong>来源</strong>: 从 SourceEvent.src_key 获取</li>
<li><strong>用途</strong>: 标识数据来源于哪个数据源（如 “syslog_1”, “file_reader” 等）</li>
</ul>
<h3 id="3-wp_src_ip"><a class="header" href="#3-wp_src_ip">3. wp_src_ip</a></h3>
<ul>
<li><strong>字段类型</strong>: IP 地址 (IP)</li>
<li><strong>描述</strong>: 数据源的客户端 IP 地址</li>
<li><strong>来源</strong>: 从 SourceEvent.ups_ip 获取</li>
<li><strong>用途</strong>: 记录发送数据的客户端 IP 地址，用于审计和定位</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sinks-配置指南"><a class="header" href="#sinks-配置指南">Sinks 配置指南</a></h1>
<p>本指南介绍如何配置和使用 Warp Parse 系统的各种数据输出（Sink）。</p>
<h2 id="支持的-sink-类型"><a class="header" href="#支持的-sink-类型">支持的 Sink 类型</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类型</th><th>说明</th><th>文档</th></tr>
</thead>
<tbody>
<tr><td><code>blackhole</code></td><td>黑洞输出（用于测试）</td><td>-</td></tr>
<tr><td><code>file</code></td><td>输出到本地文件</td><td><a href="#文件-sink">文件 Sink 配置</a></td></tr>
<tr><td><code>syslog</code></td><td>输出到 Syslog 服务器 (UDP/TCP)</td><td><a href="#syslog-sink">Syslog Sink 配置</a></td></tr>
<tr><td><code>tcp</code></td><td>输出到 TCP 服务端</td><td><a href="#tcp-sink">TCP Sink 配置</a></td></tr>
<tr><td><code>kafka</code></td><td>输出到 Kafka</td><td><a href="#kafka-sink">Kafka Sink 配置</a></td></tr>
<tr><td><code>mysql</code></td><td>输出到 MySQL</td><td><a href="#mysql-sink">MySQL Sink 配置</a></td></tr>
<tr><td><code>doris</code></td><td>输出到 Doris</td><td><a href="#doris-sink">Doris Sink 配置</a></td></tr>
<tr><td><code>prometheus</code></td><td>Prometheus 指标暴露</td><td><a href="#prometheus-sink">Prometheus Sink 配置</a></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sink-基础"><a class="header" href="#sink-基础">Sink 基础</a></h1>
<p>本文档介绍 warpparse 系统中数据输出端 (Sink) 的基础概念和配置结构。</p>
<h2 id="概述-12"><a class="header" href="#概述-12">概述</a></h2>
<p>Sink 是 warpparse 系统的数据输出端，负责将处理后的数据发送到各种目标系统。系统支持多种输出类型，包括文件、Syslog、Prometheus 等。</p>
<h2 id="核心概念-2"><a class="header" href="#核心概念-2">核心概念</a></h2>
<h3 id="1-配置层次结构"><a class="header" href="#1-配置层次结构">1. 配置层次结构</a></h3>
<p>warpparse 系统采用分层配置架构：</p>
<pre><code>全局默认配置 (defaults.toml)
    ↓
路由组配置 (business.d/**/*.toml, infra.d/**/*.toml)
    ↓
连接器定义 (connectors/sink.d/*.toml)
    ↓
解析后的 Sink 实例 (ResolvedSinkSpec)
</code></pre>
<h3 id="2-核心数据结构"><a class="header" href="#2-核心数据结构">2. 核心数据结构</a></h3>
<h2 id="配置文件结构-1"><a class="header" href="#配置文件结构-1">配置文件结构</a></h2>
<h3 id="1-连接器定义-connectorstoml"><a class="header" href="#1-连接器定义-connectorstoml">1. 连接器定义 (connectors.toml)</a></h3>
<pre><code class="language-toml"># connectors/sink.d/file_raw_sink.toml
[[connectors]]
id = "file_raw_sink"
type = "file"
allow_override = ["base", "file", "fmt"]

[connectors.params]
base = "./data/out_dat"
file = "default.dat"
fmt = "json"
</code></pre>
<p><strong>关键字段说明</strong>：</p>
<ul>
<li><code>id</code>: 连接器唯一标识符</li>
<li><code>type</code>: 连接器类型 (file, syslog, prometheus 等)</li>
<li><code>allow_override</code>: 允许源配置覆盖的参数列表</li>
<li><code>params</code>: 连接器默认参数</li>
</ul>
<h3 id="2-路由配置-businessdtoml-infradtoml"><a class="header" href="#2-路由配置-businessdtoml-infradtoml">2. 路由配置 (business.d/<strong>/*.toml, infra.d/</strong>/*.toml)</a></h3>
<pre><code class="language-toml"># business.d/example.toml
version = "2.0"

[sink_group]
name = "/sink/example"
oml = ["example_pattern"]
parallel = 2
tags = ["env:production"]

[[sink_group.sinks]]
name = "example_sink"
connect = "file_raw_sink"
params = {
    base = "./output",
    file = "example.dat"
}
filter = "./filter.wpl"
tags = ["type:example"]

[sink_group.sinks.expect]
ratio = 1.0
tol = 0.01
</code></pre>
<h3 id="3-全局默认配置-defaultstoml"><a class="header" href="#3-全局默认配置-defaultstoml">3. 全局默认配置 (defaults.toml)</a></h3>
<pre><code class="language-toml"># defaults.toml
version = "2.0"

[defaults]
tags = ["env:default"]

[defaults.expect]
basis = "total_input"
min_samples = 100
mode = "error"
</code></pre>
<h2 id="基础配置示例"><a class="header" href="#基础配置示例">基础配置示例</a></h2>
<h3 id="1-简单文件输出"><a class="header" href="#1-简单文件输出">1. 简单文件输出</a></h3>
<pre><code class="language-toml"># infra.d/simple_file.toml
version = "2.0"

[sink_group]
name = "simple_output"
oml = []
[[sink_group.sinks]]
connect = "file_raw_sink"
params = { file = "simple.log" }
</code></pre>
<h3 id="2-带过滤器的输出"><a class="header" href="#2-带过滤器的输出">2. 带过滤器的输出</a></h3>
<pre><code class="language-toml"># business.d/filtered_output.toml
version = "2.0"

[sink_group]
name = "/sink/filtered"
oml = ["/oml/logs/*"]

[[sink_group.sinks]]
name = "all_logs"
connect = "file_json_sink"
params = { file = "all_logs.json" }

[[sink_group.sinks]]
name = "error_logs"
connect = "file_json_sink"
filter = "./error_filter.wpl"
params = { file = "error_logs.json" }
[sink_group.sinks.expect]
ratio = 0.1
tol = 0.02
</code></pre>
<h3 id="3-并行输出配置仅业务组"><a class="header" href="#3-并行输出配置仅业务组">3. 并行输出配置（仅业务组）</a></h3>
<pre><code class="language-toml"># business.d/parallel_output.toml
version = "2.0"

[sink_group]
name = "/sink/parallel"
oml = ["high_volume"]
parallel = 4
tags = ["type:parallel"]

[[sink_group.sinks]]
name = "output_1"
connect = "file_proto_sink"
params = { file = "output_1.dat" }

[[sink_group.sinks]]
name = "output_2"
connect = "file_proto_sink"
params = { file = "output_2.dat" }
</code></pre>
<p>注：基础组（infra.d）不支持 <code>parallel</code> 与文件分片；如需提升吞吐与分片，请在业务组配置。</p>
<h2 id="标签系统"><a class="header" href="#标签系统">标签系统</a></h2>
<h3 id="1-标签继承层次"><a class="header" href="#1-标签继承层次">1. 标签继承层次</a></h3>
<p>标签系统支持三层继承：</p>
<ol>
<li><strong>默认标签</strong> (来自 defaults.toml)</li>
<li><strong>组级标签</strong> (来自 sink_group)</li>
<li><strong>Sink 级标签</strong> (来自具体 sink)</li>
</ol>
<h3 id="2-标签配置示例"><a class="header" href="#2-标签配置示例">2. 标签配置示例</a></h3>
<pre><code class="language-toml"># defaults.toml
[defaults]
tags = ["env:production", "service:warpflow"]

# business.d/example.toml
[sink_group]
tags = ["region:us-west", "tier:processing"]

[[sink_group.sinks]]
tags = ["output:file", "compression:gzip"]
</code></pre>
<p><strong>最终标签合并结果</strong>：</p>
<pre><code>["env:production", "service:warpflow", "region:us-west", "tier:processing", "output:file", "compression:gzip"]
</code></pre>
<h2 id="期望值配置-expect"><a class="header" href="#期望值配置-expect">期望值配置 (Expect)</a></h2>
<h3 id="1-比例模式"><a class="header" href="#1-比例模式">1. 比例模式</a></h3>
<pre><code class="language-toml">[sink_group.sinks.expect]
ratio = 1.0    # 期望占比 100%
tol = 0.01     # 允许偏差 ±1%
</code></pre>
<h3 id="2-范围模式"><a class="header" href="#2-范围模式">2. 范围模式</a></h3>
<pre><code class="language-toml">[sink_group.sinks.expect]
min = 0.001    # 最小占比 0.1%
max = 2.0      # 最大占比 200%
</code></pre>
<h3 id="3-全局默认期望值"><a class="header" href="#3-全局默认期望值">3. 全局默认期望值</a></h3>
<pre><code class="language-toml">[defaults.expect]
basis = "total_input"  # 计算基准
min_samples = 100      # 最小样本数
mode = "error"         # 违规时处理模式
</code></pre>
<h2 id="过滤器配置"><a class="header" href="#过滤器配置">过滤器配置</a></h2>
<h3 id="1-过滤器文件"><a class="header" href="#1-过滤器文件">1. 过滤器文件</a></h3>
<p>过滤器文件使用 WPL (Warp Processing Language) 语法：</p>
<pre><code class="language-wpl"># filter.wpl
# 只处理错误级别的日志
level == "ERROR" || level == "FATAL"

# 或者复杂条件
(level == "ERROR" &amp;&amp; source == "auth") ||
(level == "WARN" &amp;&amp; message ~= "timeout")
</code></pre>
<h3 id="2-过滤器应用"><a class="header" href="#2-过滤器应用">2. 过滤器应用</a></h3>
<pre><code class="language-toml">[[sink_group.sinks]]
name = "filtered_output"
connect = "file_json_sink"
filter = "./error_filter.wpl"    # 应用过滤器
params = { file = "errors.json" }
</code></pre>
<h2 id="配置验证"><a class="header" href="#配置验证">配置验证</a></h2>
<h3 id="1-参数覆盖验证"><a class="header" href="#1-参数覆盖验证">1. 参数覆盖验证</a></h3>
<p>系统严格验证参数覆盖：</p>
<ul>
<li>只能覆盖 <code>allow_override</code> 中指定的参数</li>
<li>不支持嵌套表结构覆盖</li>
</ul>
<h3 id="2-唯一性验证"><a class="header" href="#2-唯一性验证">2. 唯一性验证</a></h3>
<ul>
<li>同一 sink_group 内 sink 名称必须唯一</li>
<li>连接器 ID 必须全局唯一</li>
</ul>
<h3 id="3-文件存在性验证"><a class="header" href="#3-文件存在性验证">3. 文件存在性验证</a></h3>
<ul>
<li>过滤器文件必须存在且语法正确</li>
<li>文件路径参数必须有效</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="defaults"><a class="header" href="#defaults">defaults</a></h1>
<p>目标</p>
<ul>
<li>配置期望（比例/阈值/窗口）并理解分母口径与忽略规则；在 CLI 中进行校验。</li>
</ul>
<p>核心概念（权威见 <code>../02-config/04-sinks_config.md</code>）</p>
<ul>
<li>defaults：组的默认期望，<code>$SINK_ROOT/defaults.toml</code> 中的 <code>[defaults.expect]</code>；可被组/单 sink 覆盖。</li>
<li>group expect：<code>[sink_group].expect</code>；优先于 defaults。</li>
<li>sink expect：<code>[[sink_group.sinks]].expect</code>；仅支持局部字段（ratio/tol 或 min/max，二者不可混用）。</li>
<li>分母口径：<code>total_input | group_input | model</code>（具体定义见权威文档）。</li>
</ul>
<p>示例（defaults）</p>
<pre><code class="language-toml">version = "2.0"
[defaults]
tags = ["env:dev"]
[defaults.expect]
basis = "group_input"
min_samples = 100
mode = "warn"
</code></pre>
<p>示例（组级与单 sink）</p>
<pre><code class="language-toml">[sink_group]
name = "/sink/demo"
[sink_group.expect]
basis = "group_input"
mode  = "fail"

[[sink_group.sinks]]
name = "ff"
connect = "file_json_sink"
[sink_group.sinks.expect]
ratio = 0.98   # 与 min/max 互斥
tol   = 0.01
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sinks-路由"><a class="header" href="#sinks-路由">Sinks 路由</a></h1>
<!-- 角色：使用配置者 | 最近验证：2025-12-11 -->
<p>目标</p>
<ul>
<li>基于目录式 routes（business.d/infra.d）配置路由分发；理解业务组与基础组的差异及命名规则。</li>
</ul>
<p>核心概念（单点定义见 <code>../02-config/04-sinks_config.md</code>）</p>
<ul>
<li>业务组 business.d：面向场景输出.</li>
<li>基础组 infra.d：系统级输出（default/miss/residue/error/monitor）。</li>
</ul>
<p>目录与命名</p>
<ul>
<li>业务组：<code>$SINK_ROOT/business.d/**/*.toml</code>，支持子目录递归；每个路由文件一个组。</li>
<li>基础组：<code>$SINK_ROOT/infra.d/**/*.toml</code>，支持子目录递归；固定组名（default/miss/…）。</li>
<li>连接器：从 <code>$WORK_ROOT/models/sinks</code> 起向上查找最近的 <code>connectors/sink.d/*.toml</code>。</li>
</ul>
<p>最小示例（业务组）</p>
<pre><code class="language-toml">version = "2.0"
[sink_group]
name = "/sink/demo"
oml  = ["/oml/example/*"]
parallel = 1

[[sink_group.sinks]]
name = "file_out"
connect = "file_json_sink"   # 连接器 id
params = { file = "demo.json" }
</code></pre>
<p>基础组示例（default）</p>
<pre><code class="language-toml">version = "2.0"
[sink_group]
name = "default"

[[sink_group.sinks]]
name = "default_sink"
connect = "file_json_sink"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="文件-sink"><a class="header" href="#文件-sink">文件 Sink</a></h1>
<p>本文档介绍文件型 Sink 的现行配置与能力，已与代码实现对齐。</p>
<h2 id="概述-13"><a class="header" href="#概述-13">概述</a></h2>
<p>文件 Sink 将处理后的数据写入本地文件系统，支持多种输出格式和灵活的路径配置。常用于离线验收、归档与调试。</p>
<p>支持的输出格式（<code>fmt</code>）：<code>json</code>、<code>csv</code>、<code>kv</code>、<code>raw</code>、<code>proto</code>、<code>proto-text</code>（默认 <code>json</code>）。</p>
<h2 id="连接器定义-3"><a class="header" href="#连接器定义-3">连接器定义</a></h2>
<p>推荐直接使用仓库自带模板（位于 <code>connectors/sink.d/</code>）：</p>
<pre><code class="language-toml"># JSON
[[connectors]]
id = "file_json_sink"
type = "file"
allow_override = ["base","file"]
[connectors.params]
fmt  = "json"
base = "./data/out_dat"
file = "default.json"

# Prototext
[[connectors]]
id = "file_proto_sink"
type = "file"
allow_override = ["base","file"]
[connectors.params]
fmt  = "proto-text"
base = "./data/out_dat"
file = "default.dat"

# Raw
[[connectors]]
id = "file_raw_sink"
type = "file"
allow_override = ["base","file"]
[connectors.params]
fmt  = "raw"
base = "./data/out_dat"
file = "default.raw"
</code></pre>
<h2 id="可用参数路由-params"><a class="header" href="#可用参数路由-params">可用参数（路由 <code>params</code>）</a></h2>
<ul>
<li><code>base</code> + <code>file</code>：目标目录与文件名（推荐写法）。</li>
<li><code>fmt</code>：输出格式（见上）。</li>
</ul>
<p>说明：文件 Sink 会自动创建父目录；内部使用缓冲写入并按批次刷新，无“手动缓冲大小/同步模式”等参数。</p>
<h2 id="配置示例-8"><a class="header" href="#配置示例-8">配置示例</a></h2>
<ol>
<li>基础 JSON 输出</li>
</ol>
<pre><code class="language-toml"># business.d/json_output.toml
version = "2.0"
[sink_group]
name = "/sink/json_output"
oml  = ["logs"]

[[sink_group.sinks]]
name = "json"
connect = "file_json_sink"
params = { base = "/var/log/warpflow", file = "application.json" }
</code></pre>
<ol start="2">
<li>错误日志分离（按过滤器）</li>
</ol>
<pre><code class="language-toml">version = "2.0"
[sink_group]
name = "/sink/error_logs"
oml  = ["application_logs"]

[[sink_group.sinks]]
name = "all"
connect = "file_json_sink"
params = { file = "all.json" }

[[sink_group.sinks]]
name = "err"
connect = "file_json_sink"
filter = "./error_filter.wpl"
params = { file = "err.json" }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="syslog-sink"><a class="header" href="#syslog-sink">Syslog Sink</a></h1>
<p>本文档与代码实现对齐，描述 Syslog Sink 的实际可用参数与示例。</p>
<h2 id="概述-14"><a class="header" href="#概述-14">概述</a></h2>
<p>Syslog Sink 将数据以 RFC3164 文本格式发送到 Syslog 服务器，支持 UDP 与 TCP。消息格式：<code>&lt;PRI&gt;TIMESTAMP HOSTNAME APP_NAME: MESSAGE</code>。</p>
<h2 id="连接器定义-4"><a class="header" href="#连接器定义-4">连接器定义</a></h2>
<p>使用仓库内置模板（<code>connectors/sink.d/10-syslog-udp.toml</code>、<code>11-syslog-tcp.toml</code>）：</p>
<pre><code class="language-toml">[[connectors]]
id = "syslog_udp_sink"
type = "syslog"
allow_override = ["addr", "port", "protocol", "app_name"]
[connectors.params]
addr = "127.0.0.1"
port = 1514
protocol = "udp"

[[connectors]]
id = "syslog_tcp_sink"
type = "syslog"
allow_override = ["addr", "port", "protocol", "app_name"]
[connectors.params]
addr = "127.0.0.1"
port = 1514
protocol = "tcp"
</code></pre>
<h2 id="可用参数路由-params-1"><a class="header" href="#可用参数路由-params-1">可用参数（路由 <code>params</code>）</a></h2>
<ul>
<li><code>addr</code>：Syslog 服务器地址（IP 或主机名）。</li>
<li><code>port</code>：端口（1–65535）。</li>
<li><code>protocol</code>：<code>udp</code> 或 <code>tcp</code>（大小写不敏感）。</li>
<li><code>app_name</code>：应用名称，默认为当前进程名（如 <code>wp-engine</code>）。</li>
</ul>
<h2 id="配置示例-9"><a class="header" href="#配置示例-9">配置示例</a></h2>
<ol>
<li>基础 UDP 输出</li>
</ol>
<pre><code class="language-toml">version = "2.0"
[sink_group]
name = "/sink/syslog_basic"
oml  = ["application_logs"]

[[sink_group.sinks]]
name = "syslog_output"
connect = "syslog_udp_sink"
params = { addr = "syslog.example.com", port = 1514, protocol = "udp" }
</code></pre>
<ol start="2">
<li>按条件分流</li>
</ol>
<pre><code class="language-toml">version = "2.0"
[sink_group]
name = "/sink/syslog_by_cond"

[[sink_group.sinks]]
name = "error"
connect = "syslog_tcp_sink"
filter = "./error_filter.wpl"
params = { addr = "syslog-errors.example.com", port = 514, protocol = "tcp" }

[[sink_group.sinks]]
name = "info"
connect = "syslog_udp_sink"
filter = "./info_filter.wpl"
params = { addr = "syslog-info.example.com", port = 1514, protocol = "udp" }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="prometheus-sink"><a class="header" href="#prometheus-sink">Prometheus Sink</a></h1>
<blockquote>
<p><strong>⚠️ 注意</strong>：Prometheus Sink 当前<strong>暂未实现</strong>。本文档为计划功能的设计文档，实际使用时请以代码实现为准。</p>
</blockquote>
<p>本文档与代码实现对齐。当前 Prometheus Sink 为“自暴露“型 Exporter，会在本地启动一个 HTTP 服务（默认仅支持 Counter 类计数），对外暴露 <code>/metrics</code>。</p>
<h2 id="连接器定义-5"><a class="header" href="#连接器定义-5">连接器定义</a></h2>
<p>使用仓库模板（<code>connectors/sink.d/40-prometheus.toml</code>）：</p>
<pre><code class="language-toml">[[connectors]]
id = "prometheus_sink"
type = "prometheus"
allow_override = ["endpoint", "source_key_format", "sink_key_format"]
[connectors.params]
endpoint = "127.0.0.1:35666"   # 监听地址（对外暴露 /metrics）
source_key_format = "(?P&lt;source_type&gt;.)_(?P&lt;access_source&gt;.)"
sink_key_format   = "(?P&lt;rule&gt;.)_(?P&lt;sink_type&gt;.)_sink"
</code></pre>
<p>说明：不支持 Pushgateway/自定义 <code>metric_name</code>/<code>metric_type</code>/<code>labels</code>。内置指标名固定：</p>
<ul>
<li><code>wparse_receive_data</code>（从数据源接收条数，带源标签）</li>
<li><code>wparse_parse_success</code>、<code>wparse_parse_all</code>（解析成功/总量）</li>
<li><code>wparse_send_to_sink</code>（发送到 sink 的条数，带 sink 标签）</li>
</ul>
<h2 id="可用参数路由-params-2"><a class="header" href="#可用参数路由-params-2">可用参数（路由 <code>params</code>）</a></h2>
<ul>
<li><code>endpoint</code>：Exporter 监听的 <code>host:port</code>（如 <code>127.0.0.1:35666</code>）。</li>
<li><code>source_key_format</code>：可选，用于从 key 中提取 <code>source_type/access_source</code> 的正则（具名分组）。</li>
<li><code>sink_key_format</code>：可选，用于从 key 中提取 <code>rule/sink_type</code> 的正则（具名分组）。</li>
</ul>
<h2 id="配置示例-10"><a class="header" href="#配置示例-10">配置示例</a></h2>
<p>启动 Exporter 并暴露指标：</p>
<pre><code class="language-toml">version = "2.0"
[sink_group]
name = "/sink/prom_exporter"
oml  = ["metrics"]

[[sink_group.sinks]]
name = "prom"
connect = "prometheus_sink"
params = { endpoint = "0.0.0.0:35666" }
</code></pre>
<p>验证：<code>curl http://127.0.0.1:35666/metrics</code></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tcp-sink"><a class="header" href="#tcp-sink">TCP Sink</a></h1>
<p>TCP sink 用于将数据输出到任意 TCP 服务端，支持按行或长度前缀（RFC6587 风格）分帧。</p>
<h2 id="连接器定义-6"><a class="header" href="#连接器定义-6">连接器定义</a></h2>
<pre><code class="language-toml">[[connectors]]
id = "tcp_sink"
type = "tcp"
allow_override = ["addr", "port", "framing"]

[connectors.params]
addr = "127.0.0.1"
port = 9000
framing = "line"   # line|len
</code></pre>
<h2 id="可用参数"><a class="header" href="#可用参数">可用参数</a></h2>
<ul>
<li><code>addr</code>：目标服务器地址（IP 或主机名）。</li>
<li><code>port</code>：目标端口（1–65535），默认 9000。</li>
<li><code>framing</code>：分帧模式，<code>line</code> 或 <code>len</code>，默认 <code>line</code>。</li>
</ul>
<h2 id="使用示例wpgen-输出到-tcp"><a class="header" href="#使用示例wpgen-输出到-tcp">使用示例（wpgen 输出到 TCP）</a></h2>
<pre><code class="language-toml"># conf/wpgen.toml
[generator]
mode = "sample"
count = 10000

[output]
connect = "tcp_sink"

[output.params]
addr = "127.0.0.1"
port = 9000
framing = "line"
</code></pre>
<h2 id="分帧说明"><a class="header" href="#分帧说明">分帧说明</a></h2>
<ul>
<li><code>line</code>：追加 <code>\n</code> 作为消息结束符</li>
<li><code>len</code>：发送 <code>&lt;len&gt;&lt;space&gt;&lt;payload&gt;</code>（不追加 <code>\n</code>）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="victorialogs"><a class="header" href="#victorialogs">VictoriaLogs</a></h1>
<p>VictoriaLogs sink 用于将日志数据输出到 <a href="https://docs.victoriametrics.com/victorialogs/">VictoriaLogs</a> 日志存储系统，通过 HTTP JSON Line 接口写入。</p>
<h2 id="连接器定义-7"><a class="header" href="#连接器定义-7">连接器定义</a></h2>
<pre><code class="language-toml">[[connectors]]
id = "victorialog_sink"
type = "victorialogs"
allow_override = ["endpoint", "insert_path", "fmt"]

[connectors.params]
endpoint = "http://localhost:8481"
insert_path = "/insert/json"
fmt = "json"
</code></pre>
<h2 id="可用参数-1"><a class="header" href="#可用参数-1">可用参数</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>endpoint</code></td><td>string</td><td><code>http://localhost:8481</code></td><td>VictoriaLogs 服务地址（必填）</td></tr>
<tr><td><code>insert_path</code></td><td>string</td><td><code>/insert/json</code></td><td>数据写入路径</td></tr>
<tr><td><code>create_time_field</code></td><td>string</td><td>-</td><td>自定义时间戳字段名，从数据记录中提取</td></tr>
<tr><td><code>fmt</code></td><td>string</td><td><code>json</code></td><td>输出格式：<code>json</code>、<code>csv</code>、<code>kv</code>、<code>raw</code> 等</td></tr>
</tbody>
</table>
</div>
<h2 id="数据格式"><a class="header" href="#数据格式">数据格式</a></h2>
<p>Sink 会将每条数据记录转换为 JSON 对象发送，包含以下特殊字段：</p>
<ul>
<li><code>_msg</code>：格式化后的消息内容（根据 <code>fmt</code> 参数格式化）</li>
<li><code>_time</code>：时间戳（纳秒精度），优先使用 <code>create_time_field</code> 指定字段，否则使用当前时间</li>
</ul>
<h2 id="配置示例-11"><a class="header" href="#配置示例-11">配置示例</a></h2>
<h3 id="基础用法"><a class="header" href="#基础用法">基础用法</a></h3>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "/sink/victorialogs"
oml  = ["logs"]

[[sink_group.sinks]]
name = "vlogs"
connect = "victorialog_sink"
params = { endpoint = "http://victorialogs:9428" }
</code></pre>
<h3 id="自定义时间字段"><a class="header" href="#自定义时间字段">自定义时间字段</a></h3>
<pre><code class="language-toml">[[sink_group.sinks]]
name = "vlogs"
connect = "victorialog_sink"

[sink_group.sinks.params]
endpoint = "http://victorialogs:9428"
insert_path = "/insert/jsonline"
create_time_field = "timestamp"
fmt = "json"
</code></pre>
<h2 id="注意事项-5"><a class="header" href="#注意事项-5">注意事项</a></h2>
<ul>
<li><code>endpoint</code> 参数不能为空，否则会校验失败</li>
<li>HTTP 请求超时时间为 5 秒</li>
<li>如果 <code>create_time_field</code> 指定的字段不存在或非时间类型，将使用当前 UTC 时间</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="doris-sink"><a class="header" href="#doris-sink">Doris Sink</a></h1>
<p>Doris sink 通过 Doris 的 MySQL 协议入口建立连接，并使用 Stream Load 写入数据。相比 mysql sink，对 Doris 兼容性更好（mysql sink 不兼容 Doris，doris sink 兼容 MySQL）。</p>
<h2 id="连接器定义-8"><a class="header" href="#连接器定义-8">连接器定义</a></h2>
<p>推荐使用仓库自带模板（位于 <code>connectors/sink.d/50-doris.toml</code>）：</p>
<pre><code class="language-toml">[[connectors]]
id = "doris_sink"
type = "doris"
allow_override = ["endpoint", "user", "password", "database", "table", "create_table"]

[connectors.params]
endpoint = "mysql://localhost:9030?charset=utf8mb4&amp;connect_timeout=10"
user = "root"
password = ""
database = "wp_test"
table = "events_parsed"
</code></pre>
<h2 id="可用参数-2"><a class="header" href="#可用参数-2">可用参数</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>类型</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>endpoint</code></td><td>string</td><td>Doris FE 的 MySQL 访问地址（DSN 形式），如 <code>mysql://host:9030?charset=utf8mb4</code>（必填）</td></tr>
<tr><td><code>user</code></td><td>string</td><td>Doris 用户名（必填）</td></tr>
<tr><td><code>password</code></td><td>string</td><td>Doris 密码（可为空）</td></tr>
<tr><td><code>database</code></td><td>string</td><td>目标数据库（必填）</td></tr>
<tr><td><code>table</code></td><td>string</td><td>目标表（必填）</td></tr>
<tr><td><code>create_table</code></td><td>string</td><td>可选建表 SQL，库表不存在时自动执行</td></tr>
<tr><td><code>pool_size</code></td><td>int</td><td>连接池大小（可选，常用 4）</td></tr>
<tr><td><code>batch_size</code></td><td>int</td><td>单批写入事件数量（可选，常用 2048）</td></tr>
</tbody>
</table>
</div>
<h2 id="配置示例-12"><a class="header" href="#配置示例-12">配置示例</a></h2>
<h3 id="基础用法-1"><a class="header" href="#基础用法-1">基础用法</a></h3>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "/sink/doris"
oml  = ["example2"]

[[sink_group.sinks]]
name = "doris_stream_load"
connect = "doris_sink"

[sink_group.sinks.params]
endpoint = "mysql://localhost:9030?charset=utf8mb4&amp;connect_timeout=10"
database = "wp_test"
table = "events_parsed"
user = "root"
password = ""
</code></pre>
<h3 id="自动建表"><a class="header" href="#自动建表">自动建表</a></h3>
<pre><code class="language-toml">[[sink_group.sinks]]
name = "doris_stream_load"
connect = "doris_sink"

[sink_group.sinks.params]
endpoint = "mysql://localhost:9030?charset=utf8mb4&amp;connect_timeout=10"
database = "wp_test"
table = "events_parsed"
create_table = """
CREATE DATABASE IF NOT EXISTS wp_test;
CREATE TABLE events_parsed (
    sn           VARCHAR(64) COMMENT '设备序列号',
    dev_name     VARCHAR(128) COMMENT '设备名称',
    sip          VARCHAR(45) COMMENT '源 IP',
    from_zone    VARCHAR(32) COMMENT '来源区域',
    from_ip      VARCHAR(45) COMMENT '来源 IP',
    requ_uri     VARCHAR(512) COMMENT '请求 URI',
    requ_status  SMALLINT COMMENT '请求状态码',
    resp_len     INT COMMENT '响应长度',
    src_city     VARCHAR(32) COMMENT '源城市'
)
    ENGINE=OLAP
    DUPLICATE KEY(sn)
COMMENT '设备请求事件解析表'
DISTRIBUTED BY HASH(sn) BUCKETS 8
PROPERTIES (
    "replication_num" = "1"
);
"""
user = "root"
password = ""
</code></pre>
<h2 id="注意事项-6"><a class="header" href="#注意事项-6">注意事项</a></h2>
<ul>
<li>确保 Doris FE 的 MySQL 端口可访问，并开启 Stream Load 能力。</li>
<li>需要为账号授予 <code>SELECT/INSERT</code> 以及 <code>LOAD</code> 权限。</li>
<li>完整端到端示例可参考 <code>wp-examples/extensions/doris/README.md</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kafka-sink"><a class="header" href="#kafka-sink">Kafka Sink</a></h1>
<p>Kafka sink 用于将数据输出到 Apache Kafka。启动时会尝试创建目标 topic（使用 <code>num_partitions</code>/<code>replication</code> 作为分区与副本配置）。</p>
<h2 id="连接器定义-9"><a class="header" href="#连接器定义-9">连接器定义</a></h2>
<p>推荐使用仓库自带模板（位于 <code>connectors/sink.d/30-kafka.toml</code>）：</p>
<pre><code class="language-toml">[[connectors]]
id = "kafka_sink"
type = "kafka"
allow_override = ["topic", "config", "num_partitions", "replication", "brokers"]

[connectors.params]
brokers = "localhost:9092"
topic = "wparse_output"
num_partitions = 1
replication = 1
# config = ["compression.type=snappy", "acks=all"]
</code></pre>
<h2 id="可用参数-3"><a class="header" href="#可用参数-3">可用参数</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>类型</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>brokers</code></td><td>string</td><td>Kafka bootstrap servers（逗号分隔，必填）</td></tr>
<tr><td><code>topic</code></td><td>string</td><td>目标 topic（必填）</td></tr>
<tr><td><code>num_partitions</code></td><td>int</td><td>自动创建 topic 的分区数（默认 1）</td></tr>
<tr><td><code>replication</code></td><td>int</td><td>自动创建 topic 的副本数（默认 1）</td></tr>
<tr><td><code>config</code></td><td>string/array</td><td>生产者配置列表，<code>key=value</code> 形式（可选）</td></tr>
</tbody>
</table>
</div>
<h2 id="配置示例-13"><a class="header" href="#配置示例-13">配置示例</a></h2>
<h3 id="基础用法-2"><a class="header" href="#基础用法-2">基础用法</a></h3>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "/sink/kafka"
oml  = ["example2"]

[[sink_group.sinks]]
name = "kafka_out"
connect = "kafka_sink"

[sink_group.sinks.params]
brokers = "localhost:9092"
topic = "wp.testcase.events.parsed"
</code></pre>
<h3 id="自定义生产者参数与格式"><a class="header" href="#自定义生产者参数与格式">自定义生产者参数与格式</a></h3>
<pre><code class="language-toml">[[sink_group.sinks]]
name = "kafka_out"
connect = "kafka_sink"

[sink_group.sinks.params]
topic = "app.events"
num_partitions = 3
replication = 1
config = [
  "compression.type=snappy",
  "acks=all",
  "linger.ms=5"
]
</code></pre>
<h2 id="注意事项-7"><a class="header" href="#注意事项-7">注意事项</a></h2>
<ul>
<li><code>config</code> 参数会透传给 Kafka producer（rdkafka），格式必须是 <code>key=value</code> 字符串。</li>
<li>若集群禁用自动建 topic，请提前在 Kafka 中创建目标 topic。</li>
<li>完整示例可参考 <code>wp-examples/extensions/kafka/README.md</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mysql-sink"><a class="header" href="#mysql-sink">MySQL Sink</a></h1>
<p>MySQL sink 用于将解析后的记录写入 MySQL 表。它会根据 <code>columns</code> 生成 <code>INSERT IGNORE</code> 语句，适合幂等重试场景；仅接受 Record 数据（不支持 raw 输入）。</p>
<h2 id="连接器定义-10"><a class="header" href="#连接器定义-10">连接器定义</a></h2>
<p>推荐使用仓库自带模板（位于 <code>connectors/sink.d/50-mysql.toml</code>）：</p>
<pre><code class="language-toml">[[connectors]]
id = "mysql_sink"
type = "mysql"
allow_override = ["endpoint", "username", "password", "database", "table", "columns", "batch"]

[connectors.params]
endpoint = "localhost:3306"
username = "root"
password = "123456"
database = "wparse"
table = "nginx_logs"
columns = ["sip", "timestamp", "http/request", "status", "size", "referer", "http/agent", "wp_event_id"]
batch = 20
</code></pre>
<h2 id="可用参数-4"><a class="header" href="#可用参数-4">可用参数</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>参数</th><th>类型</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>endpoint</code></td><td>string</td><td>MySQL 地址（<code>host:port</code>，必填）</td></tr>
<tr><td><code>username</code></td><td>string</td><td>用户名（可选，默认 <code>root</code>）</td></tr>
<tr><td><code>password</code></td><td>string</td><td>密码（可选）</td></tr>
<tr><td><code>database</code></td><td>string</td><td>目标数据库（必填）</td></tr>
<tr><td><code>table</code></td><td>string</td><td>目标表名（可选，未设置时使用 sink 名称）</td></tr>
<tr><td><code>columns</code></td><td>array</td><td>列名列表，决定写入字段顺序；必须包含 <code>wp_event_id</code>（缺省会自动补齐）</td></tr>
<tr><td><code>batch</code></td><td>int</td><td>批量写入条数（可选）</td></tr>
</tbody>
</table>
</div>
<h2 id="配置示例-14"><a class="header" href="#配置示例-14">配置示例</a></h2>
<h3 id="基础用法参考-extensionstcp_mysql"><a class="header" href="#基础用法参考-extensionstcp_mysql">基础用法（参考 <code>extensions/tcp_mysql</code>）</a></h3>
<pre><code class="language-toml">version = "2.0"

[sink_group]
name = "all"
rule = ["/*"]
parallel = 8

[[sink_group.sinks]]
name = "main"
connect = "mysql_sink"

[sink_group.sinks.params]
endpoint = "localhost:3306"
username = "root"
password = "123456"
database = "wparse"
table = "nginx_logs"
columns = ["sip", "timestamp", "http/request", "status", "size", "referer", "http/agent", "wp_event_id"]
batch = 20
</code></pre>
<h2 id="注意事项-8"><a class="header" href="#注意事项-8">注意事项</a></h2>
<ul>
<li>表结构必须包含 <code>wp_event_id</code>（建议为 <code>BIGINT</code> 主键），否则写入会失败或产生重复。</li>
<li><code>columns</code> 中的字段名需与 OML 输出字段一致；缺失字段会以 <code>NULL</code> 写入。</li>
<li>可通过环境变量 <code>MYSQL_URL</code> 覆盖连接串（格式：<code>mysql://user:pass@host:port/db</code>）。</li>
<li>端到端示例可参考 <code>wp-examples/extensions/tcp_mysql/README.md</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="排障指南troubleshooting"><a class="header" href="#排障指南troubleshooting">排障指南（Troubleshooting）</a></h1>
<!-- 角色：使用配置者 | 最近验证：2025-12-11 -->
<p>常见问题</p>
<ul>
<li>未找到 connectors 目录：确认 <code>connectors/source.d</code> 或 <code>connectors/sink.d</code> 是否存在；遵守“从 models/<code>&lt;side&gt;</code> 向上查找最近目录（≤32 层）“。</li>
<li>工厂未注册：确保调用 <code>plugins::register_sinks()</code> 与 <code>register_sources_factory_only()</code>；<code>wproj</code> 默认会做。</li>
<li>覆写报错：检查 <code>allow_override</code> 白名单；覆写表禁止嵌套 <code>params/params_override</code>。</li>
<li>tags 校验未过：数量/字符集/长度是否符合；减少高基数。</li>
<li>feature 缺失：Kafka/DB 等需按 Cargo feature 启用。</li>
</ul>
<p>定位建议</p>
<ul>
<li>使用 <code>wproj sinks validate|list|route</code> 和 <code>wproj sources list|route</code> 先“看清配置解析结果”。</li>
<li>打开 <code>conf/wparse.toml</code>，确认 <code>sink_root/src_root</code> 指向的 models 目录存在。</li>
</ul>
<p>延伸阅读</p>
<ul>
<li>文档导航：docs/README.md（Quick Triage）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="benchmark-report"><a class="header" href="#benchmark-report">BenchMark Report</a></h1>
<p>4 种日志 * 3 种拓扑 * 2 种能力 * 2 种平台 * 2 种引擎。</p>
<h2 id="范畴与指标"><a class="header" href="#范畴与指标">范畴与指标</a></h2>
<ul>
<li>拓扑：File -&gt; BlackHole、TCP -&gt; BlackHole、TCP -&gt; File。</li>
<li>能力：解析（Parse）；解析+转换（Parse+Transform）。</li>
<li>平台：Mac M4 Mini、Linux VPS。</li>
<li>引擎：WarpParse、Vector。</li>
<li>指标：EPS=Events Per Second，MPS（MiB/s, Messages Per Seconds)；CPU/MEM 取进程平均/峰值；规则大小为对应规则文件体积。</li>
<li>样本大小：Nginx 239B、AWS 411B、Sysmon 1K、APT 3K（单条日志）。</li>
</ul>
<h2 id="覆盖矩阵"><a class="header" href="#覆盖矩阵">覆盖矩阵</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>维度</th><th>取值</th></tr>
</thead>
<tbody>
<tr><td>日志类型</td><td>Nginx、AWS、Sysmon、APT</td></tr>
<tr><td>拓扑</td><td>File -&gt; BlackHole、TCP -&gt; BlackHole、TCP -&gt; File</td></tr>
<tr><td>能力</td><td>解析、解析+转换</td></tr>
<tr><td>平台</td><td>Mac M4 Mini（数据就绪）、Linux VPS（数据筹备中）</td></tr>
<tr><td>引擎</td><td>WarpParse、Vector</td></tr>
</tbody>
</table>
</div>
<h2 id="日志解析测试"><a class="header" href="#日志解析测试">日志解析测试</a></h2>
<h3 id="mac-m4-mini"><a class="header" href="#mac-m4-mini">Mac M4 Mini</a></h3>
<h4 id="nginx239b"><a class="header" href="#nginx239b">Nginx（239B）</a></h4>
<h5 id="warpparse"><a class="header" href="#warpparse">WarpParse</a></h5>
<h6 id="wpl"><a class="header" href="#wpl">WPL</a></h6>
<pre><code class="language-bash">package /nginx/ {
   rule nginx {
        (ip:sip,_^2,chars:timestamp&lt;[,]&gt;,http/request:http_request",chars:status,chars:size,chars:referer",http/agent:http_agent",_")
   }
}
</code></pre>
<h6 id="output"><a class="header" href="#output">output</a></h6>
<pre><code class="language-json">{
	"wp_event_id": 1764645169882925000,
	"sip": "180.57.30.148",
	"timestamp": "21/Jan/2025:01:40:02 +0800",
	"http_request": "GET /nginx-logo.png HTTP/1.1",
	"status": "500",
	"size": "368",
	"referer": "http://207.131.38.110/",
	"http_agent": "Mozilla/5.0(Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36 ",
	"wp_src_key": "socket",
	"wp_src_ip": "127.0.0.1"
}
</code></pre>
<h5 id="vector"><a class="header" href="#vector">Vector</a></h5>
<h6 id="vrl"><a class="header" href="#vrl">VRL</a></h6>
<pre><code class="language- bash">source = '''
  parsed = parse_regex!(.message, r'^(?P&lt;client&gt;\S+) \S+ \S+ \[(?P&lt;time&gt;[^\]]+)\] "(?P&lt;request&gt;[^"]*)" (?P&lt;status&gt;\d{3}) (?P&lt;size&gt;\d+) "(?P&lt;referer&gt;[^"]*)" "(?P&lt;agent&gt;[^"]*)" "(?P&lt;extra&gt;[^"]*)"')
  .sip = parsed.client
  .http_request = parsed.request
  .status = parsed.status
  .size = parsed.size
  .referer = parsed.referer
  .http_agent = parsed.agent
  .timestamp = parsed.time
  del(.message)
'''
</code></pre>
<h6 id="output-1"><a class="header" href="#output-1">output</a></h6>
<pre><code class="language-json">{
	"host": "127.0.0.1",
	"http_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",
	"http_request": "GET /nginx-logo.png HTTP/1.1",
	"port": 58102,
	"referer": "http://207.131.38.110/",
	"sip": "180.57.30.148",
	"size": "368",
	"source_type": "socket",
	"status": "500",
	"timestamp": "21/Jan/2025:01:40:02 +0800"
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td><strong>2,456,100</strong></td><td>559.81</td><td><strong>684.40 % / 824.50 %</strong></td><td><strong>107.36 MB / 120.44 MB</strong></td><td>174B</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td><strong>1,737,200</strong></td><td>395.96</td><td><strong>506.85 % / 650.90 %</strong></td><td><strong>426.09 MB /450.23 MB</strong></td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td><strong>1,084,600</strong></td><td>247.21</td><td><strong>541.19 % / 722.40 %</strong></td><td><strong>696.63 MB / 699.62 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td><strong>540,540</strong></td><td>123.20</td><td><strong>341.51 % / 404.50 %</strong></td><td><strong>230.67 MB / 251.14 MB</strong></td><td>416B</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td><strong>974,100</strong></td><td>222.02</td><td><strong>530.76 % / 660.60 %</strong></td><td><strong>233.23 MB / 238.45 MB</strong></td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td><strong>91,200</strong></td><td>20.79</td><td><strong>186.35 % / 194.70 %</strong></td><td><strong>230.62 MB / 244.22 MB</strong></td><td></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p>https://github.com/vectordotdev/vector/issues/20739?utm_source=chatgpt.com</p>
</blockquote>
<h4 id="aws411b"><a class="header" href="#aws411b">AWS（411B)</a></h4>
<h5 id="warpparse-1"><a class="header" href="#warpparse-1">WarpParse</a></h5>
<h6 id="wpl-1"><a class="header" href="#wpl-1">WPL</a></h6>
<pre><code class="language-bash">package /aws/ {
   rule aws {
        (
            symbol(http),
            chars:timestamp,
            chars:elb,
            chars:client_host,
            chars:target_host,
            chars:request_processing_time,
            chars:target_processing_time,
            chars:response_processing_time,
            chars:elb_status_code,
            chars:target_status_code,
            chars:received_bytes,
            chars:sent_bytes,
            chars:request | (chars:request_method, chars:request_url, chars:request_protocol),
            chars:user_agent,
            chars:ssl_cipher,
            chars:ssl_protocol,
            chars:target_group_arn,
            chars:trace_id,
            chars:domain_name,
            chars:chosen_cert_arn,
            chars:matched_rule_priority,
            chars:request_creation_time,
            chars:actions_executed,
            chars:redirect_url,
            chars:error_reason,
            chars:target_port_list,
            chars:target_status_code_list,
            chars:classification,
            chars:classification_reason,
            chars:traceability_id,
        )
   }
   }
</code></pre>
<h6 id="output-2"><a class="header" href="#output-2">output</a></h6>
<pre><code class="language-json">{
	"wp_event_id": 1764646097464011000,
	"symbol": "http",
	"timestamp": "2018-11-30T22:23:00.186641Z",
	"elb": "app/my-lb",
	"client_host": "192.168.1.10:2000",
	"target_host": "10.0.0.15:8080",
	"request_processing_time": "0.01",
	"target_processing_time": "0.02",
	"response_processing_time": "0.01",
	"elb_status_code": "200",
	"target_status_code": "200",
	"received_bytes": "100",
	"sent_bytes": "200",
	"request_method": "POST",
	"request_url": "https://api.example.com/u?p=1&amp;sid=2&amp;t=3",
	"request_protocol": "HTTP/1.1",
	"user_agent": "Mozilla/5.0 (Win) Chrome/90",
	"ssl_cipher": "ECDHE",
	"ssl_protocol": "TLSv1.3",
	"target_group_arn": "arn:aws:elb:us:123:tg",
	"trace_id": "Root=1-test",
	"domain_name": "api.example.com",
	"chosen_cert_arn": "arn:aws:acm:us:123:cert/short",
	"matched_rule_priority": "1",
	"request_creation_time": "2018-11-30T22:22:48.364000Z",
	"actions_executed": "forward",
	"redirect_url": "https://auth.example.com/r",
	"error_reason": "err",
	"target_port_list": "10.0.0.1:80",
	"target_status_code_list": "200",
	"classification": "cls",
	"classification_reason": "rsn",
	"traceability_id": "TID_x1",
	"wp_src_key": "socket",
	"wp_src_ip": "127.0.0.1"
}
</code></pre>
<h5 id="vector-1"><a class="header" href="#vector-1">Vector</a></h5>
<h6 id="vrl-1"><a class="header" href="#vrl-1">VRL</a></h6>
<pre><code class="language-bash">source = '''
  parsed = parse_regex!(.message, r'^(?P&lt;type&gt;\S+) (?P&lt;timestamp&gt;\S+) (?P&lt;elb&gt;\S+) (?P&lt;client_host&gt;\S+) (?P&lt;target_host&gt;\S+) (?P&lt;request_processing_time&gt;[-\d\.]+) (?P&lt;target_processing_time&gt;[-\d\.]+) (?P&lt;response_processing_time&gt;[-\d\.]+) (?P&lt;elb_status_code&gt;\S+) (?P&lt;target_status_code&gt;\S+) (?P&lt;received_bytes&gt;\d+) (?P&lt;sent_bytes&gt;\d+) "(?P&lt;request_method&gt;\S+) (?P&lt;request_url&gt;[^ ]+) (?P&lt;request_protocol&gt;[^"]+)" "(?P&lt;user_agent&gt;[^"]*)" "(?P&lt;ssl_cipher&gt;[^"]*)" "(?P&lt;ssl_protocol&gt;[^"]*)" (?P&lt;target_group_arn&gt;\S+) "(?P&lt;trace_id&gt;[^"]*)" "(?P&lt;domain_name&gt;[^"]*)" "(?P&lt;chosen_cert_arn&gt;[^"]*)" (?P&lt;matched_rule_priority&gt;\S+) (?P&lt;request_creation_time&gt;\S+) "(?P&lt;actions_executed&gt;[^"]*)" "(?P&lt;redirect_url&gt;[^"]*)" "(?P&lt;error_reason&gt;[^"]*)" "(?P&lt;target_port_list&gt;[^"]*)" "(?P&lt;target_status_code_list&gt;[^"]*)" "(?P&lt;classification&gt;[^"]*)" "(?P&lt;classification_reason&gt;[^"]*)" (?P&lt;traceability_id&gt;\S+)$')
  .timestamp = parsed.timestamp
  .symbol = parsed.type
  .elb = parsed.elb
  .client_host = parsed.client_host
  .target_host = parsed.target_host
  .request_processing_time = parsed.request_processing_time
  .target_processing_time = parsed.target_processing_time
  .response_processing_time = parsed.response_processing_time
  .elb_status_code = parsed.elb_status_code
  .target_status_code = parsed.target_status_code
  .received_bytes = parsed.received_bytes
  .sent_bytes = parsed.sent_bytes
  .request_method = parsed.request_method
  .request_url = parsed.request_url
  .request_protocol = parsed.request_protocol
  .user_agent = parsed.user_agent
  .ssl_cipher = parsed.ssl_cipher
  .ssl_protocol = parsed.ssl_protocol
  .target_group_arn = parsed.target_group_arn
  .trace_id = parsed.trace_id
  .domain_name = parsed.domain_name
  .chosen_cert_arn = parsed.chosen_cert_arn
  .matched_rule_priority = parsed.matched_rule_priority
  .request_creation_time = parsed.request_creation_time
  .actions_executed = parsed.actions_executed
  .redirect_url = parsed.redirect_url
  .error_reason = parsed.error_reason
  .target_port_list = parsed.target_port_list
  .target_status_code_list = parsed.target_status_code_list
  .classification = parsed.classification
  .classification_reason = parsed.classification_reason
  .traceability_id = parsed.traceability_id
  del(.message)
'''
</code></pre>
<h6 id="output-3"><a class="header" href="#output-3">output</a></h6>
<pre><code class="language-json">{
	"actions_executed": "forward",
	"chosen_cert_arn": "arn:aws:acm:us:123:cert/short",
	"classification": "cls",
	"classification_reason": "rsn",
	"client_host": "192.168.1.10:2000",
	"domain_name": "api.example.com",
	"elb": "app/my-lb",
	"elb_status_code": "200",
	"error_reason": "err",
	"host": "127.0.0.1",
	"matched_rule_priority": "1",
	"port": 58786,
	"received_bytes": "100",
	"redirect_url": "https://auth.example.com/r",
	"request_creation_time": "2018-11-30T22:22:48.364000Z",
	"request_method": "POST",
	"request_processing_time": "0.01",
	"request_protocol": "HTTP/1.1",
	"request_url": "https://api.example.com/u?p=1&amp;sid=2&amp;t=3",
	"response_processing_time": "0.01",
	"sent_bytes": "200",
	"source_type": "socket",
	"ssl_cipher": "ECDHE",
	"ssl_protocol": "TLSv1.3",
	"symbol": "http",
	"target_group_arn": "arn:aws:elb:us:123:tg",
	"target_host": "10.0.0.15:8080",
	"target_port_list": "10.0.0.1:80",
	"target_processing_time": "0.02",
	"target_status_code": "200",
	"target_status_code_list": "200",
	"timestamp": "2018-11-30T22:23:00.186641Z",
	"trace_id": "Root=1-test",
	"traceability_id": "TID_x1",
	"user_agent": "Mozilla/5.0 (Win) Chrome/90"
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td><strong>1,012,400</strong></td><td>396.82</td><td><strong>826.53 % / 937.80 %</strong></td><td><strong>237.05 MB / 263.53 MB</strong></td><td>1153B</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td><strong>846,000</strong></td><td>331.60</td><td><strong>554.38 % / 710.90 %</strong></td><td><strong>323.86 MB / 326.97 MB</strong></td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td><strong>347,800</strong></td><td>136.32</td><td><strong>495.90 % / 615.00 %</strong></td><td><strong>481.30 MB /847.70 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td><strong>158,730</strong></td><td>62.22</td><td><strong>633.77 % / 730.30 %</strong></td><td><strong>296.87 MB / 307.42 MB</strong></td><td>2289B</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td><strong>163,600</strong></td><td>64.12</td><td><strong>628.67 % / 674.60 %</strong></td><td><strong>264.21 MB / 275.98 MB</strong></td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td><strong>74,700</strong></td><td>29.28</td><td><strong>374.47 % / 409.50 %</strong></td><td><strong>264.70 MB / 273.64 MB</strong></td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="sysmon1kjson"><a class="header" href="#sysmon1kjson">Sysmon（1K,JSON)</a></h4>
<h5 id="warpparse-2"><a class="header" href="#warpparse-2">WarpParse</a></h5>
<h6 id="wpl-2"><a class="header" href="#wpl-2">WPL</a></h6>
<pre><code class="language-bash">package /sysmon/ {
   rule sysmon {
        (_:pri&lt;&lt;,&gt;&gt;,3*_,_),(_\S\y\s\m\o\n\:,
        json(
            @Id:id,
            @Description/ProcessId:process_id,
            @Level:severity,
            @Opcode:Opcode,
            @ProcessId:ProcessId,
            @Task:Task,
            @ThreadId:ThreadId
            @Version:Version,
            @Description/CommandLine:cmd_line,
            @Description/ParentCommandLine:parent_cmd_line,
            @Description/LogonGuid:logon_guid,
            @Description/LogonId:logon_id,
            @Description/Image:process_path,
            @Description/ParentImage:parent_process_path,
            @Description/ParentProcessGuid:parent_process_guid,
            @Description/ParentProcessId:parent_process_id,
            @Description/ParentUser:parent_process_user,
            @Description/ProcessGuid:process_guid,
            @Description/Company:product_company,
            @Description/Description:process_desc,
            @Description/FileVersion:file_version,
            chars@Description/Hashes:Hashes
            @Description/IntegrityLevel:integrity_level,
            @Description/OriginalFileName:origin_file_name,
            @Description/Product:product_name,
            @Description/RuleName:rule_name,
            @Description/User:user_name,
            chars@Description/UtcTime:occur_time,
            @Description/TerminalSessionId:terminal_session_id,
            @Description/CurrentDirectory:current_dir,
            @Keywords:keywords
            )
        )
    }
   }
</code></pre>
<h6 id="output-4"><a class="header" href="#output-4">output</a></h6>
<pre><code class="language-json">{
	"wp_event_id": 1764657738662604000,
	"cmd_line": "a.exe",
	"product_company": "C",
	"current_dir": "C:\\\\",
	"process_desc": "D",
	"file_version": "1",
	"Hashes": "H",
	"process_path": "C:\\\\Windows\\\\a.exe",
	"integrity_level": "M",
	"logon_guid": "{LG}",
	"logon_id": "1",
	"origin_file_name": "a.exe",
	"parent_cmd_line": "b.exe",
	"parent_process_path": "C:\\\\Windows\\\\b.exe",
	"parent_process_guid": "{PG}",
	"parent_process_id": "1",
	"parent_process_user": "U",
	"process_guid": "{G}",
	"process_id": "1",
	"product_name": "P",
	"rule_name": "R",
	"terminal_session_id": "1",
	"user_name": "U",
	"occur_time": "2025-04-10 06:17:28.503",
	"DescriptionRawMessage": "Process Create\\r\\nRuleName: R",
	"id": "1",
	"keywords": "0",
	"severity": "4",
	"LevelDisplayName": "信息",
	"LogName": "L",
	"MachineName": "A",
	"Opcode": "0",
	"OpcodeDisplayName": "信息",
	"ProcessId": "1",
	"ProviderId": "PID",
	"ProviderName": "P",
	"Task": "1",
	"TaskDisplayName": "Process Create",
	"ThreadId": "1",
	"TimeCreated": "2025-04-10T14:17:28.693228+08:00",
	"Version": "1",
	"wp_src_key": "socket",
	"wp_src_ip": "127.0.0.1"
}
</code></pre>
<h5 id="vector-2"><a class="header" href="#vector-2">Vector</a></h5>
<h6 id="vrl-2"><a class="header" href="#vrl-2">VRL</a></h6>
<pre><code class="language-bash">source = '''
  parsed_msg = parse_regex!(.message, r'^[^{]*(?P&lt;body&gt;\{.*)$')
  parsed = parse_regex!(parsed_msg.body, r'(?s)\{"Id":(?P&lt;Id&gt;[^,]+),"Version":(?P&lt;Version&gt;[^,]+),"Level":(?P&lt;Level&gt;[^,]+),"Task":(?P&lt;Task&gt;[^,]+),"Opcode":(?P&lt;Opcode&gt;[^,]+),"Keywords":(?P&lt;Keywords&gt;[^,]+),"RecordId":(?P&lt;RecordId&gt;[^,]+),"ProviderName":"(?P&lt;ProviderName&gt;[^"]*)","ProviderId":"(?P&lt;ProviderId&gt;[^"]*)","LogName":"(?P&lt;LogName&gt;[^"]*)","ProcessId":(?P&lt;ProcessId&gt;[^,]+),"ThreadId":(?P&lt;ThreadId&gt;[^,]+),"MachineName":"(?P&lt;MachineName&gt;[^"]*)","TimeCreated":"(?P&lt;TimeCreated&gt;[^"]*)","ActivityId":(?P&lt;ActivityId&gt;[^,]+),"RelatedActivityId":(?P&lt;RelatedActivityId&gt;[^,]+),"Qualifiers":(?P&lt;Qualifiers&gt;[^,]+),"LevelDisplayName":"(?P&lt;LevelDisplayName&gt;[^"]*)","OpcodeDisplayName":"(?P&lt;OpcodeDisplayName&gt;[^"]*)","TaskDisplayName":"(?P&lt;TaskDisplayName&gt;[^"]*)","Description":\{"RuleName":"(?P&lt;RuleName&gt;[^"]*)","UtcTime":"(?P&lt;UtcTime&gt;[^"]*)","ProcessGuid":"(?P&lt;ProcessGuid&gt;[^"]*)","ProcessId":"(?P&lt;DescProcessId&gt;[^"]*)","Image":"(?P&lt;Image&gt;[^"]*)","FileVersion":"(?P&lt;FileVersion&gt;[^"]*)","Description":"(?P&lt;Description&gt;[^"]*)","Product":"(?P&lt;Product&gt;[^"]*)","Company":"(?P&lt;Company&gt;[^"]*)","OriginalFileName":"(?P&lt;OriginalFileName&gt;[^"]*)","CommandLine":"(?P&lt;CommandLine&gt;[^"]*)","CurrentDirectory":"(?P&lt;CurrentDirectory&gt;[^"]*)","User":"(?P&lt;User&gt;[^"]*)","LogonGuid":"(?P&lt;LogonGuid&gt;[^"]*)","LogonId":"(?P&lt;LogonId&gt;[^"]*)","TerminalSessionId":"(?P&lt;TerminalSessionId&gt;[^"]*)","IntegrityLevel":"(?P&lt;IntegrityLevel&gt;[^"]*)","Hashes":"(?P&lt;Hashes&gt;[^"]*)","ParentProcessGuid":"(?P&lt;ParentProcessGuid&gt;[^"]*)","ParentProcessId":"(?P&lt;ParentProcessId&gt;[^"]*)","ParentImage":"(?P&lt;ParentImage&gt;[^"]*)","ParentCommandLine":"(?P&lt;ParentCommandLine&gt;[^"]*)","ParentUser":"(?P&lt;ParentUser&gt;[^"]*)"\},"DescriptionRawMessage":"(?P&lt;DescriptionRawMessage&gt;[^"]*)"\}$')
  .cmd_line = parsed.CommandLine
  .product_company = parsed.Company
  .process_id = parsed.ProcessId
  .Opcode = parsed.Opcode
  .ProcessId = parsed.ProcessId 
  .Task = parsed.Task
  .ThreadId = parsed.ThreadId
  .Version = parsed.Version
  .current_dir = parsed.CurrentDirectory
  .process_desc = parsed.Description
  .file_version = parsed.FileVersion
  .Hashes = parsed.Hashes
  .process_path = parsed.Image
  .integrity_level = parsed.IntegrityLevel
  .logon_guid = parsed.LogonGuid
  .logon_id = parsed.LogonId
  .origin_file_name = parsed.OriginalFileName
  .parent_cmd_line = parsed.ParentCommandLine
  .parent_process_path = parsed.ParentImage
  .parent_process_guid = parsed.ParentProcessGuid
  .parent_process_id = parsed.ParentProcessId
  .parent_process_user = parsed.ParentUser
  .process_guid = parsed.ProcessGuid
  .product_name = parsed.Product
  .rule_name = parsed.RuleName
  .terminal_session_id = parsed.TerminalSessionId
  .user_name = parsed.User
  .occur_time = parsed.UtcTime
  .DescriptionRawMessage = parsed.DescriptionRawMessage
  .id = parsed.Id
  .keywords = parsed.Keywords
  .severity = parsed.Level
  .LevelDisplayName = parsed.LevelDisplayName
  .LogName = parsed.LogName
  .MachineName = parsed.MachineName
  .OpcodeDisplayName = parsed.OpcodeDisplayName
  .ProviderId = parsed.ProviderId
  .ProviderName = parsed.ProviderName
  .TaskDisplayName = parsed.TaskDisplayName
  .TimeCreated = parsed.TimeCreated
  del(.message)
</code></pre>
<h6 id="output-5"><a class="header" href="#output-5">output</a></h6>
<pre><code class="language-json">{
	"DescriptionRawMessage": "Process Create\\r\\nRuleName: R",
	"Hashes": "H",
	"LevelDisplayName": "信息",
	"LogName": "L",
	"MachineName": "A",
	"Opcode": "0",
	"OpcodeDisplayName": "信息",
	"ProcessId": "1",
	"ProviderId": "PID",
	"ProviderName": "P",
	"Task": "1",
	"TaskDisplayName": "Process Create",
	"ThreadId": "1",
	"TimeCreated": "2025-04-10T14:17:28.693228+08:00",
	"Version": "1",
	"cmd_line": "a.exe",
	"current_dir": "C:\\\\",
	"file_version": "1",
	"host": "127.0.0.1",
	"id": "1",
	"integrity_level": "M",
	"keywords": "0",
	"logon_guid": "{LG}",
	"logon_id": "1",
	"occur_time": "2025-04-10 06:17:28.503",
	"origin_file_name": "a.exe",
	"parent_cmd_line": "b.exe",
	"parent_process_guid": "{PG}",
	"parent_process_id": "1",
	"parent_process_path": "C:\\\\Windows\\\\b.exe",
	"parent_process_user": "U",
	"port": 50558,
	"process_desc": "D",
	"process_guid": "{G}",
	"process_id": "1",
	"process_path": "C:\\\\Windows\\\\a.exe",
	"product_company": "C",
	"product_name": "P",
	"rule_name": "R",
	"severity": "4",
	"source_type": "socket",
	"terminal_session_id": "1",
	"timestamp": "2025-12-02T06:33:53.716258Z",
	"user_name": "U"
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td><strong>440,000</strong></td><td>413.74</td><td><strong>852.01 % / 943.50 %</strong></td><td><strong>223.52 MB / 338.05 MB</strong></td><td>1552B</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td><strong>418,900</strong></td><td>393.90</td><td><strong>720.42 % / 814.70 %</strong></td><td><strong>455.91 MB / 461.02 MB</strong></td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td><strong>279,700</strong></td><td>263.01</td><td><strong>713.18 % / 789.30 %</strong></td><td><strong>441.34 MB / 453.27 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td><strong>76,717</strong></td><td>72.14</td><td><strong>462.81 % / 563.70 %</strong></td><td><strong>294.87 MB / 312.77 MB</strong></td><td>3259B</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td><strong>111,900</strong></td><td>105.22</td><td><strong>720.04 % / 808.80 %</strong></td><td><strong>362.95 MB / 376.90 MB</strong></td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td><strong>62,100</strong></td><td>58.39</td><td><strong>471.40 % / 543.40 %</strong></td><td><strong>343.65 MB / 355.57 MB</strong></td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="apt3k"><a class="header" href="#apt3k">APT（3K)</a></h4>
<h5 id="warpparse-3"><a class="header" href="#warpparse-3">WarpParse</a></h5>
<h6 id="wpl-3"><a class="header" href="#wpl-3">WPL</a></h6>
<pre><code class="language-bash">package /apt/ {
   rule apt {
        (
            _\#,
            time:timestamp,
            _,
            chars:Hostname,
            _\%\%, 
            chars:ModuleName\/,
            chars:SeverityHeader\/,
            symbol(ANTI-APT)\(,
            chars:type\),
            chars:Count&lt;[,]&gt;,
            _\:,
            chars:Content\(,
        ),
        (
            kv(chars@SyslogId),
            kv(chars@VSys),
            kv(chars@Policy),
            kv(chars@SrcIp),
            kv(chars@DstIp),
            kv(chars@SrcPort),
            kv(chars@DstPort),
            kv(chars@SrcZone),
            kv(chars@DstZone),
            kv(chars@User),
            kv(chars@Protocol),
            kv(chars@Application),
            kv(chars@Profile),
            kv(chars@Direction),
            kv(chars@ThreatType),
            kv(chars@ThreatName),
            kv(chars@Action),
            kv(chars@FileType),
            kv(chars@Hash)\),
        )\,
    }
   }

</code></pre>
<h6 id="output-6"><a class="header" href="#output-6">output</a></h6>
<pre><code class="language-json">{
	"wp_event_id": 1764661811871722000,
	"timestamp": "2025-02-07 15:07:18",
	"Hostname": "USG1000E",
	"ModuleName": "01ANTI-APT",
	"SeverityHeader": "4",
	"symbol": "ANTI-APT",
	"type": "l",
	"Count": "29",
	"Content": "An advanced persistent threat was detected.",
	"SyslogId": "1",
	"VSys": "public-long-virtual-system-name-for-testing-extra-large-value-to-simulate-enterprise-scenario",
	"Policy": "trust-untrust-high-risk-policy-with-deep-inspection-and-layer7-protection-enabled-for-advanced-threat-detection",
	"SrcIp": "192.168.1.123",
	"DstIp": "182.150.63.102",
	"SrcPort": "51784",
	"DstPort": "10781",
	"SrcZone": "trust-zone-with-multiple-segments-for-internal-security-domains-and-access-control",
	"DstZone": "untrust-wide-area-network-zone-with-external-facing-interfaces-and-honeynet-integration",
	"User": "unknown-long-user-field-used-for-simulation-purpose-with-extra-description-and-tags-[tag1][tag2][tag3]-to-reach-required-size",
	"Protocol": "TCP",
	"Application": "HTTP-long-application-signature-identification-with-multiple-behavior-patterns-and-deep-packet-inspection-enabled",
	"Profile": "IPS_default_advanced_extended_profile_with_ml_detection-long",
	"Direction": "aaa-long-direction-field-used-to-extend-size-with-additional-info-about-traffic-orientation-from-client-to-server",
	"ThreatType": "File Reputation with additional descriptive context of multi-layer analysis engine including sandbox-behavioral-signature-ml-static-analysis-and-network-correlation-modules-working-together",
	"ThreatName": "bbb-advanced-threat-campaign-with-code-name-operation-shadow-storm-and-related-IOCs-collected-over-multiple-incidents-in-the-wild-attached-metadata-[phase1][phase2][phase3]",
	"Action": "ccc-block-and-alert-with-deep-scan-followed-by-quarantine-and-forensic-dump-generation-for-further-investigation",
	"FileType": "ddd-executable-binary-with-multiple-packed-layers-suspicious-import-table-behavior-and-evasion-techniques",
	"Hash": "eee1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef-long-hash-value-used-for-testing-purpose-extended-with-multiple-hash-representations-[MD5:aaa111bbb222ccc333]-[SHA1:bbb222ccc333ddd444]-[SHA256:ccc333ddd444eee555]-[SSDEEP:ddd444eee555fff666]-end-of-hash-section, ExtraInfo=\"This is additional extended information purposely added to inflate the total log size for stress testing of log ingestion engines such as Vector, Fluent Bit, self-developed ETL pipelines, and any high-throughput log processing systems. It contains repeated segments to simulate realistic verbose threat intelligence attachment blocks. [SEG-A-BEGIN] The threat was part of a coordinated multi-vector campaign observed across various geographic regions targeting enterprise networks with spear-phishing, watering-hole attacks, and supply-chain compromise vectors. Enriched indicators include C2 domains, malware families, behavioral clusters, sandbox detonation traces, and network telemetry correlation. [SEG-A-END] [SEG-B-BEGIN] Further analysis revealed that the payload exhibited persistence techniques including registry autoruns, scheduled tasks, masquerading, process injection, and lateral movement attempts leveraging remote service creation and stolen credentials. The binary contains multiple obfuscation layers, anti-debugging, anti-VM checks, and unusual API call sequences. [SEG-B-END] [SEG-C-BEGIN] IOC Bundle: Domains=malicious-domain-example-01.com,malicious-domain-example-02.net,malicious-update-service.info; IPs=103.21.244.0,198.51.100.55,203.0.113.77; FileNames=update_service.exe,winlog_service.dll,mscore_update.bin; RegistryKeys=HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run,HKLM\\\\System\\\\Services\\\\FakeService; Mutex=Global\\\\A1B2C3D4E5F6G7H8; YARA Matches=[rule1,rule2,rule3]. [SEG-C-END] EndOfExtraInfo\"",
	"wp_src_key": "socket",
	"wp_src_ip": "127.0.0.1"
}
</code></pre>
<h5 id="vector-3"><a class="header" href="#vector-3">Vector</a></h5>
<h6 id="vrl-3"><a class="header" href="#vrl-3">VRL</a></h6>
<pre><code class="language-bash">source = '''
  parsed_log = parse_regex!(.message, r'(?s)^#(?P&lt;timestamp&gt;\w+\s+\d+\s+\d{4}\s+\d{2}:\d{2}:\d{2}[+-]\d{2}:\d{2})\s+(?P&lt;hostname&gt;\S+)\s+%%(?P&lt;ModuleName&gt;\d+[^/]+)/(?P&lt;SeverityHeader&gt;\d+)/(?P&lt;symbol&gt;[^(]+)\((?P&lt;type&gt;[^)]+)\)\[(?P&lt;count&gt;\d+)\]:\s*(?P&lt;content&gt;[^()]+?)\s*\(SyslogId=(?P&lt;SyslogId&gt;[^,]+),\s+VSys="(?P&lt;VSys&gt;[^"]+)",\s+Policy="(?P&lt;Policy&gt;[^"]+)",\s+SrcIp=(?P&lt;SrcIp&gt;[^,]+),\s+DstIp=(?P&lt;DstIp&gt;[^,]+),\s+SrcPort=(?P&lt;SrcPort&gt;[^,]+),\s+DstPort=(?P&lt;DstPort&gt;[^,]+),\s+SrcZone=(?P&lt;SrcZone&gt;[^,]+),\s+DstZone=(?P&lt;DstZone&gt;[^,]+),\s+User="(?P&lt;User&gt;[^"]+)",\s+Protocol=(?P&lt;Protocol&gt;[^,]+),\s+Application="(?P&lt;Application&gt;[^"]+)",\s+Profile="(?P&lt;Profile&gt;[^"]+)",\s+Direction=(?P&lt;Direction&gt;[^,]+),\s+ThreatType=(?P&lt;ThreatType&gt;[^,]+),\s+ThreatName=(?P&lt;ThreatName&gt;[^,]+),\s+Action=(?P&lt;Action&gt;[^,]+),\s+FileType=(?P&lt;FileType&gt;[^,]+),\s+Hash=(?P&lt;Hash&gt;.*)\)$')
  .Hostname = parsed_log.hostname
  .SrcPort = parsed_log.SrcPort
  .SeverityHeader = parsed_log.SeverityHeader
  .type = parsed_log.type
  .Count = parsed_log.count
  .Content = parsed_log.content
  .VSys = parsed_log.VSys
  .DstPort = parsed_log.DstPort
  .Policy = parsed_log.Policy
  .SrcIp = parsed_log.SrcIp
  .DstIp = parsed_log.DstIp
  .SrcZone = parsed_log.SrcZone
  .DstZone = parsed_log.DstZone
  .User = parsed_log.User
  .Protocol = parsed_log.Protocol
  .ModuleName = parsed_log.ModuleName
  .symbol = parsed_log.symbol
  .timestamp = parsed_log.timestamp
  .SyslogId = parsed_log.SyslogId
  .Application = parsed_log.Application
  .Profile = parsed_log.Profile
  .Direction = parsed_log.Direction
  .ThreatType = parsed_log.ThreatType
  .ThreatName = parsed_log.ThreatName
  .Action = parsed_log.Action
  .FileType = parsed_log.FileType
  .Hash = parsed_log.Hash
  del(.message)
'''
</code></pre>
<h6 id="output-7"><a class="header" href="#output-7">output</a></h6>
<pre><code class="language-json">{
	"Action": "ccc-block-and-alert-with-deep-scan-followed-by-quarantine-and-forensic-dump-generation-for-further-investigation",
	"Application": "HTTP-long-application-signature-identification-with-multiple-behavior-patterns-and-deep-packet-inspection-enabled",
	"Content": "An advanced persistent threat was detected.",
	"Count": "29",
	"Direction": "aaa-long-direction-field-used-to-extend-size-with-additional-info-about-traffic-orientation-from-client-to-server",
	"DstIp": "182.150.63.102",
	"DstPort": "10781",
	"DstZone": "untrust-wide-area-network-zone-with-external-facing-interfaces-and-honeynet-integration",
	"FileType": "ddd-executable-binary-with-multiple-packed-layers-suspicious-import-table-behavior-and-evasion-techniques",
	"Hash": "eee1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef-long-hash-value-used-for-testing-purpose-extended-with-multiple-hash-representations-[MD5:aaa111bbb222ccc333]-[SHA1:bbb222ccc333ddd444]-[SHA256:ccc333ddd444eee555]-[SSDEEP:ddd444eee555fff666]-end-of-hash-section, ExtraInfo=\"This is additional extended information purposely added to inflate the total log size for stress testing of log ingestion engines such as Vector, Fluent Bit, self-developed ETL pipelines, and any high-throughput log processing systems. It contains repeated segments to simulate realistic verbose threat intelligence attachment blocks. [SEG-A-BEGIN] The threat was part of a coordinated multi-vector campaign observed across various geographic regions targeting enterprise networks with spear-phishing, watering-hole attacks, and supply-chain compromise vectors. Enriched indicators include C2 domains, malware families, behavioral clusters, sandbox detonation traces, and network telemetry correlation. [SEG-A-END] [SEG-B-BEGIN] Further analysis revealed that the payload exhibited persistence techniques including registry autoruns, scheduled tasks, masquerading, process injection, and lateral movement attempts leveraging remote service creation and stolen credentials. The binary contains multiple obfuscation layers, anti-debugging, anti-VM checks, and unusual API call sequences. [SEG-B-END] [SEG-C-BEGIN] IOC Bundle: Domains=malicious-domain-example-01.com,malicious-domain-example-02.net,malicious-update-service.info; IPs=103.21.244.0,198.51.100.55,203.0.113.77; FileNames=update_service.exe,winlog_service.dll,mscore_update.bin; RegistryKeys=HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run,HKLM\\\\System\\\\Services\\\\FakeService; Mutex=Global\\\\A1B2C3D4E5F6G7H8; YARA Matches=[rule1,rule2,rule3]. [SEG-C-END] EndOfExtraInfo\"",
	"Hostname": "USG1000E",
	"ModuleName": "01ANTI-APT",
	"Policy": "trust-untrust-high-risk-policy-with-deep-inspection-and-layer7-protection-enabled-for-advanced-threat-detection",
	"Profile": "IPS_default_advanced_extended_profile_with_ml_detection-long",
	"Protocol": "TCP",
	"SeverityHeader": "4",
	"SrcIp": "192.168.1.123",
	"SrcPort": "51784",
	"SrcZone": "trust-zone-with-multiple-segments-for-internal-security-domains-and-access-control",
	"SyslogId": "1",
	"ThreatName": "bbb-advanced-threat-campaign-with-code-name-operation-shadow-storm-and-related-IOCs-collected-over-multiple-incidents-in-the-wild-attached-metadata-[phase1][phase2][phase3]",
	"ThreatType": "File Reputation with additional descriptive context of multi-layer analysis engine including sandbox-behavioral-signature-ml-static-analysis-and-network-correlation-modules-working-together",
	"User": "unknown-long-user-field-used-for-simulation-purpose-with-extra-description-and-tags-[tag1][tag2][tag3]-to-reach-required-size",
	"VSys": "public-long-virtual-system-name-for-testing-extra-large-value-to-simulate-enterprise-scenario",
	"host": "127.0.0.1",
	"port": 55771,
	"source_type": "socket",
	"symbol": "ANTI-APT",
	"timestamp": "Feb  7 2025 15:07:18+08:00",
	"type": "l"
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td><strong>314,200</strong></td><td>1062.84</td><td><strong>700.03 % / 826.30 %</strong></td><td><strong>175.63 MB / 181.05 MB</strong></td><td>985B</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td><strong>298,200</strong></td><td>1008.72</td><td><strong>693.55 % / 762.10 %</strong></td><td><strong>408.87 MB / 481.27 MB</strong></td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td><strong>179,600</strong></td><td>607.53</td><td><strong>605.69 % / 853.20 %</strong></td><td><strong>1016.06 MB/ 1987.94 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td><strong>33,614</strong></td><td>113.71</td><td><strong>563.18 % / 677.50 %</strong></td><td><strong>261.19 MB / 278.39 MB</strong></td><td>1759B</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td><strong>46,100</strong></td><td>155.94</td><td><strong>849.30 % / 921.50 %</strong></td><td><strong>421.18 MB / 445.80 MB</strong></td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td><strong>36,200</strong></td><td>122.45</td><td><strong>688.47 % / 754.70 %</strong></td><td><strong>368.91 MB / 397.16 MB</strong></td><td></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="日志解析转换测试"><a class="header" href="#日志解析转换测试">日志解析转换测试</a></h2>
<h3 id="mac-m4-mini-1"><a class="header" href="#mac-m4-mini-1">Mac M4 Mini</a></h3>
<h4 id="nginx239b-1"><a class="header" href="#nginx239b-1">Nginx（239B）</a></h4>
<p>WarpParse</p>
<h6 id="wpl-4"><a class="header" href="#wpl-4">WPL</a></h6>
<pre><code class="language-bash">package /nginx/ {
   rule nginx {
        (ip:sip,_^2,chars:timestamp&lt;[,]&gt;,http/request",chars:status,chars:size,chars:referer",http/agent",_")
   }
}
</code></pre>
<h6 id="oml"><a class="header" href="#oml">OML</a></h6>
<pre><code class="language-bash">name : nginx
rule : /nginx/*
---
size : digit = take(size);
status : digit = take(status);
str_status = match read(option:[status]) {
    digit(500) =&gt; chars(Internal Server Error);
    digit(404) =&gt; chars(Not Found); 
};
match_chars = match read(option:[wp_src_ip]) {
    ip(127.0.0.1) =&gt; chars(localhost); 
    !ip(127.0.0.1) =&gt; chars(attack_ip); 
};
* : auto = read();
</code></pre>
<h6 id="output-8"><a class="header" href="#output-8">output</a></h6>
<pre><code class="language-bash">{
	"host": "127.0.0.1",
	"http_agent": "Mozilla/5.0(Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36 ",
	"http_request": "GET /nginx-logo.png HTTP/1.1",
	"match_chars": "localhost",
	"referer": "http://207.131.38.110/",
	"sip": "180.57.30.148",
	"size": 368,
	"source_type": "socket",
	"status": 500,
	"str_status": "Internal Server Error",
	"timestamp": "21/Jan/2025:01:40:02 +0800"
}
</code></pre>
<h5 id="vector-4"><a class="header" href="#vector-4">Vector</a></h5>
<h6 id="vrl-4"><a class="header" href="#vrl-4">VRL</a></h6>
<pre><code class="language-toml">source = '''
  parsed = parse_regex!(.message, r'^(?P&lt;client&gt;\S+) \S+ \S+ \[(?P&lt;time&gt;[^\]]+)\] "(?P&lt;request&gt;[^"]*)" (?P&lt;status&gt;\d{3}) (?P&lt;size&gt;\d+) "(?P&lt;referer&gt;[^"]*)" "(?P&lt;agent&gt;[^"]*)" "(?P&lt;extra&gt;[^"]*)"')
  .sip = parsed.client
  .http_request = parsed.request
  .referer = parsed.referer
  .http_agent = parsed.agent
  .timestamp = parsed.time
  del(.message)
  .status = to_int!(parsed.status)
  .size = to_int!(parsed.size)
if .host == "127.0.0.1" {
    .match_chars = "localhost"
} else if .host != "127.0.0.1" {
    .match_chars = "attack_ip"
}  
if .status == 500 {
    .str_status = "Internal Server Error"
} else if .status == 404 {
    .str_status = "Not Found"
}  
'''
</code></pre>
<h6 id="output-9"><a class="header" href="#output-9">output</a></h6>
<pre><code class="language-bash">{
	"host": "127.0.0.1",
	"http_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",
	"http_request": "GET /nginx-logo.png HTTP/1.1",
	"match_chars": "localhost",
	"port": 53894,
	"referer": "http://207.131.38.110/",
	"sip": "180.57.30.148",
	"size": 368,
	"source_type": "socket",
	"status": 500,
	"str_status": "Internal Server Error",
	"timestamp": "21/Jan/2025:01:40:02 +0800"
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td><strong>1,749,200</strong></td><td>398.69</td><td><strong>762.65 %/865.70 %</strong></td><td><strong>143.16 MB/159.22 MB</strong></td><td>521</td></tr>
<tr><td>WarpParse</td><td>TCP -&gt; BlackHole</td><td><strong>1,219,100</strong></td><td>277.87</td><td><strong>485.37 %/625.20 %</strong></td><td><strong>415.22 MB/440.52 MB</strong></td><td></td></tr>
<tr><td>WarpParse</td><td>TCP -&gt; File</td><td><strong>797,700</strong></td><td>181.82</td><td><strong>492.15 %/621.20 %</strong></td><td><strong>523.97 MB/540.97 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td><strong>470,312</strong></td><td>107.20</td><td><strong>372.09 %/423.00 %</strong></td><td><strong>254.05 MB/280.03 MB</strong></td><td>682</td></tr>
<tr><td>Vector</td><td>TCP -&gt; BlackHole</td><td><strong>870,500</strong></td><td>198.41</td><td><strong>514.06 %/639.90 %</strong></td><td><strong>238.50 MB/258.02 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>TCP -&gt; File</td><td><strong>708,00</strong></td><td>16.14</td><td><strong>160.79 %/180.60 %</strong></td><td><strong>226.58 MB/236.41 MB</strong></td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="aws411b-1"><a class="header" href="#aws411b-1">AWS（411B)</a></h4>
<p>WarpParse</p>
<h6 id="wpl-5"><a class="header" href="#wpl-5">WPL</a></h6>
<pre><code class="language-bash">package /aws/ {
   rule aws {
        (
            symbol(http),
            chars:timestamp,
            chars:elb,
            chars:client_host,
            chars:target_host,
            chars:request_processing_time,
            chars:target_processing_time,
            chars:response_processing_time,
            chars:elb_status_code,
            chars:target_status_code,
            chars:received_bytes,
            chars:sent_bytes,
            chars:request | (chars:request_method, chars:request_url, chars:request_protocol),
            chars:user_agent,
            chars:ssl_cipher,
            chars:ssl_protocol,
            chars:target_group_arn,
            chars:trace_id,
            chars:domain_name,
            chars:chosen_cert_arn,
            chars:matched_rule_priority,
            chars:request_creation_time,
            chars:actions_executed,
            chars:redirect_url,
            chars:error_reason,
            chars:target_port_list,
            chars:target_status_code_list,
            chars:classification,
            chars:classification_reason,
            chars:traceability_id,
        )
   }
   }
</code></pre>
<h6 id="oml-1"><a class="header" href="#oml-1">OML</a></h6>
<pre><code class="language-bash">name : aws
rule : /aws/*
---
sent_bytes:digit = take(sent_bytes) ;
target_status_code:digit = take(target_status_code) ;
elb_status_code:digit = take(elb_status_code) ;
extends : obj = object {
    ssl_cipher = read(ssl_cipher);
    ssl_protocol = read(ssl_protocol);
};
match_chars = match read(option:[wp_src_ip]) {
    ip(127.0.0.1) =&gt; chars(localhost); 
    !ip(127.0.0.1) =&gt; chars(attack_ip); 
};
str_elb_status = match read(option:[elb_status_code]) {
    digit(200) =&gt; chars(ok);
    digit(404) =&gt; chars(error); 
};
* : auto = read();
</code></pre>
<h6 id="output-10"><a class="header" href="#output-10">output</a></h6>
<pre><code class="language-bash">{
	"timestamp": "2018-11-30T22:23:00.186641Z",
	"actions_executed": "forward",
	"chosen_cert_arn": "arn:aws:acm:us:123:cert/short",
	"classification": "cls",
	"classification_reason": "rsn",
	"client_host": "192.168.1.10:2000",
	"domain_name": "api.example.com",
	"elb": "app/my-lb",
	"elb_status_code": 200,
	"error_reason": "err",
	"extends": {
		"ssl_cipher": "ECDHE",
		"ssl_protocol": "TLSv1.3"
	},
	"host": "127.0.0.1",
	"match_chars": "localhost",
	"matched_rule_priority": "1",
	"received_bytes": "100",
	"redirect_url": "https://auth.example.com/r",
	"request_creation_time": "2018-11-30T22:22:48.364000Z",
	"request_method": "POST",
	"request_processing_time": "0.01",
	"request_protocol": "HTTP/1.1",
	"request_url": "https://api.example.com/u?p=1&amp;sid=2&amp;t=3",
	"response_processing_time": "0.01",
	"sent_bytes": 200,
	"source_type": "socket",
	"ssl_cipher": "ECDHE",
	"ssl_protocol": "TLSv1.3",
	"str_elb_status": "ok",
	"target_group_arn": "arn:aws:elb:us:123:tg",
	"target_host": "10.0.0.15:8080",
	"target_port_list": "10.0.0.1:80",
	"target_processing_time": "0.02",
	"target_status_code": 200,
	"target_status_code_list": "200",
	"trace_id": "Root=1-test",
	"traceability_id": "TID_x1",
	"user_agent": "Mozilla/5.0 (Win) Chrome/90"
}
</code></pre>
<h5 id="vector-5"><a class="header" href="#vector-5">Vector</a></h5>
<h6 id="vrl-5"><a class="header" href="#vrl-5">VRL</a></h6>
<pre><code class="language-toml">source = '''
  parsed = parse_regex!(.message, r'^(?P&lt;type&gt;\S+) (?P&lt;timestamp&gt;\S+) (?P&lt;elb&gt;\S+) (?P&lt;client_host&gt;\S+) (?P&lt;target_host&gt;\S+) (?P&lt;request_processing_time&gt;[-\d\.]+) (?P&lt;target_processing_time&gt;[-\d\.]+) (?P&lt;response_processing_time&gt;[-\d\.]+) (?P&lt;elb_status_code&gt;\S+) (?P&lt;target_status_code&gt;\S+) (?P&lt;received_bytes&gt;\d+) (?P&lt;sent_bytes&gt;\d+) "(?P&lt;request_method&gt;\S+) (?P&lt;request_url&gt;[^ ]+) (?P&lt;request_protocol&gt;[^"]+)" "(?P&lt;user_agent&gt;[^"]*)" "(?P&lt;ssl_cipher&gt;[^"]*)" "(?P&lt;ssl_protocol&gt;[^"]*)" (?P&lt;target_group_arn&gt;\S+) "(?P&lt;trace_id&gt;[^"]*)" "(?P&lt;domain_name&gt;[^"]*)" "(?P&lt;chosen_cert_arn&gt;[^"]*)" (?P&lt;matched_rule_priority&gt;\S+) (?P&lt;request_creation_time&gt;\S+) "(?P&lt;actions_executed&gt;[^"]*)" "(?P&lt;redirect_url&gt;[^"]*)" "(?P&lt;error_reason&gt;[^"]*)" "(?P&lt;target_port_list&gt;[^"]*)" "(?P&lt;target_status_code_list&gt;[^"]*)" "(?P&lt;classification&gt;[^"]*)" "(?P&lt;classification_reason&gt;[^"]*)" (?P&lt;traceability_id&gt;\S+)$')
  .timestamp = parsed.timestamp
  .symbol = parsed.type
  .elb = parsed.elb
  .client_host = parsed.client_host
  .target_host = parsed.target_host
  .request_processing_time = parsed.request_processing_time
  .target_processing_time = parsed.target_processing_time
  .response_processing_time = parsed.response_processing_time
  .received_bytes = parsed.received_bytes
  .request_method = parsed.request_method
  .request_url = parsed.request_url
  .request_protocol = parsed.request_protocol
  .user_agent = parsed.user_agent
  .ssl_cipher = parsed.ssl_cipher
  .ssl_protocol = parsed.ssl_protocol
  .target_group_arn = parsed.target_group_arn
  .trace_id = parsed.trace_id
  .domain_name = parsed.domain_name
  .chosen_cert_arn = parsed.chosen_cert_arn
  .matched_rule_priority = parsed.matched_rule_priority
  .request_creation_time = parsed.request_creation_time
  .actions_executed = parsed.actions_executed
  .redirect_url = parsed.redirect_url
  .error_reason = parsed.error_reason
  .target_port_list = parsed.target_port_list
  .target_status_code_list = parsed.target_status_code_list
  .classification = parsed.classification
  .classification_reason = parsed.classification_reason
  .traceability_id = parsed.traceability_id
  del(.message)
  .elb_status_code = to_int!(parsed.elb_status_code)
  .target_status_code = to_int!(parsed.target_status_code)
  .sent_bytes = to_int!(parsed.sent_bytes)
if .host == "127.0.0.1" {
    .match_chars = "localhost"
} else if .host != "127.0.0.1" {
    .match_chars = "attack_ip"
}   
if .elb_status_code == 200 {
    .str_elb_status = "ok"
} else if .elb_status_code == 404 {
    .str__elb_status = "error"
}
  .extends = {
    "ssl_cipher": .ssl_cipher,
    "ssl_protocol": .ssl_protocol,
}
'''
</code></pre>
<h6 id="output-11"><a class="header" href="#output-11">output</a></h6>
<pre><code class="language-bash">{
	"actions_executed": "forward",
	"chosen_cert_arn": "arn:aws:acm:us:123:cert/short",
	"classification": "cls",
	"classification_reason": "rsn",
	"client_host": "192.168.1.10:2000",
	"domain_name": "api.example.com",
	"elb": "app/my-lb",
	"elb_status_code": 200,
	"error_reason": "err",
	"extends": {
		"ssl_cipher": "ECDHE",
		"ssl_protocol": "TLSv1.3"
	},
	"host": "127.0.0.1",
	"match_chars": "localhost",
	"matched_rule_priority": "1",
	"port": 53995,
	"received_bytes": "100",
	"redirect_url": "https://auth.example.com/r",
	"request_creation_time": "2018-11-30T22:22:48.364000Z",
	"request_method": "POST",
	"request_processing_time": "0.01",
	"request_protocol": "HTTP/1.1",
	"request_url": "https://api.example.com/u?p=1&amp;sid=2&amp;t=3",
	"response_processing_time": "0.01",
	"sent_bytes": 200,
	"source_type": "socket",
	"ssl_cipher": "ECDHE",
	"ssl_protocol": "TLSv1.3",
	"str_elb_status": "ok",
	"symbol": "http",
	"target_group_arn": "arn:aws:elb:us:123:tg",
	"target_host": "10.0.0.15:8080",
	"target_port_list": "10.0.0.1:80",
	"target_processing_time": "0.02",
	"target_status_code": 200,
	"target_status_code_list": "200",
	"timestamp": "2018-11-30T22:23:00.186641Z",
	"trace_id": "Root=1-test",
	"traceability_id": "TID_x1",
	"user_agent": "Mozilla/5.0 (Win) Chrome/90"
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td><strong>710,400</strong></td><td>278.45</td><td><strong>837.44 %/912.40 %</strong></td><td><strong>230.00 MB/252.95 MB</strong></td><td>1694</td></tr>
<tr><td>WarpParse</td><td>TCP -&gt; BlackHole</td><td><strong>611,800</strong></td><td>239.80</td><td><strong>624.17 %/753.00 %</strong></td><td><strong>478.25 MB/487.42 MB</strong></td><td></td></tr>
<tr><td>WarpParse</td><td>TCP -&gt; File</td><td><strong>318,200</strong></td><td>124.72</td><td><strong>593.16 %/732.60 %</strong></td><td><strong>409.21 MB/547.50 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td><strong>129,743</strong></td><td>50.85</td><td><strong>593.45 %/665.00 %</strong></td><td><strong>283.67 MB/298.16 MB</strong></td><td>2650</td></tr>
<tr><td>Vector</td><td>TCP -&gt; BlackHole</td><td><strong>152,900</strong></td><td>59.93</td><td><strong>611.53 %/677.50 %</strong></td><td><strong>288.53 MB/294.42 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>TCP -&gt; File</td><td><strong>582,00</strong></td><td>22.81</td><td><strong>331.78 %/373.90 %</strong></td><td><strong>276.99 MB/288.42 MB</strong></td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="sysmon1kjson-1"><a class="header" href="#sysmon1kjson-1">Sysmon（1K,JSON)</a></h4>
<p>WarpParse</p>
<h6 id="wpl-6"><a class="header" href="#wpl-6">WPL</a></h6>
<pre><code class="language-bash">package /sysmon/ {
   rule sysmon {
        (_:pri&lt;&lt;,&gt;&gt;,3*_,_),(_\S\y\s\m\o\n\:,
        json(
            @Id:id,
            @Description/ProcessId:process_id,
            @Level:severity,
            @Opcode:Opcode,
            @ProcessId:ProcessId,
            @Task:Task,
            @ThreadId:ThreadId
            @Version:Version,
            @Description/CommandLine:cmd_line,
            @Description/ParentCommandLine:parent_cmd_line,
            @Description/LogonGuid:logon_guid,
            @Description/LogonId:logon_id,
            @Description/Image:process_path,
            @Description/ParentImage:parent_process_path,
            @Description/ParentProcessGuid:parent_process_guid,
            @Description/ParentProcessId:parent_process_id,
            @Description/ParentUser:parent_process_user,
            @Description/ProcessGuid:process_guid,
            @Description/Company:product_company,
            @Description/Description:process_desc,
            @Description/FileVersion:file_version,
            chars@Description/Hashes:Hashes
            @Description/IntegrityLevel:integrity_level,
            @Description/OriginalFileName:origin_file_name,
            @Description/Product:product_name,
            @Description/RuleName:rule_name,
            @Description/User:user_name,
            chars@Description/UtcTime:occur_time,
            @Description/TerminalSessionId:terminal_session_id,
            @Description/CurrentDirectory:current_dir,
            @Keywords:keywords
            )
        )
    }
   }
</code></pre>
<h6 id="oml-2"><a class="header" href="#oml-2">OML</a></h6>
<pre><code class="language-bash">name : sysmon
rule : /sysmon/*
---
Id:digit = take(id) ;
LogonId:digit = take(logon_id) ;
enrich_level = match read(option:[severity]) {
    chars(4) =&gt; chars(severity);
    chars(3) =&gt; chars(normal);
};
extends : obj = object {
    OriginalFileName = read(origin_file_name);
    ParentCommandLine = read(parent_cmd_line);
};
extends_dir = object {
    ParentProcessPath = read(parent_process_path);
    Process_path = read(process_path);
};
match_chars = match read(option:[wp_src_ip]) {
    ip(127.0.0.1) =&gt; chars(localhost); 
    !ip(127.0.0.1) =&gt; chars(attack_ip); 
};
num_range = match read(option:[Id]) {
    in ( digit(0), digit(1000) ) =&gt; read(Id) ;
    _ =&gt; digit(0) ;
};
* : auto = read();
</code></pre>
<h6 id="output-12"><a class="header" href="#output-12">output</a></h6>
<pre><code class="language-bash">{
	"Id": 1,
	"LogonId": 1,
	"enrich_level": "severity",
	"extends": {
		"OriginalFileName": "a.exe",
		"ParentCommandLine": "b.exe"
	},
	"extends_dir": {
		"ParentProcessPath": "C:\\\\Windows\\\\b.exe",
		"Process_path": "C:\\\\Windows\\\\a.exe"
	},
	"match_chars": "localhost",
	"num_range": 1,
	"wp_event_id": 1764813339134818000,
	"cmd_line": "a.exe",
	"product_company": "C",
	"current_dir": "C:\\\\",
	"process_desc": "D",
	"file_version": "1",
	"Hashes": "H",
	"process_path": "C:\\\\Windows\\\\a.exe",
	"integrity_level": "M",
	"logon_guid": "{LG}",
	"origin_file_name": "a.exe",
	"parent_cmd_line": "b.exe",
	"parent_process_path": "C:\\\\Windows\\\\b.exe",
	"parent_process_guid": "{PG}",
	"parent_process_id": "1",
	"parent_process_user": "U",
	"process_guid": "{G}",
	"process_id": "1",
	"product_name": "P",
	"rule_name": "R",
	"terminal_session_id": "1",
	"user_name": "U",
	"occur_time": "2025-04-10 06:17:28.503",
	"DescriptionRawMessage": "Process Create\\r\\nRuleName: R",
	"keywords": "0",
	"severity": "4",
	"LevelDisplayName": "信息",
	"LogName": "L",
	"MachineName": "A",
	"Opcode": "0",
	"OpcodeDisplayName": "信息",
	"ProcessId": "1",
	"ProviderId": "PID",
	"ProviderName": "P",
	"Task": "1",
	"TaskDisplayName": "Process Create",
	"ThreadId": "1",
	"TimeCreated": "2025-04-10T14:17:28.693228+08:00",
	"Version": "1",
	"wp_src_key": "socket",
	"wp_src_ip": "127.0.0.1"
}
</code></pre>
<h5 id="vector-6"><a class="header" href="#vector-6">Vector</a></h5>
<h6 id="vrl-6"><a class="header" href="#vrl-6">VRL</a></h6>
<pre><code class="language-toml">source = '''
  parsed_msg = parse_regex!(.message, r'^[^{]*(?P&lt;body&gt;\{.*)$')
  parsed = parse_regex!(parsed_msg.body, r'(?s)\{"Id":(?P&lt;Id&gt;[^,]+),"Version":(?P&lt;Version&gt;[^,]+),"Level":(?P&lt;Level&gt;[^,]+),"Task":(?P&lt;Task&gt;[^,]+),"Opcode":(?P&lt;Opcode&gt;[^,]+),"Keywords":(?P&lt;Keywords&gt;[^,]+),"RecordId":(?P&lt;RecordId&gt;[^,]+),"ProviderName":"(?P&lt;ProviderName&gt;[^"]*)","ProviderId":"(?P&lt;ProviderId&gt;[^"]*)","LogName":"(?P&lt;LogName&gt;[^"]*)","ProcessId":(?P&lt;ProcessId&gt;[^,]+),"ThreadId":(?P&lt;ThreadId&gt;[^,]+),"MachineName":"(?P&lt;MachineName&gt;[^"]*)","TimeCreated":"(?P&lt;TimeCreated&gt;[^"]*)","ActivityId":(?P&lt;ActivityId&gt;[^,]+),"RelatedActivityId":(?P&lt;RelatedActivityId&gt;[^,]+),"Qualifiers":(?P&lt;Qualifiers&gt;[^,]+),"LevelDisplayName":"(?P&lt;LevelDisplayName&gt;[^"]*)","OpcodeDisplayName":"(?P&lt;OpcodeDisplayName&gt;[^"]*)","TaskDisplayName":"(?P&lt;TaskDisplayName&gt;[^"]*)","Description":\{"RuleName":"(?P&lt;RuleName&gt;[^"]*)","UtcTime":"(?P&lt;UtcTime&gt;[^"]*)","ProcessGuid":"(?P&lt;ProcessGuid&gt;[^"]*)","ProcessId":"(?P&lt;DescProcessId&gt;[^"]*)","Image":"(?P&lt;Image&gt;[^"]*)","FileVersion":"(?P&lt;FileVersion&gt;[^"]*)","Description":"(?P&lt;Description&gt;[^"]*)","Product":"(?P&lt;Product&gt;[^"]*)","Company":"(?P&lt;Company&gt;[^"]*)","OriginalFileName":"(?P&lt;OriginalFileName&gt;[^"]*)","CommandLine":"(?P&lt;CommandLine&gt;[^"]*)","CurrentDirectory":"(?P&lt;CurrentDirectory&gt;[^"]*)","User":"(?P&lt;User&gt;[^"]*)","LogonGuid":"(?P&lt;LogonGuid&gt;[^"]*)","LogonId":"(?P&lt;LogonId&gt;[^"]*)","TerminalSessionId":"(?P&lt;TerminalSessionId&gt;[^"]*)","IntegrityLevel":"(?P&lt;IntegrityLevel&gt;[^"]*)","Hashes":"(?P&lt;Hashes&gt;[^"]*)","ParentProcessGuid":"(?P&lt;ParentProcessGuid&gt;[^"]*)","ParentProcessId":"(?P&lt;ParentProcessId&gt;[^"]*)","ParentImage":"(?P&lt;ParentImage&gt;[^"]*)","ParentCommandLine":"(?P&lt;ParentCommandLine&gt;[^"]*)","ParentUser":"(?P&lt;ParentUser&gt;[^"]*)"\},"DescriptionRawMessage":"(?P&lt;DescriptionRawMessage&gt;[^"]*)"\}$')
  .cmd_line = parsed.CommandLine
  .product_company= parsed.Company
  .Opcode = parsed.Opcode
  .process_id = parsed.ProcessId 
  .ProcessId = parsed.ProcessId 
  .Task = parsed.Task
  .ThreadId = parsed.ThreadId
  .Version = parsed.Version
  .current_dir = parsed.CurrentDirectory
  .process_desc = parsed.Description
  .file_version = parsed.FileVersion
  .Hashes = parsed.Hashes
  .process_path = parsed.Image
  .integrity_level = parsed.IntegrityLevel
  .logon_guid = parsed.LogonGuid
  .origin_file_name = parsed.OriginalFileName
  .parent_cmd_line = parsed.ParentCommandLine
  .parent_process_path = parsed.ParentImage
  .parent_process_guid = parsed.ParentProcessGuid
  .parent_process_id = parsed.ParentProcessId
  .parent_process_user = parsed.ParentUser
  .process_guid = parsed.ProcessGuid
  .product_name = parsed.Product
  .rule_name = parsed.RuleName
  .terminal_session_id = parsed.TerminalSessionId
  .user_name = parsed.User
  .occur_time = parsed.UtcTime
  .DescriptionRawMessage = parsed.DescriptionRawMessage
  .keywords = parsed.Keywords
  .severity = parsed.Level
  .LevelDisplayName = parsed.LevelDisplayName
  .LogName = parsed.LogName
  .MachineName = parsed.MachineName
  .OpcodeDisplayName = parsed.OpcodeDisplayName
  .ProviderId = parsed.ProviderId
  .ProviderName = parsed.ProviderName
  .TaskDisplayName = parsed.TaskDisplayName
  .TimeCreated = parsed.TimeCreated
  del(.message)
  .LogonId = to_int!(parsed.LogonId)
  .Id = to_int!(parsed.Id)
if .host == "127.0.0.1" {
    .match_chars = "localhost"
} else if .host != "127.0.0.1" {
    .match_chars = "attack_ip"
}   
if .severity == "4" {
    .enrich_level = "severity"
} else if .Level == "3" {
    .enrich_level = "normal"
} 
.extends = {
    "OriginalFileName": .origin_file_name,
    "ParentCommandLine": .parent_cmd_line,
}
.extends_dir = {
    "ParentProcessPath": .parent_process_path,
    "Process_path": .process_path,
}
.num_range = if .Id &gt;= 0 &amp;&amp; .Id &lt;= 1000 {
    .Id
} else {
    0
}
'''
</code></pre>
<h6 id="output-13"><a class="header" href="#output-13">output</a></h6>
<pre><code class="language-bash">{
	"DescriptionRawMessage": "Process Create\\r\\nRuleName: R",
	"Hashes": "H",
	"Id": 1,
	"LevelDisplayName": "信息",
	"LogName": "L",
	"LogonId": 1,
	"MachineName": "A",
	"Opcode": "0",
	"OpcodeDisplayName": "信息",
	"ProcessId": "1",
	"ProviderId": "PID",
	"ProviderName": "P",
	"Task": "1",
	"TaskDisplayName": "Process Create",
	"ThreadId": "1",
	"TimeCreated": "2025-04-10T14:17:28.693228+08:00",
	"Version": "1",
	"cmd_line": "a.exe",
	"current_dir": "C:\\\\",
	"enrich_level": "severity",
	"extends": {
		"OriginalFileName": "a.exe",
		"ParentCommandLine": "b.exe"
	},
	"extends_dir": {
		"ParentProcessPath": "C:\\\\Windows\\\\b.exe",
		"Process_path": "C:\\\\Windows\\\\a.exe"
	},
	"file_version": "1",
	"host": "127.0.0.1",
	"integrity_level": "M",
	"keywords": "0",
	"logon_guid": "{LG}",
	"match_chars": "localhost",
	"num_range": 1,
	"occur_time": "2025-04-10 06:17:28.503",
	"origin_file_name": "a.exe",
	"parent_cmd_line": "b.exe",
	"parent_process_guid": "{PG}",
	"parent_process_id": "1",
	"parent_process_path": "C:\\\\Windows\\\\b.exe",
	"parent_process_user": "U",
	"port": 49838,
	"process_desc": "D",
	"process_guid": "{G}",
	"process_id": "1",
	"process_path": "C:\\\\Windows\\\\a.exe",
	"product_company": "C",
	"product_name": "P",
	"rule_name": "R",
	"severity": "4",
	"source_type": "socket",
	"terminal_session_id": "1",
	"timestamp": "2025-12-04T02:04:24.686378Z",
	"user_name": "U"
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td><strong>354,800</strong></td><td>333.63</td><td><strong>880.24 %/935.40 %</strong></td><td><strong>157.88 MB/170.69 MB</strong></td><td>2249</td></tr>
<tr><td>WarpParse</td><td>TCP -&gt; BlackHole</td><td><strong>299,500</strong></td><td>281.63</td><td><strong>664.56 %/749.00 %</strong></td><td><strong>367.47 MB/377.25 MB</strong></td><td></td></tr>
<tr><td>WarpParse</td><td>TCP -&gt; File</td><td><strong>219,900</strong></td><td>206.78</td><td><strong>719.29 %/817.00 %</strong></td><td><strong>431.93 MB/457.17 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td><strong>582,00</strong></td><td>54.73</td><td><strong>431.45 %/527.60 %</strong></td><td><strong>296.28 MB/317.84 MB</strong></td><td>3782</td></tr>
<tr><td>Vector</td><td>TCP -&gt; BlackHole</td><td><strong>97,200</strong></td><td>91.40</td><td><strong>710.83 %/806.80 %</strong></td><td><strong>399.64 MB/424.08 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>TCP -&gt; File</td><td><strong>40,300</strong></td><td>37.90</td><td><strong>391.09 %/497.30 %</strong></td><td><strong>394.67 MB/409.95 MB</strong></td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="apt3k-1"><a class="header" href="#apt3k-1">APT（3K)</a></h4>
<p>WarpParse</p>
<h6 id="wpl-7"><a class="header" href="#wpl-7">WPL</a></h6>
<pre><code class="language-bash">package /apt/ {
   rule apt {
        (
            _\#,
            time:timestamp,
            _,
            chars:Hostname,
            _\%\%, 
            chars:ModuleName\/,
            chars:SeverityHeader\/,
            symbol(ANTI-APT)\(,
            chars:type\),
            chars:Count&lt;[,]&gt;,
            _\:,
            chars:Content\(,
        ),
        (
            kv(chars@SyslogId),
            kv(chars@VSys),
            kv(chars@Policy),
            kv(chars@SrcIp),
            kv(chars@DstIp),
            kv(chars@SrcPort),
            kv(chars@DstPort),
            kv(chars@SrcZone),
            kv(chars@DstZone),
            kv(chars@User),
            kv(chars@Protocol),
            kv(chars@Application),
            kv(chars@Profile),
            kv(chars@Direction),
            kv(chars@ThreatType),
            kv(chars@ThreatName),
            kv(chars@Action),
            kv(chars@FileType),
            kv(chars@Hash)\),
        )\,
    }
   }
</code></pre>
<h6 id="oml-3"><a class="header" href="#oml-3">OML</a></h6>
<pre><code class="language-bash">name : apt
rule : /apt/*
---
count:digit = take(Count) ;
severity:digit = take(SeverityHeader) ;
match_chars = match read(option:[wp_src_ip]) {
    ip(127.0.0.1) =&gt; chars(localhost); 
    !ip(127.0.0.1) =&gt; chars(attack_ip); 
};
num_range = match read(option:[count]) {
    in ( digit(0), digit(1000) ) =&gt; read(count) ;
    _ =&gt; digit(0) ;
};
src_system_log_type = match read(option:[type]) {
    chars(l) =&gt; chars(日志信息);
    chars(s) =&gt; chars(安全日志信息);
};
extends_ip : obj = object {
    DstIp = read(DstIp);
    SrcIp = read(SrcIp);
};
extends_info : obj = object {
    hostname = read(Hostname);
    source_type = read(wp_src_key)
};
* : auto = read();
</code></pre>
<h6 id="output-14"><a class="header" href="#output-14">output</a></h6>
<pre><code class="language-bash">{
	"count": 29,
	"severity": 4,
	"match_chars": "localhost",
	"num_range": 29,
	"src_system_log_type": "日志信息",
	"extends_ip": {
		"DstIp": "182.150.63.102",
		"SrcIp": "192.168.1.123"
	},
	"extends_info": {
		"hostname": "USG1000E",
		"source_type": "socket"
	},
	"wp_event_id": 1764815397395451000,
	"timestamp": "2025-02-07 15:07:18",
	"Hostname": "USG1000E",
	"ModuleName": "01ANTI-APT",
	"symbol": "ANTI-APT",
	"type": "l",
	"Content": "An advanced persistent threat was detected.",
	"SyslogId": "1",
	"VSys": "public-long-virtual-system-name-for-testing-extra-large-value-to-simulate-enterprise-scenario",
	"Policy": "trust-untrust-high-risk-policy-with-deep-inspection-and-layer7-protection-enabled-for-advanced-threat-detection",
	"SrcIp": "192.168.1.123",
	"DstIp": "182.150.63.102",
	"SrcPort": "51784",
	"DstPort": "10781",
	"SrcZone": "trust-zone-with-multiple-segments-for-internal-security-domains-and-access-control",
	"DstZone": "untrust-wide-area-network-zone-with-external-facing-interfaces-and-honeynet-integration",
	"User": "unknown-long-user-field-used-for-simulation-purpose-with-extra-description-and-tags-[tag1][tag2][tag3]-to-reach-required-size",
	"Protocol": "TCP",
	"Application": "HTTP-long-application-signature-identification-with-multiple-behavior-patterns-and-deep-packet-inspection-enabled",
	"Profile": "IPS_default_advanced_extended_profile_with_ml_detection-long",
	"Direction": "aaa-long-direction-field-used-to-extend-size-with-additional-info-about-traffic-orientation-from-client-to-server",
	"ThreatType": "File Reputation with additional descriptive context of multi-layer analysis engine including sandbox-behavioral-signature-ml-static-analysis-and-network-correlation-modules-working-together",
	"ThreatName": "bbb-advanced-threat-campaign-with-code-name-operation-shadow-storm-and-related-IOCs-collected-over-multiple-incidents-in-the-wild-attached-metadata-[phase1][phase2][phase3]",
	"Action": "ccc-block-and-alert-with-deep-scan-followed-by-quarantine-and-forensic-dump-generation-for-further-investigation",
	"FileType": "ddd-executable-binary-with-multiple-packed-layers-suspicious-import-table-behavior-and-evasion-techniques",
	"Hash": "eee1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef-long-hash-value-used-for-testing-purpose-extended-with-multiple-hash-representations-[MD5:aaa111bbb222ccc333]-[SHA1:bbb222ccc333ddd444]-[SHA256:ccc333ddd444eee555]-[SSDEEP:ddd444eee555fff666]-end-of-hash-section, ExtraInfo=\"This is additional extended information purposely added to inflate the total log size for stress testing of log ingestion engines such as Vector, Fluent Bit, self-developed ETL pipelines, and any high-throughput log processing systems. It contains repeated segments to simulate realistic verbose threat intelligence attachment blocks. [SEG-A-BEGIN] The threat was part of a coordinated multi-vector campaign observed across various geographic regions targeting enterprise networks with spear-phishing, watering-hole attacks, and supply-chain compromise vectors. Enriched indicators include C2 domains, malware families, behavioral clusters, sandbox detonation traces, and network telemetry correlation. [SEG-A-END] [SEG-B-BEGIN] Further analysis revealed that the payload exhibited persistence techniques including registry autoruns, scheduled tasks, masquerading, process injection, and lateral movement attempts leveraging remote service creation and stolen credentials. The binary contains multiple obfuscation layers, anti-debugging, anti-VM checks, and unusual API call sequences. [SEG-B-END] [SEG-C-BEGIN] IOC Bundle: Domains=malicious-domain-example-01.com,malicious-domain-example-02.net,malicious-update-service.info; IPs=103.21.244.0,198.51.100.55,203.0.113.77; FileNames=update_service.exe,winlog_service.dll,mscore_update.bin; RegistryKeys=HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run,HKLM\\\\System\\\\Services\\\\FakeService; Mutex=Global\\\\A1B2C3D4E5F6G7H8; YARA Matches=[rule1,rule2,rule3]. [SEG-C-END] EndOfExtraInfo\"",
	"wp_src_key": "socket",
	"wp_src_ip": "127.0.0.1"
}
</code></pre>
<h5 id="vector-7"><a class="header" href="#vector-7">Vector</a></h5>
<pre><code class="language-toml">source = '''
parsed_log = parse_regex!(.message, r'(?s)^#(?P&lt;timestamp&gt;\w+\s+\d+\s+\d{4}\s+\d{2}:\d{2}:\d{2}[+-]\d{2}:\d{2})\s+(?P&lt;hostname&gt;\S+)\s+%%(?P&lt;ModuleName&gt;\d+[^/]+)/(?P&lt;SeverityHeader&gt;\d+)/(?P&lt;symbol&gt;[^(]+)\((?P&lt;type&gt;[^)]+)\)\[(?P&lt;count&gt;\d+)\]:\s*(?P&lt;content&gt;[^()]+?)\s*\(SyslogId=(?P&lt;SyslogId&gt;[^,]+),\s+VSys="(?P&lt;VSys&gt;[^"]+)",\s+Policy="(?P&lt;Policy&gt;[^"]+)",\s+SrcIp=(?P&lt;SrcIp&gt;[^,]+),\s+DstIp=(?P&lt;DstIp&gt;[^,]+),\s+SrcPort=(?P&lt;SrcPort&gt;[^,]+),\s+DstPort=(?P&lt;DstPort&gt;[^,]+),\s+SrcZone=(?P&lt;SrcZone&gt;[^,]+),\s+DstZone=(?P&lt;DstZone&gt;[^,]+),\s+User="(?P&lt;User&gt;[^"]+)",\s+Protocol=(?P&lt;Protocol&gt;[^,]+),\s+Application="(?P&lt;Application&gt;[^"]+)",\s+Profile="(?P&lt;Profile&gt;[^"]+)",\s+Direction=(?P&lt;Direction&gt;[^,]+),\s+ThreatType=(?P&lt;ThreatType&gt;[^,]+),\s+ThreatName=(?P&lt;ThreatName&gt;[^,]+),\s+Action=(?P&lt;Action&gt;[^,]+),\s+FileType=(?P&lt;FileType&gt;[^,]+),\s+Hash=(?P&lt;Hash&gt;.*)\)$')
  .Hostname = parsed_log.hostname
  .SrcPort = parsed_log.SrcPort
  .SeverityHeader = parsed_log.SeverityHeader
  .type = parsed_log.type
  .Content = parsed_log.content
  .VSys = parsed_log.VSys
  .DstPort = parsed_log.DstPort
  .Policy = parsed_log.Policy
  .SrcIp = parsed_log.SrcIp
  .DstIp = parsed_log.DstIp
  .SrcZone = parsed_log.SrcZone
  .DstZone = parsed_log.DstZone
  .User = parsed_log.User
  .Protocol = parsed_log.Protocol
  .ModuleName = parsed_log.ModuleName
  .symbol = parsed_log.symbol
  .timestamp = parsed_log.timestamp
  .SyslogId = parsed_log.SyslogId
  .Application = parsed_log.Application
  .Profile = parsed_log.Profile
  .Direction = parsed_log.Direction
  .ThreatType = parsed_log.ThreatType
  .ThreatName = parsed_log.ThreatName
  .Action = parsed_log.Action
  .FileType = parsed_log.FileType
  .Hash = parsed_log.Hash
  del(.message)
.severity = to_int!(parsed_log.SeverityHeader)
.count = to_int!(parsed_log.count)
if .host == "127.0.0.1" {
    .match_chars = "localhost"
} else if .host != "127.0.0.1" {
    .match_chars = "attack_ip"
}  
if .type == "l" {
.src_system_log_type = "日志信息"
} else if .type == "s" {
.src_system_log_type = "安全日志信息"
}
.extends_ip = {
    "DstIp": .DstIp,
    "SrcIp": .SrcIp,
}
.extends_info = {
    "hostname": .Hostname,
    "source_type": .source_type,
}
.num_range = if .count &gt;= 0 &amp;&amp; .count &lt;= 1000 {
    .count
} else {
    0
}
'''
</code></pre>
<h6 id="output-15"><a class="header" href="#output-15">output</a></h6>
<pre><code class="language-bash">{
	"Action": "ccc-block-and-alert-with-deep-scan-followed-by-quarantine-and-forensic-dump-generation-for-further-investigation",
	"Application": "HTTP-long-application-signature-identification-with-multiple-behavior-patterns-and-deep-packet-inspection-enabled",
	"Content": "An advanced persistent threat was detected.",
	"Direction": "aaa-long-direction-field-used-to-extend-size-with-additional-info-about-traffic-orientation-from-client-to-server",
	"DstIp": "182.150.63.102",
	"DstPort": "10781",
	"DstZone": "untrust-wide-area-network-zone-with-external-facing-interfaces-and-honeynet-integration",
	"FileType": "ddd-executable-binary-with-multiple-packed-layers-suspicious-import-table-behavior-and-evasion-techniques",
	"Hash": "eee1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef-long-hash-value-used-for-testing-purpose-extended-with-multiple-hash-representations-[MD5:aaa111bbb222ccc333]-[SHA1:bbb222ccc333ddd444]-[SHA256:ccc333ddd444eee555]-[SSDEEP:ddd444eee555fff666]-end-of-hash-section, ExtraInfo=\"This is additional extended information purposely added to inflate the total log size for stress testing of log ingestion engines such as Vector, Fluent Bit, self-developed ETL pipelines, and any high-throughput log processing systems. It contains repeated segments to simulate realistic verbose threat intelligence attachment blocks. [SEG-A-BEGIN] The threat was part of a coordinated multi-vector campaign observed across various geographic regions targeting enterprise networks with spear-phishing, watering-hole attacks, and supply-chain compromise vectors. Enriched indicators include C2 domains, malware families, behavioral clusters, sandbox detonation traces, and network telemetry correlation. [SEG-A-END] [SEG-B-BEGIN] Further analysis revealed that the payload exhibited persistence techniques including registry autoruns, scheduled tasks, masquerading, process injection, and lateral movement attempts leveraging remote service creation and stolen credentials. The binary contains multiple obfuscation layers, anti-debugging, anti-VM checks, and unusual API call sequences. [SEG-B-END] [SEG-C-BEGIN] IOC Bundle: Domains=malicious-domain-example-01.com,malicious-domain-example-02.net,malicious-update-service.info; IPs=103.21.244.0,198.51.100.55,203.0.113.77; FileNames=update_service.exe,winlog_service.dll,mscore_update.bin; RegistryKeys=HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run,HKLM\\\\System\\\\Services\\\\FakeService; Mutex=Global\\\\A1B2C3D4E5F6G7H8; YARA Matches=[rule1,rule2,rule3]. [SEG-C-END] EndOfExtraInfo\"",
	"Hostname": "USG1000E",
	"ModuleName": "01ANTI-APT",
	"Policy": "trust-untrust-high-risk-policy-with-deep-inspection-and-layer7-protection-enabled-for-advanced-threat-detection",
	"Profile": "IPS_default_advanced_extended_profile_with_ml_detection-long",
	"Protocol": "TCP",
	"SeverityHeader": "4",
	"SrcIp": "192.168.1.123",
	"SrcPort": "51784",
	"SrcZone": "trust-zone-with-multiple-segments-for-internal-security-domains-and-access-control",
	"SyslogId": "1",
	"ThreatName": "bbb-advanced-threat-campaign-with-code-name-operation-shadow-storm-and-related-IOCs-collected-over-multiple-incidents-in-the-wild-attached-metadata-[phase1][phase2][phase3]",
	"ThreatType": "File Reputation with additional descriptive context of multi-layer analysis engine including sandbox-behavioral-signature-ml-static-analysis-and-network-correlation-modules-working-together",
	"User": "unknown-long-user-field-used-for-simulation-purpose-with-extra-description-and-tags-[tag1][tag2][tag3]-to-reach-required-size",
	"VSys": "public-long-virtual-system-name-for-testing-extra-large-value-to-simulate-enterprise-scenario",
	"count": 29,
	"extends_info": {
		"hostname": "USG1000E",
		"source_type": "socket"
	},
	"extends_ip": {
		"DstIp": "182.150.63.102",
		"SrcIp": "192.168.1.123"
	},
	"host": "127.0.0.1",
	"match_chars": "localhost",
	"num_range": 29,
	"port": 51272,
	"severity": 4,
	"source_type": "socket",
	"src_system_log_type": "日志信息",
	"symbol": "ANTI-APT",
	"timestamp": "Feb  7 2025 15:07:18+08:00",
	"type": "l"
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td><strong>280,000</strong></td><td>947.15</td><td><strong>768.50 %/868.90 %</strong></td><td><strong>172.72 MB/178.23 MB</strong></td><td>1638</td></tr>
<tr><td>WarpParse</td><td>TCP -&gt; BlackHole</td><td><strong>238,900</strong></td><td>808.12</td><td><strong>657.14 %/705.40 %</strong></td><td><strong>364.73 MB/389.94 MB</strong></td><td></td></tr>
<tr><td>WarpParse</td><td>TCP -&gt; File</td><td><strong>169,800</strong></td><td>574.38</td><td><strong>663.90 %/883.80 %</strong></td><td><strong>871.77 MB/1500.22 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td><strong>306,12</strong></td><td>103.55</td><td><strong>560.94 %/654.40 %</strong></td><td><strong>248.00 MB/273.02 MB</strong></td><td>2259</td></tr>
<tr><td>Vector</td><td>TCP -&gt; BlackHole</td><td><strong>340,00</strong></td><td>115.01</td><td><strong>693.47 %/848.80 %</strong></td><td><strong>408.92 MB/430.59 MB</strong></td><td></td></tr>
<tr><td>Vector</td><td>TCP -&gt; File</td><td><strong>249,00</strong></td><td>84.23</td><td><strong>538.78 %/644.90 %</strong></td><td><strong>393.26 MB/420.05 MB</strong></td><td></td></tr>
</tbody>
</table>
</div>
<h3 id="linux-vps"><a class="header" href="#linux-vps">Linux VPS</a></h3>
<p>平台数据仍在采集中，先保留统一表格，便于后续补录。</p>
<h4 id="nginx239b-2"><a class="header" href="#nginx239b-2">Nginx（239B）</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="aws411b-2"><a class="header" href="#aws411b-2">AWS（411B)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="sysmon1kjson-2"><a class="header" href="#sysmon1kjson-2">Sysmon（1K,JSON)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="apt3k-2"><a class="header" href="#apt3k-2">APT（3K)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>引擎</th><th>拓扑</th><th>EPS</th><th>MPS</th><th>CPU (avg/peak)</th><th>MEM (avg/peak)</th><th>规则大小</th></tr>
</thead>
<tbody>
<tr><td>WarpParse</td><td>File -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td>Vector</td><td>File -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td></td><td>TCP -&gt; BlackHole</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr><td></td><td>TCP -&gt; File</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="connector-实现指南"><a class="header" href="#connector-实现指南">Connector 实现指南</a></h1>
<h2 id="架构总览"><a class="header" href="#架构总览">架构总览</a></h2>
<ul>
<li>运行时通过 <code>connectors/registry</code> 维护 Source/Sink Factory 的注册表，利用 <code>OnceCell + RwLock</code> 管理工厂实例，并在 <code>register_*</code> 时记录调用位置，方便诊断（<code>src/connectors/registry.rs:1-99</code>）。</li>
<li>应用启动时统一调用 <code>connectors/startup::init_runtime_registries</code>：它一次性注册内置 Sink（file/syslog/tcp/test_rescue/blackhole）与 Source（syslog/tcp/file），随后打印最终的 kind 列表，确保外部动态工厂也可追踪（<code>src/connectors/startup.rs:1-42</code>）。</li>
<li>若还需桥接 <code>ConnectorKindAdapter</code>，使用 <code>connectors/adapter.rs</code> 中的注册表；在 engine 内注册后，后续组件都能通过 kind 查到各自的 adapter（<code>src/connectors/adapter.rs:1-43</code>）。</li>
</ul>
<pre><code>         ┌────────────────────────────────────┐
         │     wp_connector_api (Traits)     │
         │ ┌───────────────────────────────┐ │
         │ │ SourceFactory / SinkFactory   │ │
         │ │ DataSource / Async* traits    │ │
         │ └───────────────────────────────┘ │
         └────────────────────────────────────┘
                         │ 实现
                         ▼
 ┌─────────────────────────────────────────────────────────────┐
 │              具体 Source / Sink 实现 (wp-engine)            │
 │ ┌─────────────────────────────────────────────────────────┐ │
 │ │ FileSourceSpec ──► FileSourceFactory ──► FileSource     │ │
 │ │ TcpSourceSpec  ──► TcpSourceFactory  ──► TcpSource      │ │
 │ │ SyslogSourceSpec ─► SyslogFactory     ─► Tcp/Udp Source │ │
 │ │ TcpSinkSpec    ──► TcpFactory         ─► TcpSink        │ │
 │ └─────────────────────────────────────────────────────────┘ │
 └─────────────────────────────────────────────────────────────┘
                         │ 注册
                         ▼
           ┌───────────────────────────────────┐
           │ connectors::registry / startup    │
           │  • register_*_factory(...)        │
           │  • log_registered_kinds()         │
           └───────────────────────────────────┘
                         │ 提供统一入口
                         ▼
           ┌───────────────────────────────────┐
           │ runtime / orchestrator            │
           │  读取 kind → 获取 Factory → Build │
           └───────────────────────────────────┘
</code></pre>
<h2 id="必须实现的-trait"><a class="header" href="#必须实现的-trait">必须实现的 Trait</a></h2>
<ul>
<li><strong>SourceFactory/SinkFactory</strong>：来自 <code>wp_connector_api</code>。工厂需实现 <code>kind(&amp;self)</code>, <code>validate_spec(&amp;self, &amp;Resolved*Spec)</code> 与 <code>build(&amp;self, &amp;Resolved*Spec, &amp;*Ctx)</code>。示例参见 <code>src/sources/file/factory.rs:65-123</code> 与 <code>src/sinks/backends/tcp.rs:240-259</code>。</li>
<li><strong>DataSource</strong>：Source 运行时实现 <code>DataSource</code> trait，提供 <code>receive/try_receive/can_try_receive/identifier</code> 等接口；<code>FileSource</code> 在 <code>src/sources/file/source.rs</code> 展示了如何在 <code>receive</code> 中返回批次并在 <code>stop</code> 时清理。</li>
<li><strong>AsyncCtrl/AsyncRecordSink/AsyncRawDataSink</strong>：Sink 运行时需实现这些异步 trait 以接收结构化记录和原始字符串；<code>TcpSink</code> 在 <code>src/sinks/backends/tcp.rs:62-215</code> 给出了完整实现（含批量方法）。</li>
<li><strong>可选：ConnectorKindAdapter</strong>：若需要在运行时动态选择不同工厂组合，实现 <code>wp_connector_api::ConnectorKindAdapter</code> 并通过 <code>connectors/adapter.rs</code> 注册；适用于同一 kind 在不同部署模式下映射到不同底层实现。</li>
<li><strong>工程工具（wp-proj）一致性</strong>：<code>crates/wp-proj</code> 中的 <code>Sources</code>、<code>Sinks</code>、<code>Wpl</code>、<code>Oml</code> 管理器会读取 <code>EngineConfig</code>（即 <code>conf/wparse.toml</code>）中的 <code>src_root</code>/<code>sink_root</code>/<code>rule_root</code>/<code>oml_root</code>，因此 connector 初始化必须保证这些路径正确。wp-proj 的 CLI 在调用 <code>init/check</code> 时直接依赖这些路径，无需再手工推断目录。</li>
</ul>
<h2 id="sourcesink-实现步骤"><a class="header" href="#sourcesink-实现步骤">Source/Sink 实现步骤</a></h2>
<ol>
<li><strong>先建立静态 Spec</strong>：
<ul>
<li>在 Source 端，以 <code>FileSourceSpec</code> 为例，它负责从 <code>ResolvedSourceSpec</code> 中提取路径/编码/实例数并完成参数校验；<code>validate_spec</code> 与 <code>build</code> 都仅调用 <code>from_resolved</code>，防止重复解析（<code>src/sources/file/factory.rs:15-123</code>）。</li>
<li>在 Sink 端同理，<code>TcpSinkSpec</code> 负责提取地址/端口/分帧信息并校验布尔开关；后续连接逻辑只接收 <code>TcpSinkSpec</code>，避免直接访问动态 Map（<code>src/sinks/backends/tcp.rs:18-105</code>）。</li>
</ul>
</li>
<li><strong>在 <code>validate_spec</code> 中仅做转换</strong>：始终让 <code>validate_spec</code> 里只调用一次 <code>Spec::from_*</code>，把所有错误统一转成 <code>SourceReason::from_conf</code> 或 <code>SinkError</code>，确保 CLI/控制面可以直接提示参数问题（<code>src/sources/file/factory.rs:73-82</code>、<code>src/sinks/backends/tcp.rs:240-259</code>）。</li>
<li><strong>在 <code>build</code> 中复用静态 Spec</strong>：<code>build</code> 里禁止再次从 <code>params</code> 中取值，直接使用 Spec 产物，并在需要时注入上下文（如 <code>SourceBuildCtx</code> 的路径/副本信息或 <code>SinkBuildCtx</code> 的限速值）。</li>
<li><strong>注册工厂</strong>：实现完成后，在相应模块提供 <code>register_*</code> 函数并在 <code>connectors/startup</code> 中调用。FileSource 通过 <code>register_factory_only</code> 注册到全局表，是最简示例（<code>src/sources/file/factory.rs:126-129</code>）。</li>
<li><strong>保持日志可读</strong>：网络类实现应在首次连接、首个包、错误等关键点打印 <code>info!</code>/<code>warn!</code>（可参考 <code>TcpSink::connect</code> 与 <code>SyslogSourceFactory</code> 中的日志调用）。</li>
<li><strong>确保 EngineConfig 可解析</strong>：因为 wp-proj 的管理命令和 CLI 检查都直接加载 <code>conf/wparse.toml</code> 来定位 <code>topology</code>/<code>models</code> 路径，connector 的默认模板、示例配置必须与 EngineConfig 中的路径保持一致。一旦添加新的默认目录或模板，需要同步更新 <code>wparse.toml</code> 示例和 <code>EngineConfig::init</code> 的默认字段。</li>
</ol>
<h2 id="参数校验与-spec-转换建议"><a class="header" href="#参数校验与-spec-转换建议">参数校验与 Spec 转换建议</a></h2>
<ul>
<li><strong>一次性检查</strong>：尽量用 <code>anyhow::ensure!</code> 或模式匹配在 Spec 构造时完成所有合法性检查，再把 <code>anyhow::Error</code> 映射回连接器的 <code>Reason</code>（示例：<code>TcpSourceSpec::from_params</code> 对端口/缓冲区/帧模式/实例数的校验，见 <code>src/sources/tcp/config.rs:4-63</code>）。</li>
<li><strong>集中处理布尔或枚举参数</strong>：布尔开关使用 <code>as_bool()</code> 并在 Spec 层给出默认值；枚举按 <code>to_ascii_lowercase()</code> 匹配，防止大小写问题（示例：<code>SyslogSourceSpec</code> 中的 <code>protocol</code> 和 <code>header_mode</code>，见 <code>src/sources/syslog/config.rs:7-74</code>）。</li>
<li><strong>先校验标签</strong>：Source 实现通常需要在 <code>validate_spec</code> 开头调用 <code>wp_data_model::tags::validate_tags</code>，并在 <code>build</code> 时通过 <code>parse_tags</code> 生成 <code>TagSet</code>（<code>src/sources/file/factory.rs:73-123</code>）。</li>
</ul>
<h2 id="启动与诊断"><a class="header" href="#启动与诊断">启动与诊断</a></h2>
<ul>
<li><strong>集中注册</strong>：确保新工厂的 <code>register_*</code> 在 <code>connectors/startup::init_runtime_registries</code> 中被调用，否则 CLI 虽能解析配置，但运行期无法找到对应 kind。</li>
<li><strong>列出注册结果</strong>：通过 <code>connectors/startup::log_registered_kinds</code> 可以快速查看当前进程加载的 Source/Sink，若出现找不到的 kind，优先检查是否忘记注册或重复注册（<code>src/connectors/startup.rs:25-42</code>）。</li>
<li><strong>适配器使用场景</strong>：如果需要把同一种 connector kind 映射到多个 factory（比如企业版扩展），在 <code>adapter.rs</code> 注册 <code>ConnectorKindAdapter</code>，再由业务层读取 <code>list_kinds()</code> 决定要启用的适配路径（<code>src/connectors/adapter.rs:1-43</code>）。</li>
</ul>
<h2 id="测试策略"><a class="header" href="#测试策略">测试策略</a></h2>
<ul>
<li><strong>工厂级单元测试</strong>：所有新工厂都应像 File/Tcp/Syslog 一样包含 <code>#[cfg(test)]</code> 模块，验证参数校验、实例数量、Tag 注入等关键路径。例如 <code>file::factory</code> 中的 <code>build_spec_with_instances</code>、<code>compute_file_ranges_aligns_to_line_boundaries</code> 等用例（<code>src/sources/file/factory.rs:188-266</code>）。</li>
<li><strong>端到端验证</strong>：网络类 Source/Sink 建议提供受控的 e2e 测试，配合条件变量（如 <code>WP_NET_TESTS</code>）运行真实 TCP/UDP 循环，参考 <code>src/sinks/backends/tcp.rs:287-356</code> 与 <code>src/sources/tcp/conn/connection.rs:500-552</code> 的用例。</li>
<li><strong>保持幂等</strong>：测试/工具函数不应依赖全局状态，使用 <code>register_*</code> 时若会污染全局 registry，要在测试结束后清理或使用隔离的 runner。</li>
</ul>
<h2 id="提交流程提示"><a class="header" href="#提交流程提示">提交流程提示</a></h2>
<ol>
<li><strong>文档更新</strong>：当新 connector 引入新的 CLI/配置参数，需同步更新 <code>docs</code>、<code>wpgen</code> 模板以及任何 CLI 帮助文本。</li>
<li><strong>代码规范</strong>：遵守 Rustfmt、Clippy 以及仓库指引（宏/特性集中定义、错误提示使用 <code>SourceReason/SinkReason</code>）。</li>
<li><strong>日志与可观测性</strong>：一旦连接建立、首包发送或异常发生应输出 <code>info!/warn!</code>，便于排查跨机问题。</li>
<li><strong>注册核查</strong>：PR 提交前检查 <code>connectors/startup.rs</code> 是否包含新工厂的注册逻辑，并在日志里确认可见。</li>
</ol>
<p>遵循以上步骤，新 connector 可以快速接入 engine，并保持配置、诊断与回归测试的统一体验。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/lang-switch.js"></script>
        <script src="../theme/version-badge.js"></script>
        <script src="mermaid-eefea253.min.js"></script>
        <script src="mermaid-init-ccf746f1.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
